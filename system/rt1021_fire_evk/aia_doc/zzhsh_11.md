#### p.AIPSTZ1.OPACR1
<lang=dft>
 (rw)  [1;33m0x4007c044[0m (0x4007c000 + 0x0044)
Off-Platform Peripheral Access Control Registers
 (rw) (04)  [0;32mOPAC15[0m  - [03:00] -  Off-platform Peripheral Access Control 15
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC14[0m  - [07:04] -  Off-platform Peripheral Access Control 14
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC13[0m  - [11:08] -  Off-platform Peripheral Access Control 13
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC12[0m  - [15:12] -  Off-platform Peripheral Access Control 12
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC11[0m  - [19:16] -  Off-platform Peripheral Access Control 11
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC10[0m  - [23:20] -  Off-platform Peripheral Access Control 10
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC9[0m  - [27:24] -  Off-platform Peripheral Access Control 9
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC8[0m  - [31:28] -  Off-platform Peripheral Access Control 8
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
</lang>
#### p.AIPSTZ2.OPACR
<lang=dft>
 (rw)  [1;33m0x4017c040[0m (0x4017c000 + 0x0040)
Off-Platform Peripheral Access Control Registers
 (rw) (04)  [0;32mOPAC7[0m  - [03:00] -  Off-platform Peripheral Access Control 7
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC6[0m  - [07:04] -  Off-platform Peripheral Access Control 6
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC5[0m  - [11:08] -  Off-platform Peripheral Access Control 5
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC4[0m  - [15:12] -  Off-platform Peripheral Access Control 4
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC3[0m  - [19:16] -  Off-platform Peripheral Access Control 3
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC2[0m  - [23:20] -  Off-platform Peripheral Access Control 2
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC1[0m  - [27:24] -  Off-platform Peripheral Access Control 1
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
 (rw) (04)  [0;32mOPAC0[0m  - [31:28] -  Off-platform Peripheral Access Control 0
      #xxx0 - TP0 :
         Accesses from an untrusted master are allowed.
      #xxx1 - TP1 :
         Accesses from an untrusted master are not allowed. If an access is atte
         mpted by an untrusted master, the access is terminated with an error re
         sponse and no peripheral access is initiated on the IPS bus.
</lang>
#### p.aipstz2.opacr1
<link=p.AIPSTZ2.OPACR1>
#### AIPSTZ3.OPACR1
<link=p.AIPSTZ3.OPACR1>
#### p.aipstz3.opacr3
<link=p.AIPSTZ3.OPACR3>
#### p.aipstz4.opacr2
<link=p.AIPSTZ4.OPACR2>
#### pit.tctrl3
<link=p.PIT.TCTRL3>
#### p.pit.tflg3
<link=p.PIT.TFLG3>
#### PIT.LTMR64L
<link=p.PIT.LTMR64L>
#### p.CMP1.DACCR
<lang=dft>
 (rw)  [1;33m0x40094004[0m (0x40094000 + 0x0004)
DAC Control Register
 (rw) (06)  [0;32mVOSEL[0m  - [05:00] -  DAC Output Voltage Select
 (rw) (01)  [0;32mVRSEL[0m  - [06:06] -  Supply Voltage Reference Source Select
      0 - VRSEL_0 :
         Vin1 is selected as resistor ladder network supply reference.
      0x1 - VRSEL_1 :
         Vin2 is selected as resistor ladder network supply reference.
 (rw) (01)  [0;32mDACEN[0m  - [07:07] -  DAC Enable
      0 - DACEN_0 :
         DAC is disabled.
      0x1 - DACEN_1 :
         DAC is enabled.
</lang>
#### p.CMP2.FPR
<lang=dft>
 (rw)  [1;33m0x4009400a[0m (0x40094008 + 0x0002)
CMP Filter Period Register
 (rw) (08)  [0;32mFILT_PER[0m  - [07:00] -  Filter Sample Period
</lang>
#### p.cmp2.daccr
<link=p.CMP2.DACCR>
#### p.CMP2.MUXCR
<lang=dft>
 (rw)  [1;33m0x4009400d[0m (0x40094008 + 0x0005)
MUX Control Register
 (rw) (03)  [0;32mMSEL[0m  - [02:00] -  Minus Input Mux Control
      0 - MSEL_0 :
         IN0
      0x1 - MSEL_1 :
         IN1
      0x2 - MSEL_2 :
         IN2
      0x3 - MSEL_3 :
         IN3
      0x4 - MSEL_4 :
         IN4
      0x5 - MSEL_5 :
         IN5
      0x6 - MSEL_6 :
         IN6
      0x7 - MSEL_7 :
         IN7
 (rw) (03)  [0;32mPSEL[0m  - [05:03] -  Plus Input Mux Control
      0 - PSEL_0 :
         IN0
      0x1 - PSEL_1 :
         IN1
      0x2 - PSEL_2 :
         IN2
      0x3 - PSEL_3 :
         IN3
      0x4 - PSEL_4 :
         IN4
      0x5 - PSEL_5 :
         IN5
      0x6 - PSEL_6 :
         IN6
      0x7 - PSEL_7 :
         IN7
</lang>
#### p.CMP3.SCR
<lang=dft>
 (rw)  [1;33m0x40094013[0m (0x40094010 + 0x0003)
CMP Status and Control Register
 (ro) (01)  [0;32mCOUT[0m  - [00:00] -  Analog Comparator Output
 (rw) (01)  [0;32mCFF[0m  - [01:01] -  Analog Comparator Flag Falling
      0 - CFF_0 :
         Falling-edge on COUT has not been detected.
      0x1 - CFF_1 :
         Falling-edge on COUT has occurred.
 (rw) (01)  [0;32mCFR[0m  - [02:02] -  Analog Comparator Flag Rising
      0 - CFR_0 :
         Rising-edge on COUT has not been detected.
      0x1 - CFR_1 :
         Rising-edge on COUT has occurred.
 (rw) (01)  [0;32mIEF[0m  - [03:03] -  Comparator Interrupt Enable Falling
      0 - IEF_0 :
         Interrupt is disabled.
      0x1 - IEF_1 :
         Interrupt is enabled.
 (rw) (01)  [0;32mIER[0m  - [04:04] -  Comparator Interrupt Enable Rising
      0 - IER_0 :
         Interrupt is disabled.
      0x1 - IER_1 :
         Interrupt is enabled.
 (rw) (01)  [0;32mDMAEN[0m  - [06:06] -  DMA Enable Control
      0 - DMAEN_0 :
         DMA is disabled.
      0x1 - DMAEN_1 :
         DMA is enabled.
</lang>
#### p.CMP3.DACCR
<lang=dft>
 (rw)  [1;33m0x40094014[0m (0x40094010 + 0x0004)
DAC Control Register
 (rw) (06)  [0;32mVOSEL[0m  - [05:00] -  DAC Output Voltage Select
 (rw) (01)  [0;32mVRSEL[0m  - [06:06] -  Supply Voltage Reference Source Select
      0 - VRSEL_0 :
         Vin1 is selected as resistor ladder network supply reference.
      0x1 - VRSEL_1 :
         Vin2 is selected as resistor ladder network supply reference.
 (rw) (01)  [0;32mDACEN[0m  - [07:07] -  DAC Enable
      0 - DACEN_0 :
         DAC is disabled.
      0x1 - DACEN_1 :
         DAC is enabled.
</lang>
#### p.CMP4.FPR
<lang=dft>
 (rw)  [1;33m0x4009401a[0m (0x40094018 + 0x0002)
CMP Filter Period Register
 (rw) (08)  [0;32mFILT_PER[0m  - [07:00] -  Filter Sample Period
</lang>
#### p.cmp4.muxcr
<link=p.CMP4.MUXCR>
#### p.IOMUXC_SNVS_GPR.GPR0
<lang=dft>
 (ro)  [1;33m0x400a4000[0m (0x400a4000 + 0x0000)
GPR0 General Purpose Register
</lang>
#### IOMUXC_SNVS.SW_PAD_CTL_PAD_PMIC_ON_REQ
<link=p.IOMUXC_SNVS.SW_PAD_CTL_PAD_PMIC_ON_REQ>
#### iomuxc_gpr.gpr0
<link=p.IOMUXC_GPR.GPR0>
#### p.IOMUXC_GPR.GPR3
<lang=dft>
 (rw)  [1;33m0x400ac00c[0m (0x400ac000 + 0x000c)
GPR3 General Purpose Register
 (rw) (04)  [0;32mOCRAM_CTL[0m  - [03:00] -  OCRAM_CTL[3] - write address pipeline control bit
 (rw) (01)  [0;32mDCP_KEY_SEL[0m  - [04:04] -  Select 128-bit dcp key from 256-bit key from snvs/ocotp
      0 - DCP_KEY_SEL_0 :
         Select [127:0] from snvs/ocotp key as dcp key
      0x1 - DCP_KEY_SEL_1 :
         Select [255:128] from snvs/ocotp key as dcp key
 (rw) (04)  [0;32mOCRAM2_CTL[0m  - [11:08] -  OCRAM2_CTL[3] - write address pipeline control bit
 (rw) (01)  [0;32mAXBS_L_HALT_REQ[0m  - [15:15] -  Request to halt axbs_l
      0 - AXBS_L_HALT_REQ_0 :
         axbs_l normal run
      0x1 - AXBS_L_HALT_REQ_1 :
         request to halt axbs_l
 (ro) (04)  [0;32mOCRAM_STATUS[0m  - [19:16] -  This field shows the OCRAM pipeline settings status, controlled by OCRAM_CTL bi
 ts respectively
 (ro) (04)  [0;32mOCRAM2_STATUS[0m  - [27:24] -  This field shows the OCRAM2 pipeline settings status, controlled by OCRAM2_CTL 
 bits respectively
 (rw) (01)  [0;32mAXBS_L_HALTED[0m  - [31:31] -  This bit shows the status of axbs_l
      0 - AXBS_L_HALTED_0 :
         axbs_l is not halted
      0x1 - AXBS_L_HALTED_1 :
         axbs_l is in halted status
</lang>
#### iomuxc_gpr.gpr17
<link=p.IOMUXC_GPR.GPR17>
#### p.iomuxc_gpr.gpr26
<link=p.IOMUXC_GPR.GPR26>
#### p.iomuxc_gpr.gpr31
<link=p.IOMUXC_GPR.GPR31>
#### flexram.tcm_ctrl
<link=p.FLEXRAM.TCM_CTRL>
#### FLEXRAM.INT_STATUS
<link=p.FLEXRAM.INT_STATUS>
#### p.flexram.int_stat_en
<link=p.FLEXRAM.INT_STAT_EN>
#### p.flexram.int_sig_en
<link=p.FLEXRAM.INT_SIG_EN>
#### wdog2.wsr
<link=p.WDOG2.WSR>
#### RTWDOG.CS
<link=p.RTWDOG.CS>
#### p.rtwdog.cnt
<link=p.RTWDOG.CNT>
#### p.rtwdog.win
<link=p.RTWDOG.WIN>
#### rtwdog.win
<link=p.RTWDOG.WIN>
#### p.ADC1
<lang=dft>
base: 0x400c4000
CAL             CFG             CV              GC              
GS              HC0             HC1             HC2             
HC3             HC4             HC5             HC6             
HC7             HS              OFS             R0              
R1              R2              R3              R4              
R5              R6              R7              
输入 p.ADC1.{reg_name} 以查看寄存器的详细信息
type p.ADC1.{reg_name} to check details of registers
</lang>
#### p.ADC1.HC1
<lang=dft>
 (rw)  [1;33m0x400c4004[0m (0x400c4000 + 0x0004)
Control register for hardware triggers
 (rw) (05)  [0;32mADCH[0m  - [04:00] -  Input Channel Select
      0x10 - ADCH_16 :
         External channel selection from ADC_ETC
      0x19 - ADCH_25 :
         VREFSH = internal channel, for ADC self-test, hard connected to VRH int
         ernally
      0x1F - ADCH_31 :
         Conversion Disabled. Hardware Triggers will not initiate any conversion
         .
 (rw) (01)  [0;32mAIEN[0m  - [07:07] -  Conversion Complete Interrupt Enable/Disable Control
      0 - AIEN_0 :
         Conversion complete interrupt disabled
      0x1 - AIEN_1 :
         Conversion complete interrupt enabled
</lang>
#### ADC1.HC6
<link=p.ADC1.HC6>
#### adc1.hc7
<link=p.ADC1.HC7>
#### ADC1.R7
<link=p.ADC1.R7>
#### p.adc1.ofs
<link=p.ADC1.OFS>
#### p.ADC2.HC3
<lang=dft>
 (rw)  [1;33m0x400c800c[0m (0x400c8000 + 0x000c)
Control register for hardware triggers
 (rw) (05)  [0;32mADCH[0m  - [04:00] -  Input Channel Select
      0x10 - ADCH_16 :
         External channel selection from ADC_ETC
      0x19 - ADCH_25 :
         VREFSH = internal channel, for ADC self-test, hard connected to VRH int
         ernally
      0x1F - ADCH_31 :
         Conversion Disabled. Hardware Triggers will not initiate any conversion
         .
 (rw) (01)  [0;32mAIEN[0m  - [07:07] -  Conversion Complete Interrupt Enable/Disable Control
      0 - AIEN_0 :
         Conversion complete interrupt disabled
      0x1 - AIEN_1 :
         Conversion complete interrupt enabled
</lang>
#### ADC2.HC6
<link=p.ADC2.HC6>
#### p.adc2.r3
<link=p.ADC2.R3>
#### TRNG.PKRRNG
<link=p.TRNG.PKRRNG>
#### p.trng.totsam
<link=p.TRNG.TOTSAM>
#### TRNG.FRQMAX
<link=p.TRNG.FRQMAX>
#### trng.scr2c
<link=p.TRNG.SCR2C>
#### p.TRNG.ENT[0]
<lang=dft>
 (ro)  [1;33m0x400cc040[0m (0x400cc000 + 0x0040)
Entropy Read Register
 (ro) (32)  [0;32mENT[0m  - [31:00] -  Entropy Value
</lang>
#### p.TRNG.ENT[5]
<lang=dft>
 (ro)  [1;33m0x400cc054[0m (0x400cc000 + 0x0054)
Entropy Read Register
 (ro) (32)  [0;32mENT[0m  - [31:00] -  Entropy Value
</lang>
#### trng.pkrcnt76
<link=p.TRNG.PKRCNT76>
#### TRNG.PKRCNT76
<link=p.TRNG.PKRCNT76>
#### p.TRNG.INT_MASK
<lang=dft>
 (rw)  [1;33m0x400cc0a8[0m (0x400cc000 + 0x00a8)
Mask Register
 (rw) (01)  [0;32mHW_ERR[0m  - [00:00] -  Bit position that can be cleared if corresponding bit of INT_STATUS has been as
 serted.
      0 - HW_ERR_0 :
         Corresponding interrupt of INT_STATUS is masked.
      0x1 - HW_ERR_1 :
         Corresponding bit of INT_STATUS is active.
 (rw) (01)  [0;32mENT_VAL[0m  - [01:01] -  Same behavior as bit 0 of this register.
      0 - ENT_VAL_0 :
         Same behavior as bit 0 of this register.
      0x1 - ENT_VAL_1 :
         Same behavior as bit 0 of this register.
 (rw) (01)  [0;32mFRQ_CT_FAIL[0m  - [02:02] -  Same behavior as bit 0 of this register.
      0 - FRQ_CT_FAIL_0 :
         Same behavior as bit 0 of this register.
      0x1 - FRQ_CT_FAIL_1 :
         Same behavior as bit 0 of this register.
</lang>
#### TRNG.VID1
<link=p.TRNG.VID1>
#### p.snvs.hpcomr
<link=p.SNVS.HPCOMR>
#### p.snvs.hpcr
<link=p.SNVS.HPCR>
#### p.snvs.hpsicr
<link=p.SNVS.HPSICR>
#### SNVS.HPSR
<link=p.SNVS.HPSR>
#### snvs.hptamr
<link=p.SNVS.HPTAMR>
#### p.SNVS.LPCR
<lang=dft>
 (rw)  [1;33m0x400d4038[0m (0x400d4000 + 0x0038)
SNVS_LP Control Register
 (rw) (01)  [0;32mSRTC_ENV[0m  - [00:00] -  Secure Real Time Counter Enabled and Valid When set, the SRTC becomes operation
 al
      0 - SRTC_ENV_0 :
         SRTC is disabled or invalid.
      0x1 - SRTC_ENV_1 :
         SRTC is enabled and valid.
 (rw) (01)  [0;32mLPTA_EN[0m  - [01:01] -  LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the
  LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter
      0 - LPTA_EN_0 :
         LP time alarm interrupt is disabled.
      0x1 - LPTA_EN_1 :
         LP time alarm interrupt is enabled.
 (rw) (01)  [0;32mMC_ENV[0m  - [02:02] -  Monotonic Counter Enabled and Valid When set, the MC can be incremented (by wri
 te transaction to the LPSMCMR or LPSMCLR)
      0 - MC_ENV_0 :
         MC is disabled or invalid.
      0x1 - MC_ENV_1 :
         MC is enabled and valid.
 (rw) (01)  [0;32mLPWUI_EN[0m  - [03:03] -  LP Wake-Up Interrupt Enable This interrupt line should be connected to the exte
 rnal pin and is intended to inform the external chip about an SNVS_LP event (ta
 mper event, MC rollover, SRTC rollover, or time alarm )
 (rw) (01)  [0;32mSRTC_INV_EN[0m  - [04:04] -  If this bit is 1, in the case of a security violation the SRTC stops counting a
 nd the SRTC is invalidated (SRTC_ENV bit is cleared)
      0 - SRTC_INV_EN_0 :
         SRTC stays valid in the case of security violation.
      0x1 - SRTC_INV_EN_1 :
         SRTC is invalidated in the case of security violation.
 (rw) (01)  [0;32mDP_EN[0m  - [05:05] -  Dumb PMIC Enabled When set, software can control the system power
      0 - DP_EN_0 :
         Smart PMIC enabled.
      0x1 - DP_EN_1 :
         Dumb PMIC enabled.
 (rw) (01)  [0;32mTOP[0m  - [06:06] -  Turn off System Power Asserting this bit causes a signal to be sent to the Powe
 r Management IC to turn off the system power
      0 - TOP_0 :
         Leave system power on.
      0x1 - TOP_1 :
         Turn off system power.
 (rw) (01)  [0;32mPWR_GLITCH_EN[0m  - [07:07] -  Power Glitch Enable By default the detection of a power glitch does not cause t
 he pmic_en_b signal to be asserted
 (rw) (01)  [0;32mLPCALB_EN[0m  - [08:08] -  LP Calibration Enable When set, enables the SRTC calibration mechanism
      0 - LPCALB_EN_0 :
         SRTC Time calibration is disabled.
      0x1 - LPCALB_EN_1 :
         SRTC Time calibration is enabled.
 (rw) (05)  [0;32mLPCALB_VAL[0m  - [14:10] -  LP Calibration Value Defines signed calibration value for SRTC
      0 - LPCALB_VAL_0 :
         +0 counts per each 32768 ticks of the counter clock
      0x1 - LPCALB_VAL_1 :
         +1 counts per each 32768 ticks of the counter clock
      0x2 - LPCALB_VAL_2 :
         +2 counts per each 32768 ticks of the counter clock
      0xF - LPCALB_VAL_15 :
         +15 counts per each 32768 ticks of the counter clock
      0x10 - LPCALB_VAL_16 :
         -16 counts per each 32768 ticks of the counter clock
      0x11 - LPCALB_VAL_17 :
         -15 counts per each 32768 ticks of the counter clock
      0x1E - LPCALB_VAL_30 :
         -2 counts per each 32768 ticks of the counter clock
      0x1F - LPCALB_VAL_31 :
         -1 counts per each 32768 ticks of the counter clock
 (rw) (02)  [0;32mBTN_PRESS_TIME[0m  - [17:16] -  This field configures the button press time out values for the PMIC Logic
 (rw) (02)  [0;32mDEBOUNCE[0m  - [19:18] -  This field configures the amount of debounce time for the BTN input signal
 (rw) (02)  [0;32mON_TIME[0m  - [21:20] -  The ON_TIME field is used to configure the period of time after BTN is asserted
  before pmic_en_b is asserted to turn on the SoC power
 (rw) (01)  [0;32mPK_EN[0m  - [22:22] -  PMIC On Request Enable The value written to PK_EN will be asserted on output si
 gnal snvs_lp_pk_en
 (rw) (01)  [0;32mPK_OVERRIDE[0m  - [23:23] -  PMIC On Request Override The value written to PK_OVERRIDE will be asserted on o
 utput signal snvs_lp_pk_override
 (rw) (01)  [0;32mGPR_Z_DIS[0m  - [24:24] -  General Purpose Registers Zeroization Disable
</lang>
#### SNVS.LPPGDR
<link=p.SNVS.LPPGDR>
#### p.snvs.lpzmkr[2]
<link=p.SNVS.LPZMKR[2]>
#### SNVS.LPZMKR[5]
<link=p.SNVS.LPZMKR[5]>
#### p.snvs.lpgpr_alias[0]
<link=p.SNVS.LPGPR_ALIAS[0]>
#### SNVS.LPGPR[2]
<link=p.SNVS.LPGPR[2]>
#### p.SNVS.HPVIDR1
<lang=dft>
 (ro)  [1;33m0x400d4bf8[0m (0x400d4000 + 0x0bf8)
SNVS_HP Version ID Register 1
 (ro) (08)  [0;32mMINOR_REV[0m  - [07:00] -  SNVS block minor version number
 (ro) (08)  [0;32mMAJOR_REV[0m  - [15:08] -  SNVS block major version number
 (ro) (16)  [0;32mIP_ID[0m  - [31:16] -  SNVS block ID
</lang>
#### CCM_ANALOG.PLL_USB2_SET
<link=p.CCM_ANALOG.PLL_USB2_SET>
#### CCM_ANALOG.PLL_VIDEO_CLR
<link=p.CCM_ANALOG.PLL_VIDEO_CLR>
#### CCM_ANALOG.PLL_VIDEO_DENOM
<link=p.CCM_ANALOG.PLL_VIDEO_DENOM>
#### p.CCM_ANALOG.PFD_480
<lang=dft>
 (rw)  [1;33m0x400d80f0[0m (0x400d8000 + 0x00f0)
480MHz Clock (PLL3) Phase Fractional Divider Control Register
 (rw) (06)  [0;32mPFD0_FRAC[0m  - [05:00] -  This field controls the fractional divide value
 (ro) (01)  [0;32mPFD0_STABLE[0m  - [06:06] -  This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional di
 vider should become stable quickly enough that this field will never need to be
  used by either device driver or application code
 (rw) (01)  [0;32mPFD0_CLKGATE[0m  - [07:07] -  If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power
  savings)
 (rw) (06)  [0;32mPFD1_FRAC[0m  - [13:08] -  This field controls the fractional divide value
 (ro) (01)  [0;32mPFD1_STABLE[0m  - [14:14] -  This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional di
 vider should become stable quickly enough that this field will never need to be
  used by either device driver or application code
 (rw) (01)  [0;32mPFD1_CLKGATE[0m  - [15:15] -  IO Clock Gate
 (rw) (06)  [0;32mPFD2_FRAC[0m  - [21:16] -  This field controls the fractional divide value
 (ro) (01)  [0;32mPFD2_STABLE[0m  - [22:22] -  This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional di
 vider should become stable quickly enough that this field will never need to be
  used by either device driver or application code
 (rw) (01)  [0;32mPFD2_CLKGATE[0m  - [23:23] -  IO Clock Gate
 (rw) (06)  [0;32mPFD3_FRAC[0m  - [29:24] -  This field controls the fractional divide value
 (ro) (01)  [0;32mPFD3_STABLE[0m  - [30:30] -  This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional di
 vider should become stable quickly enough that this field will never need to be
  used by either device driver or application code
 (rw) (01)  [0;32mPFD3_CLKGATE[0m  - [31:31] -  IO Clock Gate
</lang>
#### p.ccm_analog.misc0
<link=p.CCM_ANALOG.MISC0>
#### p.pmu.reg_1p1
<link=p.PMU.REG_1P1>
#### p.PMU.REG_1P1_SET
<lang=dft>
 (rw)  [1;33m0x400d8114[0m (0x400d8000 + 0x0114)
Regulator 1P1 Register
 (rw) (01)  [0;32mENABLE_LINREG[0m  - [00:00] -  Control bit to enable the regulator output.
 (rw) (01)  [0;32mENABLE_BO[0m  - [01:01] -  Control bit to enable the brownout circuitry in the regulator.
 (rw) (01)  [0;32mENABLE_ILIMIT[0m  - [02:02] -  Control bit to enable the current-limit circuitry in the regulator.
 (rw) (01)  [0;32mENABLE_PULLDOWN[0m  - [03:03] -  Control bit to enable the pull-down circuitry in the regulator
 (rw) (03)  [0;32mBO_OFFSET[0m  - [06:04] -  Control bits to adjust the regulator brownout offset voltage in 25mV steps
 (rw) (05)  [0;32mOUTPUT_TRG[0m  - [12:08] -  Control bits to adjust the regulator output voltage
      0x4 - OUTPUT_TRG_4 :
         0.8V
      0x10 - OUTPUT_TRG_16 :
         1.1V
 (ro) (01)  [0;32mBO_VDD1P1[0m  - [16:16] -  Status bit that signals when a brownout is detected on the regulator output.
 (ro) (01)  [0;32mOK_VDD1P1[0m  - [17:17] -  Status bit that signals when the regulator output is ok. 1 = regulator output >
  brownout target
 (rw) (01)  [0;32mENABLE_WEAK_LINREG[0m  - [18:18] -  Enables the weak 1p1 regulator
 (rw) (01)  [0;32mSELREF_WEAK_LINREG[0m  - [19:19] -  Selects the source for the reference voltage of the weak 1p1 regulator.
      0 - SELREF_WEAK_LINREG_0 :
         Weak-linreg output tracks low-power-bandgap voltage
      0x1 - SELREF_WEAK_LINREG_1 :
         Weak-linreg output tracks VDD_SOC_IN voltage
</lang>
#### p.pmu.reg_1p1_set
<link=p.PMU.REG_1P1_SET>
#### pmu.reg_1p1_set
<link=p.PMU.REG_1P1_SET>
#### PMU.REG_3P0_SET
<link=p.PMU.REG_3P0_SET>
#### PMU.REG_3P0_CLR
<link=p.PMU.REG_3P0_CLR>
#### pmu.reg_core_tog
<link=p.PMU.REG_CORE_TOG>
#### PMU.MISC0
<link=p.PMU.MISC0>
#### pmu.misc1_tog
<link=p.PMU.MISC1_TOG>
#### PMU.MISC2_TOG
<link=p.PMU.MISC2_TOG>
#### tempmon.tempsense0
<link=p.TEMPMON.TEMPSENSE0>
#### tempmon.tempsense1_set
<link=p.TEMPMON.TEMPSENSE1_SET>
#### p.TEMPMON.TEMPSENSE1_CLR
<lang=dft>
 (rw)  [1;33m0x400d8198[0m (0x400d8000 + 0x0198)
Tempsensor Control Register 1
 (rw) (16)  [0;32mMEASURE_FREQ[0m  - [15:00] -  This bits determines how many RTC clocks to wait before automatically repeating
  a temperature measurement
</lang>
#### p.tempmon.tempsense2_tog
<link=p.TEMPMON.TEMPSENSE2_TOG>
#### usb_analog.usb1_loopback
<link=p.USB_ANALOG.USB1_LOOPBACK>
#### p.USB_ANALOG.USB2_VBUS_DETECT_CLR
<lang=dft>
 (rw)  [1;33m0x400d8208[0m (0x400d8000 + 0x0208)
USB VBUS Detect Register
 (rw) (03)  [0;32mVBUSVALID_THRESH[0m  - [02:00] -  Set the threshold for the VBUSVALID comparator
      0 - 4V0 :
         4.0V
      0x1 - 4V1 :
         4.1V
      0x2 - 4V2 :
         4.2V
      0x3 - 4V3 :
         4.3V
      0x4 - 4V4 :
         4.4V (default)
      0x5 - 4V5 :
         4.5V
      0x6 - 4V6 :
         4.6V
      0x7 - 4V7 :
         4.7V
 (rw) (01)  [0;32mVBUSVALID_PWRUP_CMPS[0m  - [20:20] -  Powers up comparators for vbus_valid detector.
 (rw) (01)  [0;32mDISCHARGE_VBUS[0m  - [26:26] -  USB OTG discharge VBUS.
 (rw) (01)  [0;32mCHARGE_VBUS[0m  - [27:27] -  USB OTG charge VBUS.
</lang>
#### p.USB_ANALOG.USB2_CHRG_DETECT_SET
<lang=dft>
 (rw)  [1;33m0x400d8214[0m (0x400d8000 + 0x0214)
USB Charger Detect Register
 (rw) (01)  [0;32mCHK_CONTACT[0m  - [18:18] -  Check the contact of USB plug
      0 - NO_CHECK :
         Do not check the contact of USB plug.
      0x1 - CHECK :
         Check whether the USB plug has been in contact with each other
 (rw) (01)  [0;32mCHK_CHRG_B[0m  - [19:19] -  Check the charger connection
      0 - CHECK :
         Check whether a charger (either a dedicated charger or a host charger) 
         is connected to USB port.
      0x1 - NO_CHECK :
         Do not check whether a charger is connected to the USB port.
 (rw) (01)  [0;32mEN_B[0m  - [20:20] -  Control the charger detector.
      0 - ENABLE :
         Enable the charger detector.
      0x1 - DISABLE :
         Disable the charger detector.
</lang>
#### p.usb_analog.usb2_misc
<link=p.USB_ANALOG.USB2_MISC>
#### p.xtalosc24m
<link=p.XTALOSC24M>
#### XTALOSC24M.MISC0_CLR
<link=p.XTALOSC24M.MISC0_CLR>
#### XTALOSC24M.MISC0_TOG
<link=p.XTALOSC24M.MISC0_TOG>
#### p.USBPHY1
<lang=dft>
base: 0x400d9000
CTRL            CTRL_CLR        CTRL_SET        CTRL_TOG        
DEBUG           DEBUG0_STATUS   DEBUG1          DEBUG1_CLR      
DEBUG1_SET      DEBUG1_TOG      DEBUG_CLR       DEBUG_SET       
DEBUG_TOG       PWD             PWD_CLR         PWD_SET         
PWD_TOG         RX              RX_CLR          RX_SET          
RX_TOG          STATUS          TX              TX_CLR          
TX_SET          TX_TOG          VERSION         
输入 p.USBPHY1.{reg_name} 以查看寄存器的详细信息
type p.USBPHY1.{reg_name} to check details of registers
</lang>
#### p.usbphy1.pwd
<link=p.USBPHY1.PWD>
#### USBPHY1.PWD_CLR
<link=p.USBPHY1.PWD_CLR>
#### usbphy1.pwd_tog
<link=p.USBPHY1.PWD_TOG>
#### USBPHY1.TX
<link=p.USBPHY1.TX>
#### p.USBPHY1.TX_CLR
<lang=dft>
 (rw)  [1;33m0x400d9018[0m (0x400d9000 + 0x0018)
USB PHY Transmitter Control Register
 (rw) (04)  [0;32mD_CAL[0m  - [03:00] -  Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%
 (rw) (04)  [0;32mRSVD0[0m  - [07:04] -  Reserved. Note: This bit should remain clear.
 (rw) (04)  [0;32mTXCAL45DN[0m  - [11:08] -  Decode to select a 45-Ohm resistance to the USB_DN output pin
 (rw) (04)  [0;32mRSVD1[0m  - [15:12] -  Reserved. Note: This bit should remain clear.
 (rw) (04)  [0;32mTXCAL45DP[0m  - [19:16] -  Decode to select a 45-Ohm resistance to the USB_DP output pin
 (ro) (06)  [0;32mRSVD2[0m  - [25:20] -  Reserved.
 (rw) (03)  [0;32mUSBPHY_TX_EDGECTRL[0m  - [28:26] -  Controls the edge-rate of the current sensing transistors used in HS transmit
 (ro) (03)  [0;32mRSVD5[0m  - [31:29] -  Reserved.
</lang>
#### usbphy1.tx_clr
<link=p.USBPHY1.TX_CLR>
#### p.USBPHY1.RX_TOG
<lang=dft>
 (rw)  [1;33m0x400d902c[0m (0x400d9000 + 0x002c)
USB PHY Receiver Control Register
 (rw) (03)  [0;32mENVADJ[0m  - [02:00] -  The ENVADJ field adjusts the trip point for the envelope detector
 (ro) (01)  [0;32mRSVD0[0m  - [03:03] -  Reserved.
 (rw) (03)  [0;32mDISCONADJ[0m  - [06:04] -  The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = T
 rip-Level Voltage is 0
 (ro) (15)  [0;32mRSVD1[0m  - [21:07] -  Reserved.
 (rw) (01)  [0;32mRXDBYPASS[0m  - [22:22] -  0 = Normal operation
 (ro) (09)  [0;32mRSVD2[0m  - [31:23] -  Reserved.
</lang>
#### p.USBPHY1.DEBUG0_STATUS
<lang=dft>
 (ro)  [1;33m0x400d9060[0m (0x400d9000 + 0x0060)
UTMI Debug Status Register 0
 (ro) (16)  [0;32mLOOP_BACK_FAIL_COUNT[0m  - [15:00] -  Running count of the failed pseudo-random generator loopback
 (ro) (10)  [0;32mUTMI_RXERROR_FAIL_COUNT[0m  - [25:16] -  Running count of the UTMI_RXERROR.
 (ro) (06)  [0;32mSQUELCH_COUNT[0m  - [31:26] -  Running count of the squelch reset instead of normal end for HS RX.
</lang>
#### p.USBPHY1.DEBUG1
<lang=dft>
 (rw)  [1;33m0x400d9070[0m (0x400d9000 + 0x0070)
UTMI Debug Status Register 1
 (rw) (13)  [0;32mRSVD0[0m  - [12:00] -  Reserved. Note: This bit should remain clear.
 (rw) (02)  [0;32mENTAILADJVD[0m  - [14:13] -  Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20
 % 10 = Delay is -20% 11 = Delay is -40%
 (ro) (17)  [0;32mRSVD1[0m  - [31:15] -  Reserved.
</lang>
#### p.USBPHY2.PWD_TOG
<lang=dft>
 (rw)  [1;33m0x400da00c[0m (0x400da000 + 0x000c)
USB PHY Power-Down Register
 (ro) (10)  [0;32mRSVD0[0m  - [09:00] -  Reserved.
 (rw) (01)  [0;32mTXPWDFS[0m  - [10:10] -  0 = Normal operation
 (rw) (01)  [0;32mTXPWDIBIAS[0m  - [11:11] -  0 = Normal operation
 (rw) (01)  [0;32mTXPWDV2I[0m  - [12:12] -  0 = Normal operation
 (ro) (04)  [0;32mRSVD1[0m  - [16:13] -  Reserved.
 (rw) (01)  [0;32mRXPWDENV[0m  - [17:17] -  0 = Normal operation
 (rw) (01)  [0;32mRXPWD1PT1[0m  - [18:18] -  0 = Normal operation
 (rw) (01)  [0;32mRXPWDDIFF[0m  - [19:19] -  0 = Normal operation
 (rw) (01)  [0;32mRXPWDRX[0m  - [20:20] -  0 = Normal operation
 (ro) (11)  [0;32mRSVD2[0m  - [31:21] -  Reserved.
</lang>
#### p.usbphy2.tx
<link=p.USBPHY2.TX>
#### usbphy2.tx
<link=p.USBPHY2.TX>
#### p.usbphy2.rx_set
<link=p.USBPHY2.RX_SET>
#### p.USBPHY2.CTRL
<lang=dft>
 (rw)  [1;33m0x400da030[0m (0x400da000 + 0x0030)
USB PHY General Control Register
 (rw) (01)  [0;32mENOTG_ID_CHG_IRQ[0m  - [00:00] -  Enable OTG_ID_CHG_IRQ.
 (rw) (01)  [0;32mENHOSTDISCONDETECT[0m  - [01:01] -  For host mode, enables high-speed disconnect detector
 (rw) (01)  [0;32mENIRQHOSTDISCON[0m  - [02:02] -  Enables interrupt for detection of disconnection to Device when in high-speed h
 ost mode
 (rw) (01)  [0;32mHOSTDISCONDETECT_IRQ[0m  - [03:03] -  Indicates that the device has disconnected in high-speed mode
 (rw) (01)  [0;32mENDEVPLUGINDETECT[0m  - [04:04] -  For device mode, enables 200-KOhm pullups for detecting connectivity to the hos
 t.
 (rw) (01)  [0;32mDEVPLUGIN_POLARITY[0m  - [05:05] -  For device mode, if this bit is cleared to 0, then it trips the interrupt if th
 e device is plugged in
 (rw) (01)  [0;32mOTG_ID_CHG_IRQ[0m  - [06:06] -  OTG ID change interrupt. Indicates the value of ID pin changed.
 (rw) (01)  [0;32mENOTGIDDETECT[0m  - [07:07] -  Enables circuit to detect resistance of MiniAB ID pin.
 (rw) (01)  [0;32mRESUMEIRQSTICKY[0m  - [08:08] -  Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it
 (rw) (01)  [0;32mENIRQRESUMEDETECT[0m  - [09:09] -  Enables interrupt for detection of a non-J state on the USB line
 (rw) (01)  [0;32mRESUME_IRQ[0m  - [10:10] -  Indicates that the host is sending a wake-up after suspend
 (rw) (01)  [0;32mENIRQDEVPLUGIN[0m  - [11:11] -  Enables interrupt for the detection of connectivity to the USB line.
 (rw) (01)  [0;32mDEVPLUGIN_IRQ[0m  - [12:12] -  Indicates that the device is connected
 (rw) (01)  [0;32mDATA_ON_LRADC[0m  - [13:13] -  Enables the LRADC to monitor USB_DP and USB_DM. This is for use in non-USB mode
 s only.
 (rw) (01)  [0;32mENUTMILEVEL2[0m  - [14:14] -  Enables UTMI+ Level2. This should be enabled if needs to support LS device
 (rw) (01)  [0;32mENUTMILEVEL3[0m  - [15:15] -  Enables UTMI+ Level3
 (rw) (01)  [0;32mENIRQWAKEUP[0m  - [16:16] -  Enables interrupt for the wakeup events.
 (rw) (01)  [0;32mWAKEUP_IRQ[0m  - [17:17] -  Indicates that there is a wakeup event
 (rw) (01)  [0;32mENAUTO_PWRON_PLL[0m  - [18:18] -  Enables the feature to auto-enable the POWER bit of HW_CLKCTRL_PLLxCTRL0 if the
 re is wakeup event if USB is suspended
 (rw) (01)  [0;32mENAUTOCLR_CLKGATE[0m  - [19:19] -  Enables the feature to auto-clear the CLKGATE bit if there is wakeup event whil
 e USB is suspended
 (rw) (01)  [0;32mENAUTOCLR_PHY_PWD[0m  - [20:20] -  Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there
  is wakeup event while USB is suspended
 (rw) (01)  [0;32mENDPDMCHG_WKUP[0m  - [21:21] -  Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended
 (rw) (01)  [0;32mENIDCHG_WKUP[0m  - [22:22] -  Enables the feature to wakeup USB if ID is toggled when USB is suspended.
 (rw) (01)  [0;32mENVBUSCHG_WKUP[0m  - [23:23] -  Enables the feature to wakeup USB if VBUS is toggled when USB is suspended.
 (rw) (01)  [0;32mFSDLL_RST_EN[0m  - [24:24] -  Enables the feature to reset the FSDLL lock detection logic at the end of each 
 TX packet.
 (ro) (02)  [0;32mRSVD1[0m  - [26:25] -  Reserved.
 (ro) (01)  [0;32mOTG_ID_VALUE[0m  - [27:27] -  Almost same as OTGID_STATUS in USBPHYx_STATUS Register
 (rw) (01)  [0;32mHOST_FORCE_LS_SE0[0m  - [28:28] -  Forces the next FS packet that is transmitted to have a EOP with LS timing
 (ro) (01)  [0;32mUTMI_SUSPENDM[0m  - [29:29] -  Used by the PHY to indicate a powered-down state
 (rw) (01)  [0;32mCLKGATE[0m  - [30:30] -  Gate UTMI Clocks
 (rw) (01)  [0;32mSFTRST[0m  - [31:31] -  Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX
 , and USBPHYx_CTRL registers
</lang>
#### usbphy2.debug1
<link=p.USBPHY2.DEBUG1>
#### p.CSU.CSL6
<lang=dft>
 (rw)  [1;33m0x400dc018[0m (0x400dc000 + 0x0018)
Config security level register
 (rw) (01)  [0;32mSUR_S2[0m  - [00:00] -  Secure user read access control for the second slave
      0 - SUR_S2_0 :
         The secure user read access is disabled for the second slave.
      0x1 - SUR_S2_1 :
         The secure user read access is enabled for the second slave.
 (rw) (01)  [0;32mSSR_S2[0m  - [01:01] -  Secure supervisor read access control for the second slave
      0 - SSR_S2_0 :
         The secure supervisor read access is disabled for the second slave.
      0x1 - SSR_S2_1 :
         The secure supervisor read access is enabled for the second slave.
 (rw) (01)  [0;32mNUR_S2[0m  - [02:02] -  Non-secure user read access control for the second slave
      0 - NUR_S2_0 :
         The non-secure user read access is disabled for the second slave.
      0x1 - NUR_S2_1 :
         The non-secure user read access is enabled for the second slave.
 (rw) (01)  [0;32mNSR_S2[0m  - [03:03] -  Non-secure supervisor read access control for the second slave
      0 - NSR_S2_0 :
         The non-secure supervisor read access is disabled for the second slave.
      0x1 - NSR_S2_1 :
         The non-secure supervisor read access is enabled for the second slave.
 (rw) (01)  [0;32mSUW_S2[0m  - [04:04] -  Secure user write access control for the second slave
      0 - SUW_S2_0 :
         The secure user write access is disabled for the second slave.
      0x1 - SUW_S2_1 :
         The secure user write access is enabled for the second slave.
 (rw) (01)  [0;32mSSW_S2[0m  - [05:05] -  Secure supervisor write access control for the second slave
      0 - SSW_S2_0 :
         The secure supervisor write access is disabled for the second slave.
      0x1 - SSW_S2_1 :
         The secure supervisor write access is enabled for the second slave.
 (rw) (01)  [0;32mNUW_S2[0m  - [06:06] -  Non-secure user write access control for the second slave
      0 - NUW_S2_0 :
         The non-secure user write access is disabled for the second slave.
      0x1 - NUW_S2_1 :
         The non-secure user write access is enabled for the second slave.
 (rw) (01)  [0;32mNSW_S2[0m  - [07:07] -  Non-secure supervisor write access control for the second slave
      0 - NSW_S2_0 :
         The non-secure supervisor write access is disabled for the second slave
         .
      0x1 - NSW_S2_1 :
         The non-secure supervisor write access is enabled for the second slave.
 (rw) (01)  [0;32mLOCK_S2[0m  - [08:08] -  The lock bit corresponding to the second slave. It is written by the secure sof
 tware.
      0 - LOCK_S2_0 :
         Not locked. Bits 7-0 can be written by the software.
      0x1 - LOCK_S2_1 :
         Bits 7-0 are locked and cannot be written by the software
 (rw) (01)  [0;32mSUR_S1[0m  - [16:16] -  Secure user read access control for the first slave
      0 - SUR_S1_0 :
         The secure user read access is disabled for the first slave.
      0x1 - SUR_S1_1 :
         The secure user read access is enabled for the first slave.
 (rw) (01)  [0;32mSSR_S1[0m  - [17:17] -  Secure supervisor read access control for the first slave
      0 - SSR_S1_0 :
         The secure supervisor read access is disabled for the first slave.
      0x1 - SSR_S1_1 :
         The secure supervisor read access is enabled for the first slave.
 (rw) (01)  [0;32mNUR_S1[0m  - [18:18] -  Non-secure user read access control for the first slave
      0 - NUR_S1_0 :
         The non-secure user read access is disabled for the first slave.
      0x1 - NUR_S1_1 :
         The non-secure user read access is enabled for the first slave.
 (rw) (01)  [0;32mNSR_S1[0m  - [19:19] -  Non-secure supervisor read access control for the first slave
      0 - NSR_S1_0 :
         The non-secure supervisor read access is disabled for the first slave.
      0x1 - NSR_S1_1 :
         The non-secure supervisor read access is enabled for the first slave.
 (rw) (01)  [0;32mSUW_S1[0m  - [20:20] -  Secure user write access control for the first slave
      0 - SUW_S1_0 :
         The secure user write access is disabled for the first slave.
      0x1 - SUW_S1_1 :
         The secure user write access is enabled for the first slave.
 (rw) (01)  [0;32mSSW_S1[0m  - [21:21] -  Secure supervisor write access control for the first slave
      0 - SSW_S1_0 :
         The secure supervisor write access is disabled for the first slave.
      0x1 - SSW_S1_1 :
         The secure supervisor write access is enabled for the first slave.
 (rw) (01)  [0;32mNUW_S1[0m  - [22:22] -  Non-secure user write access control for the first slave
      0 - NUW_S1_0 :
         The non-secure user write access is disabled for the first slave.
      0x1 - NUW_S1_1 :
         The non-secure user write access is enabled for the first slave.
 (rw) (01)  [0;32mNSW_S1[0m  - [23:23] -  Non-secure supervisor write access control for the first slave
      0 - NSW_S1_0 :
         The non-secure supervisor write access is disabled for the first slave.
      0x1 - NSW_S1_1 :
         The non-secure supervisor write access is enabled for the first slave
 (rw) (01)  [0;32mLOCK_S1[0m  - [24:24] -  The lock bit corresponding to the first slave. It is written by the secure soft
 ware.
      0 - LOCK_S1_0 :
         Not locked. The bits 16-23 can be written by the software.
      0x1 - LOCK_S1_1 :
         The bits 16-23 are locked and can't be written by the software.
</lang>
#### p.csu.csl6
<link=p.CSU.CSL6>
#### csu.csl7
<link=p.CSU.CSL7>
#### CSU.CSL7
<link=p.CSU.CSL7>
#### p.CSU.CSL18
<lang=dft>
 (rw)  [1;33m0x400dc048[0m (0x400dc000 + 0x0048)
Config security level register
 (rw) (01)  [0;32mSUR_S2[0m  - [00:00] -  Secure user read access control for the second slave
      0 - SUR_S2_0 :
         The secure user read access is disabled for the second slave.
      0x1 - SUR_S2_1 :
         The secure user read access is enabled for the second slave.
 (rw) (01)  [0;32mSSR_S2[0m  - [01:01] -  Secure supervisor read access control for the second slave
      0 - SSR_S2_0 :
         The secure supervisor read access is disabled for the second slave.
      0x1 - SSR_S2_1 :
         The secure supervisor read access is enabled for the second slave.
 (rw) (01)  [0;32mNUR_S2[0m  - [02:02] -  Non-secure user read access control for the second slave
      0 - NUR_S2_0 :
         The non-secure user read access is disabled for the second slave.
      0x1 - NUR_S2_1 :
         The non-secure user read access is enabled for the second slave.
 (rw) (01)  [0;32mNSR_S2[0m  - [03:03] -  Non-secure supervisor read access control for the second slave
      0 - NSR_S2_0 :
         The non-secure supervisor read access is disabled for the second slave.
      0x1 - NSR_S2_1 :
         The non-secure supervisor read access is enabled for the second slave.
 (rw) (01)  [0;32mSUW_S2[0m  - [04:04] -  Secure user write access control for the second slave
      0 - SUW_S2_0 :
         The secure user write access is disabled for the second slave.
      0x1 - SUW_S2_1 :
         The secure user write access is enabled for the second slave.
 (rw) (01)  [0;32mSSW_S2[0m  - [05:05] -  Secure supervisor write access control for the second slave
      0 - SSW_S2_0 :
         The secure supervisor write access is disabled for the second slave.
      0x1 - SSW_S2_1 :
         The secure supervisor write access is enabled for the second slave.
 (rw) (01)  [0;32mNUW_S2[0m  - [06:06] -  Non-secure user write access control for the second slave
      0 - NUW_S2_0 :
         The non-secure user write access is disabled for the second slave.
      0x1 - NUW_S2_1 :
         The non-secure user write access is enabled for the second slave.
 (rw) (01)  [0;32mNSW_S2[0m  - [07:07] -  Non-secure supervisor write access control for the second slave
      0 - NSW_S2_0 :
         The non-secure supervisor write access is disabled for the second slave
         .
      0x1 - NSW_S2_1 :
         The non-secure supervisor write access is enabled for the second slave.
 (rw) (01)  [0;32mLOCK_S2[0m  - [08:08] -  The lock bit corresponding to the second slave. It is written by the secure sof
 tware.
      0 - LOCK_S2_0 :
         Not locked. Bits 7-0 can be written by the software.
      0x1 - LOCK_S2_1 :
         Bits 7-0 are locked and cannot be written by the software
 (rw) (01)  [0;32mSUR_S1[0m  - [16:16] -  Secure user read access control for the first slave
      0 - SUR_S1_0 :
         The secure user read access is disabled for the first slave.
      0x1 - SUR_S1_1 :
         The secure user read access is enabled for the first slave.
 (rw) (01)  [0;32mSSR_S1[0m  - [17:17] -  Secure supervisor read access control for the first slave
      0 - SSR_S1_0 :
         The secure supervisor read access is disabled for the first slave.
      0x1 - SSR_S1_1 :
         The secure supervisor read access is enabled for the first slave.
 (rw) (01)  [0;32mNUR_S1[0m  - [18:18] -  Non-secure user read access control for the first slave
      0 - NUR_S1_0 :
         The non-secure user read access is disabled for the first slave.
      0x1 - NUR_S1_1 :
         The non-secure user read access is enabled for the first slave.
 (rw) (01)  [0;32mNSR_S1[0m  - [19:19] -  Non-secure supervisor read access control for the first slave
      0 - NSR_S1_0 :
         The non-secure supervisor read access is disabled for the first slave.
      0x1 - NSR_S1_1 :
         The non-secure supervisor read access is enabled for the first slave.
 (rw) (01)  [0;32mSUW_S1[0m  - [20:20] -  Secure user write access control for the first slave
      0 - SUW_S1_0 :
         The secure user write access is disabled for the first slave.
      0x1 - SUW_S1_1 :
         The secure user write access is enabled for the first slave.
 (rw) (01)  [0;32mSSW_S1[0m  - [21:21] -  Secure supervisor write access control for the first slave
      0 - SSW_S1_0 :
         The secure supervisor write access is disabled for the first slave.
      0x1 - SSW_S1_1 :
         The secure supervisor write access is enabled for the first slave.
 (rw) (01)  [0;32mNUW_S1[0m  - [22:22] -  Non-secure user write access control for the first slave
      0 - NUW_S1_0 :
         The non-secure user write access is disabled for the first slave.
      0x1 - NUW_S1_1 :
         The non-secure user write access is enabled for the first slave.
 (rw) (01)  [0;32mNSW_S1[0m  - [23:23] -  Non-secure supervisor write access control for the first slave
      0 - NSW_S1_0 :
         The non-secure supervisor write access is disabled for the first slave.
      0x1 - NSW_S1_1 :
         The non-secure supervisor write access is enabled for the first slave
 (rw) (01)  [0;32mLOCK_S1[0m  - [24:24] -  The lock bit corresponding to the first slave. It is written by the secure soft
 ware.
      0 - LOCK_S1_0 :
         Not locked. The bits 16-23 can be written by the software.
      0x1 - LOCK_S1_1 :
         The bits 16-23 are locked and can't be written by the software.
</lang>
#### p.csu.csl18
<link=p.CSU.CSL18>
#### csu.hp0
<link=p.CSU.HP0>
#### p.tsc
<link=p.TSC>
#### p.tsc.basic_setting
<link=p.TSC.BASIC_SETTING>
#### TSC.INT_EN
<link=p.TSC.INT_EN>
#### p.tsc.int_status
<link=p.TSC.INT_STATUS>
#### DMA0.ERQ
<link=p.DMA0.ERQ>
#### dma0.ceei
<link=p.DMA0.CEEI>
#### DMA0.CEEI
<link=p.DMA0.CEEI>
#### p.DMA0.CERQ
<lang=dft>
 (rw)  [1;33m0x400e801a[0m (0x400e8000 + 0x001a)
Clear Enable Request Register
 (rw) (05)  [0;32mCERQ[0m  - [04:00] -  Clear Enable Request
 (rw) (01)  [0;32mCAER[0m  - [06:06] -  Clear All Enable Requests
      0 - CAER_0 :
         Clear only the ERQ bit specified in the CERQ field
      0x1 - CAER_1 :
         Clear all bits in ERQ
 (rw) (01)  [0;32mNOP[0m  - [07:07] -  No Op enable
      0 - NOP_0 :
         Normal operation
      0x1 - NOP_1 :
         No operation, ignore the other bits in this register
</lang>
#### dma0.cdne
<link=p.DMA0.CDNE>
#### p.dma0.int
<link=p.DMA0.INT>
#### DMA0.DCHPRI7
<link=p.DMA0.DCHPRI7>
#### p.dma0.dchpri5
<link=p.DMA0.DCHPRI5>
#### p.DMA0.DCHPRI8
<lang=dft>
 (rw)  [1;33m0x400e810b[0m (0x400e8000 + 0x010b)
Channel n Priority Register
 (rw) (04)  [0;32mCHPRI[0m  - [03:00] -  Channel n Arbitration Priority
 (ro) (02)  [0;32mGRPPRI[0m  - [05:04] -  Channel n Current Group Priority
 (rw) (01)  [0;32mDPA[0m  - [06:06] -  Disable Preempt Ability. This field resets to 0.
      0 - DPA_0 :
         Channel n can suspend a lower priority channel.
      0x1 - DPA_1 :
         Channel n cannot suspend any channel, regardless of channel priority.
 (rw) (01)  [0;32mECP[0m  - [07:07] -  Enable Channel Preemption. This field resets to 0.
      0 - ECP_0 :
         Channel n cannot be suspended by a higher priority channel's service re
         quest.
      0x1 - ECP_1 :
         Channel n can be temporarily suspended by the service request of a high
         er priority channel.
</lang>
#### DMA0.DCHPRI15
<link=p.DMA0.DCHPRI15>
#### dma0.dchpri12
<link=p.DMA0.DCHPRI12>
#### dma0.dchpri23
<link=p.DMA0.DCHPRI23>
#### p.dma0.dchpri30
<link=p.DMA0.DCHPRI30>
#### p.DMA0.TCD0_SADDR
<lang=dft>
 (rw)  [1;33m0x400e9000[0m (0x400e8000 + 0x1000)
TCD Source Address
 (rw) (32)  [0;32mSADDR[0m  - [31:00] -  Source Address
</lang>
#### p.dma0.tcd1_saddr
<link=p.DMA0.TCD1_SADDR>
#### p.dma0.tcd1_nbytes_mlno
<link=p.DMA0.TCD1_NBYTES_MLNO>
#### dma0.tcd1_slast
<link=p.DMA0.TCD1_SLAST>
#### dma0.tcd1_citer_elinkno
<link=p.DMA0.TCD1_CITER_ELINKNO>
#### p.dma0.tcd1_csr
<link=p.DMA0.TCD1_CSR>
#### p.dma0.tcd1_biter_elinkno
<link=p.DMA0.TCD1_BITER_ELINKNO>
#### DMA0.TCD2_NBYTES_MLOFFYES
<link=p.DMA0.TCD2_NBYTES_MLOFFYES>
#### p.DMA0.TCD2_CITER_ELINKYES
<lang=dft>
 (rw)  [1;33m0x400e9056[0m (0x400e8000 + 0x1056)
TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 (rw) (09)  [0;32mCITER[0m  - [08:00] -  Current Major Iteration Count
 (rw) (05)  [0;32mLINKCH[0m  - [13:09] -  Minor Loop Link Channel Number
 (rw) (01)  [0;32mELINK[0m  - [15:15] -  Enable channel-to-channel linking on minor-loop complete
      0 - ELINK_0 :
         The channel-to-channel linking is disabled
      0x1 - ELINK_1 :
         The channel-to-channel linking is enabled
</lang>
#### p.DMA0.TCD3_SADDR
<lang=dft>
 (rw)  [1;33m0x400e9060[0m (0x400e8000 + 0x1060)
TCD Source Address
 (rw) (32)  [0;32mSADDR[0m  - [31:00] -  Source Address
</lang>
#### dma0.tcd3_dlastsga
<link=p.DMA0.TCD3_DLASTSGA>
#### p.dma0.tcd3_csr
<link=p.DMA0.TCD3_CSR>
#### dma0.tcd3_biter_elinkyes
<link=p.DMA0.TCD3_BITER_ELINKYES>
#### p.dma0.tcd4_saddr
<link=p.DMA0.TCD4_SADDR>
#### dma0.tcd4_attr
<link=p.DMA0.TCD4_ATTR>
#### DMA0.TCD4_NBYTES_MLNO
<link=p.DMA0.TCD4_NBYTES_MLNO>
#### p.DMA0.TCD4_NBYTES_MLOFFNO
<lang=dft>
 (rw)  [1;33m0x400e9088[0m (0x400e8000 + 0x1088)
TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 (rw) (30)  [0;32mNBYTES[0m  - [29:00] -  Minor Byte Transfer Count
 (rw) (01)  [0;32mDMLOE[0m  - [30:30] -  Destination Minor Loop Offset enable
      0 - DMLOE_0 :
         The minor loop offset is not applied to the DADDR
      0x1 - DMLOE_1 :
         The minor loop offset is applied to the DADDR
 (rw) (01)  [0;32mSMLOE[0m  - [31:31] -  Source Minor Loop Offset Enable
      0 - SMLOE_0 :
         The minor loop offset is not applied to the SADDR
      0x1 - SMLOE_1 :
         The minor loop offset is applied to the SADDR
</lang>
#### p.dma0.tcd4_nbytes_mloffyes
<link=p.DMA0.TCD4_NBYTES_MLOFFYES>
#### dma0.tcd4_biter_elinkno
<link=p.DMA0.TCD4_BITER_ELINKNO>
#### p.dma0.tcd4_biter_elinkyes
<link=p.DMA0.TCD4_BITER_ELINKYES>
#### p.dma0.tcd5_soff
<link=p.DMA0.TCD5_SOFF>
#### dma0.tcd5_citer_elinkyes
<link=p.DMA0.TCD5_CITER_ELINKYES>
#### dma0.tcd6_slast
<link=p.DMA0.TCD6_SLAST>
#### DMA0.TCD6_BITER_ELINKNO
<link=p.DMA0.TCD6_BITER_ELINKNO>
#### p.dma0.tcd7_attr
<link=p.DMA0.TCD7_ATTR>
#### dma0.tcd7_doff
<link=p.DMA0.TCD7_DOFF>
#### p.DMA0.TCD8_SOFF
<lang=dft>
 (rw)  [1;33m0x400e9104[0m (0x400e8000 + 0x1104)
TCD Signed Source Address Offset
 (rw) (16)  [0;32mSOFF[0m  - [15:00] -  Source address signed offset
</lang>
#### p.dma0.tcd8_soff
<link=p.DMA0.TCD8_SOFF>
#### dma0.tcd8_biter_elinkno
<link=p.DMA0.TCD8_BITER_ELINKNO>
#### p.dma0.tcd9_attr
<link=p.DMA0.TCD9_ATTR>
#### DMA0.TCD10_SADDR
<link=p.DMA0.TCD10_SADDR>
#### p.DMA0.TCD10_SLAST
<lang=dft>
 (rw)  [1;33m0x400e914c[0m (0x400e8000 + 0x114c)
TCD Last Source Address Adjustment
 (rw) (32)  [0;32mSLAST[0m  - [31:00] -  Last Source Address Adjustment
</lang>
#### p.DMA0.TCD10_CITER_ELINKYES
<lang=dft>
 (rw)  [1;33m0x400e9156[0m (0x400e8000 + 0x1156)
TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 (rw) (09)  [0;32mCITER[0m  - [08:00] -  Current Major Iteration Count
 (rw) (05)  [0;32mLINKCH[0m  - [13:09] -  Minor Loop Link Channel Number
 (rw) (01)  [0;32mELINK[0m  - [15:15] -  Enable channel-to-channel linking on minor-loop complete
      0 - ELINK_0 :
         The channel-to-channel linking is disabled
      0x1 - ELINK_1 :
         The channel-to-channel linking is enabled
</lang>
#### DMA0.TCD10_CITER_ELINKYES
<link=p.DMA0.TCD10_CITER_ELINKYES>
#### dma0.tcd10_dlastsga
<link=p.DMA0.TCD10_DLASTSGA>
#### p.DMA0.TCD10_BITER_ELINKNO
<lang=dft>
 (rw)  [1;33m0x400e915e[0m (0x400e8000 + 0x115e)
TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 (rw) (15)  [0;32mBITER[0m  - [14:00] -  Starting Major Iteration Count
 (rw) (01)  [0;32mELINK[0m  - [15:15] -  Enables channel-to-channel linking on minor loop complete
      0 - ELINK_0 :
         The channel-to-channel linking is disabled
      0x1 - ELINK_1 :
         The channel-to-channel linking is enabled
</lang>
#### p.DMA0.TCD11_SOFF
<lang=dft>
 (rw)  [1;33m0x400e9164[0m (0x400e8000 + 0x1164)
TCD Signed Source Address Offset
 (rw) (16)  [0;32mSOFF[0m  - [15:00] -  Source address signed offset
</lang>
#### p.DMA0.TCD11_NBYTES_MLOFFNO
<lang=dft>
 (rw)  [1;33m0x400e9168[0m (0x400e8000 + 0x1168)
TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 (rw) (30)  [0;32mNBYTES[0m  - [29:00] -  Minor Byte Transfer Count
 (rw) (01)  [0;32mDMLOE[0m  - [30:30] -  Destination Minor Loop Offset enable
      0 - DMLOE_0 :
         The minor loop offset is not applied to the DADDR
      0x1 - DMLOE_1 :
         The minor loop offset is applied to the DADDR
 (rw) (01)  [0;32mSMLOE[0m  - [31:31] -  Source Minor Loop Offset Enable
      0 - SMLOE_0 :
         The minor loop offset is not applied to the SADDR
      0x1 - SMLOE_1 :
         The minor loop offset is applied to the SADDR
</lang>
#### p.DMA0.TCD11_SLAST
<lang=dft>
 (rw)  [1;33m0x400e916c[0m (0x400e8000 + 0x116c)
TCD Last Source Address Adjustment
 (rw) (32)  [0;32mSLAST[0m  - [31:00] -  Last Source Address Adjustment
</lang>
#### p.DMA0.TCD12_CSR
<lang=dft>
 (rw)  [1;33m0x400e919c[0m (0x400e8000 + 0x119c)
TCD Control and Status
 (rw) (01)  [0;32mSTART[0m  - [00:00] -  Channel Start
      0 - START_0 :
         The channel is not explicitly started.
      0x1 - START_1 :
         The channel is explicitly started via a software initiated service requ
         est.
 (rw) (01)  [0;32mINTMAJOR[0m  - [01:01] -  Enable an interrupt when major iteration count completes.
      0 - INTMAJOR_0 :
         The end-of-major loop interrupt is disabled.
      0x1 - INTMAJOR_1 :
         The end-of-major loop interrupt is enabled.
 (rw) (01)  [0;32mINTHALF[0m  - [02:02] -  Enable an interrupt when major counter is half complete.
      0 - INTHALF_0 :
         The half-point interrupt is disabled.
      0x1 - INTHALF_1 :
         The half-point interrupt is enabled.
 (rw) (01)  [0;32mDREQ[0m  - [03:03] -  Disable Request
      0 - DREQ_0 :
         The channel's ERQ bit is not affected.
      0x1 - DREQ_1 :
         The channel's ERQ bit is cleared when the major loop is complete.
 (rw) (01)  [0;32mESG[0m  - [04:04] -  Enable Scatter/Gather Processing
      0 - ESG_0 :
         The current channel's TCD is normal format.
      0x1 - ESG_1 :
         The current channel's TCD specifies a scatter gather format. The DLASTS
         GA field provides a memory pointer to the next TCD to be loaded into th
         is channel after the major loop completes its execution.
 (rw) (01)  [0;32mMAJORELINK[0m  - [05:05] -  Enable channel-to-channel linking on major loop complete
      0 - MAJORELINK_0 :
         The channel-to-channel linking is disabled.
      0x1 - MAJORELINK_1 :
         The channel-to-channel linking is enabled.
 (ro) (01)  [0;32mACTIVE[0m  - [06:06] -  Channel Active
 (rw) (01)  [0;32mDONE[0m  - [07:07] -  Channel Done
 (rw) (05)  [0;32mMAJORLINKCH[0m  - [12:08] -  Major Loop Link Channel Number
 (rw) (02)  [0;32mBWC[0m  - [15:14] -  Bandwidth Control
      0 - BWC_0 :
         No eDMA engine stalls.
      0x2 - BWC_2 :
         eDMA engine stalls for 4 cycles after each R/W.
      0x3 - BWC_3 :
         eDMA engine stalls for 8 cycles after each R/W.
</lang>
#### DMA0.TCD12_CSR
<link=p.DMA0.TCD12_CSR>
#### dma0.tcd12_biter_elinkno
<link=p.DMA0.TCD12_BITER_ELINKNO>
#### p.dma0.tcd13_attr
<link=p.DMA0.TCD13_ATTR>
#### dma0.tcd13_nbytes_mlno
<link=p.DMA0.TCD13_NBYTES_MLNO>
#### DMA0.TCD13_DADDR
<link=p.DMA0.TCD13_DADDR>
#### dma0.tcd13_dlastsga
<link=p.DMA0.TCD13_DLASTSGA>
#### p.dma0.tcd14_soff
<link=p.DMA0.TCD14_SOFF>
#### DMA0.TCD14_SOFF
<link=p.DMA0.TCD14_SOFF>
#### p.DMA0.TCD15_SADDR
<lang=dft>
 (rw)  [1;33m0x400e91e0[0m (0x400e8000 + 0x11e0)
TCD Source Address
 (rw) (32)  [0;32mSADDR[0m  - [31:00] -  Source Address
</lang>
#### dma0.tcd15_attr
<link=p.DMA0.TCD15_ATTR>
#### p.dma0.tcd15_dlastsga
<link=p.DMA0.TCD15_DLASTSGA>
#### p.DMA0.TCD16_SADDR
<lang=dft>
 (rw)  [1;33m0x400e9200[0m (0x400e8000 + 0x1200)
TCD Source Address
 (rw) (32)  [0;32mSADDR[0m  - [31:00] -  Source Address
</lang>
#### dma0.tcd16_saddr
<link=p.DMA0.TCD16_SADDR>
#### p.DMA0.TCD17_NBYTES_MLOFFYES
<lang=dft>
 (rw)  [1;33m0x400e9228[0m (0x400e8000 + 0x1228)
TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 (rw) (10)  [0;32mNBYTES[0m  - [09:00] -  Minor Byte Transfer Count
 (rw) (20)  [0;32mMLOFF[0m  - [29:10] -  If SMLOE or DMLOE is set, this field represents a sign-extended offset applied 
 to the source or destination address to form the next-state value after the min
 or loop completes.
 (rw) (01)  [0;32mDMLOE[0m  - [30:30] -  Destination Minor Loop Offset enable
      0 - DMLOE_0 :
         The minor loop offset is not applied to the DADDR
      0x1 - DMLOE_1 :
         The minor loop offset is applied to the DADDR
 (rw) (01)  [0;32mSMLOE[0m  - [31:31] -  Source Minor Loop Offset Enable
      0 - SMLOE_0 :
         The minor loop offset is not applied to the SADDR
      0x1 - SMLOE_1 :
         The minor loop offset is applied to the SADDR
</lang>
#### dma0.tcd17_nbytes_mloffyes
<link=p.DMA0.TCD17_NBYTES_MLOFFYES>
#### dma0.tcd17_citer_elinkno
<link=p.DMA0.TCD17_CITER_ELINKNO>
#### p.dma0.tcd18_nbytes_mlno
<link=p.DMA0.TCD18_NBYTES_MLNO>
#### dma0.tcd18_nbytes_mloffyes
<link=p.DMA0.TCD18_NBYTES_MLOFFYES>
#### p.dma0.tcd19_soff
<link=p.DMA0.TCD19_SOFF>
#### p.DMA0.TCD19_NBYTES_MLNO
<lang=dft>
 (rw)  [1;33m0x400e9268[0m (0x400e8000 + 0x1268)
TCD Minor Byte Count (Minor Loop Mapping Disabled)
 (rw) (32)  [0;32mNBYTES[0m  - [31:00] -  Minor Byte Transfer Count
</lang>
#### p.dma0.tcd19_doff
<link=p.DMA0.TCD19_DOFF>
#### DMA0.TCD19_BITER_ELINKYES
<link=p.DMA0.TCD19_BITER_ELINKYES>
#### p.DMA0.TCD20_NBYTES_MLOFFNO
<lang=dft>
 (rw)  [1;33m0x400e9288[0m (0x400e8000 + 0x1288)
TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 (rw) (30)  [0;32mNBYTES[0m  - [29:00] -  Minor Byte Transfer Count
 (rw) (01)  [0;32mDMLOE[0m  - [30:30] -  Destination Minor Loop Offset enable
      0 - DMLOE_0 :
         The minor loop offset is not applied to the DADDR
      0x1 - DMLOE_1 :
         The minor loop offset is applied to the DADDR
 (rw) (01)  [0;32mSMLOE[0m  - [31:31] -  Source Minor Loop Offset Enable
      0 - SMLOE_0 :
         The minor loop offset is not applied to the SADDR
      0x1 - SMLOE_1 :
         The minor loop offset is applied to the SADDR
</lang>
#### DMA0.TCD20_NBYTES_MLOFFYES
<link=p.DMA0.TCD20_NBYTES_MLOFFYES>
#### p.DMA0.TCD21_DOFF
<lang=dft>
 (rw)  [1;33m0x400e92b4[0m (0x400e8000 + 0x12b4)
TCD Signed Destination Address Offset
 (rw) (16)  [0;32mDOFF[0m  - [15:00] -  Destination Address Signed Offset
</lang>
#### p.dma0.tcd21_doff
<link=p.DMA0.TCD21_DOFF>
#### DMA0.TCD22_BITER_ELINKYES
<link=p.DMA0.TCD22_BITER_ELINKYES>
#### p.DMA0.TCD23_SOFF
<lang=dft>
 (rw)  [1;33m0x400e92e4[0m (0x400e8000 + 0x12e4)
TCD Signed Source Address Offset
 (rw) (16)  [0;32mSOFF[0m  - [15:00] -  Source address signed offset
</lang>
#### DMA0.TCD23_NBYTES_MLNO
<link=p.DMA0.TCD23_NBYTES_MLNO>
#### p.dma0.tcd23_slast
<link=p.DMA0.TCD23_SLAST>
#### p.DMA0.TCD24_SOFF
<lang=dft>
 (rw)  [1;33m0x400e9304[0m (0x400e8000 + 0x1304)
TCD Signed Source Address Offset
 (rw) (16)  [0;32mSOFF[0m  - [15:00] -  Source address signed offset
</lang>
#### DMA0.TCD24_SOFF
<link=p.DMA0.TCD24_SOFF>
#### p.DMA0.TCD24_SLAST
<lang=dft>
 (rw)  [1;33m0x400e930c[0m (0x400e8000 + 0x130c)
TCD Last Source Address Adjustment
 (rw) (32)  [0;32mSLAST[0m  - [31:00] -  Last Source Address Adjustment
</lang>
#### dma0.tcd24_citer_elinkyes
<link=p.DMA0.TCD24_CITER_ELINKYES>
#### p.DMA0.TCD24_CSR
<lang=dft>
 (rw)  [1;33m0x400e931c[0m (0x400e8000 + 0x131c)
TCD Control and Status
 (rw) (01)  [0;32mSTART[0m  - [00:00] -  Channel Start
      0 - START_0 :
         The channel is not explicitly started.
      0x1 - START_1 :
         The channel is explicitly started via a software initiated service requ
         est.
 (rw) (01)  [0;32mINTMAJOR[0m  - [01:01] -  Enable an interrupt when major iteration count completes.
      0 - INTMAJOR_0 :
         The end-of-major loop interrupt is disabled.
      0x1 - INTMAJOR_1 :
         The end-of-major loop interrupt is enabled.
 (rw) (01)  [0;32mINTHALF[0m  - [02:02] -  Enable an interrupt when major counter is half complete.
      0 - INTHALF_0 :
         The half-point interrupt is disabled.
      0x1 - INTHALF_1 :
         The half-point interrupt is enabled.
 (rw) (01)  [0;32mDREQ[0m  - [03:03] -  Disable Request
      0 - DREQ_0 :
         The channel's ERQ bit is not affected.
      0x1 - DREQ_1 :
         The channel's ERQ bit is cleared when the major loop is complete.
 (rw) (01)  [0;32mESG[0m  - [04:04] -  Enable Scatter/Gather Processing
      0 - ESG_0 :
         The current channel's TCD is normal format.
      0x1 - ESG_1 :
         The current channel's TCD specifies a scatter gather format. The DLASTS
         GA field provides a memory pointer to the next TCD to be loaded into th
         is channel after the major loop completes its execution.
 (rw) (01)  [0;32mMAJORELINK[0m  - [05:05] -  Enable channel-to-channel linking on major loop complete
      0 - MAJORELINK_0 :
         The channel-to-channel linking is disabled.
      0x1 - MAJORELINK_1 :
         The channel-to-channel linking is enabled.
 (ro) (01)  [0;32mACTIVE[0m  - [06:06] -  Channel Active
 (rw) (01)  [0;32mDONE[0m  - [07:07] -  Channel Done
 (rw) (05)  [0;32mMAJORLINKCH[0m  - [12:08] -  Major Loop Link Channel Number
 (rw) (02)  [0;32mBWC[0m  - [15:14] -  Bandwidth Control
      0 - BWC_0 :
         No eDMA engine stalls.
      0x2 - BWC_2 :
         eDMA engine stalls for 4 cycles after each R/W.
      0x3 - BWC_3 :
         eDMA engine stalls for 8 cycles after each R/W.
</lang>
#### p.DMA0.TCD25_DADDR
<lang=dft>
 (rw)  [1;33m0x400e9330[0m (0x400e8000 + 0x1330)
TCD Destination Address
 (rw) (32)  [0;32mDADDR[0m  - [31:00] -  Destination Address
</lang>
#### p.dma0.tcd25_citer_elinkyes
<link=p.DMA0.TCD25_CITER_ELINKYES>
#### p.dma0.tcd25_csr
<link=p.DMA0.TCD25_CSR>
#### DMA0.TCD25_BITER_ELINKYES
<link=p.DMA0.TCD25_BITER_ELINKYES>
#### p.dma0.tcd26_nbytes_mlno
<link=p.DMA0.TCD26_NBYTES_MLNO>
#### p.DMA0.TCD26_NBYTES_MLOFFNO
<lang=dft>
 (rw)  [1;33m0x400e9348[0m (0x400e8000 + 0x1348)
TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 (rw) (30)  [0;32mNBYTES[0m  - [29:00] -  Minor Byte Transfer Count
 (rw) (01)  [0;32mDMLOE[0m  - [30:30] -  Destination Minor Loop Offset enable
      0 - DMLOE_0 :
         The minor loop offset is not applied to the DADDR
      0x1 - DMLOE_1 :
         The minor loop offset is applied to the DADDR
 (rw) (01)  [0;32mSMLOE[0m  - [31:31] -  Source Minor Loop Offset Enable
      0 - SMLOE_0 :
         The minor loop offset is not applied to the SADDR
      0x1 - SMLOE_1 :
         The minor loop offset is applied to the SADDR
</lang>
#### p.DMA0.TCD26_DADDR
<lang=dft>
 (rw)  [1;33m0x400e9350[0m (0x400e8000 + 0x1350)
TCD Destination Address
 (rw) (32)  [0;32mDADDR[0m  - [31:00] -  Destination Address
</lang>
#### p.dma0.tcd26_daddr
<link=p.DMA0.TCD26_DADDR>
#### p.DMA0.TCD27_ATTR
<lang=dft>
 (rw)  [1;33m0x400e9366[0m (0x400e8000 + 0x1366)
TCD Transfer Attributes
 (rw) (03)  [0;32mDSIZE[0m  - [02:00] -  Destination data transfer size
 (rw) (05)  [0;32mDMOD[0m  - [07:03] -  Destination Address Modulo
 (rw) (03)  [0;32mSSIZE[0m  - [10:08] -  Source data transfer size
      0 - SSIZE_0 :
         8-bit
      0x1 - SSIZE_1 :
         16-bit
      0x2 - SSIZE_2 :
         32-bit
      0x3 - SSIZE_3 :
         64-bit
      0x5 - SSIZE_5 :
         32-byte burst (4 beats of 64 bits)
 (rw) (05)  [0;32mSMOD[0m  - [15:11] -  Source Address Modulo
      0 - SMOD_0 :
         Source address modulo feature is disabled
      0x1 - SMOD_1 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x2 - SMOD_2 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x3 - SMOD_3 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x4 - SMOD_4 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x5 - SMOD_5 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x6 - SMOD_6 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x7 - SMOD_7 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x8 - SMOD_8 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x9 - SMOD_9 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
</lang>
#### p.DMA0.TCD27_CSR
<lang=dft>
 (rw)  [1;33m0x400e937c[0m (0x400e8000 + 0x137c)
TCD Control and Status
 (rw) (01)  [0;32mSTART[0m  - [00:00] -  Channel Start
      0 - START_0 :
         The channel is not explicitly started.
      0x1 - START_1 :
         The channel is explicitly started via a software initiated service requ
         est.
 (rw) (01)  [0;32mINTMAJOR[0m  - [01:01] -  Enable an interrupt when major iteration count completes.
      0 - INTMAJOR_0 :
         The end-of-major loop interrupt is disabled.
      0x1 - INTMAJOR_1 :
         The end-of-major loop interrupt is enabled.
 (rw) (01)  [0;32mINTHALF[0m  - [02:02] -  Enable an interrupt when major counter is half complete.
      0 - INTHALF_0 :
         The half-point interrupt is disabled.
      0x1 - INTHALF_1 :
         The half-point interrupt is enabled.
 (rw) (01)  [0;32mDREQ[0m  - [03:03] -  Disable Request
      0 - DREQ_0 :
         The channel's ERQ bit is not affected.
      0x1 - DREQ_1 :
         The channel's ERQ bit is cleared when the major loop is complete.
 (rw) (01)  [0;32mESG[0m  - [04:04] -  Enable Scatter/Gather Processing
      0 - ESG_0 :
         The current channel's TCD is normal format.
      0x1 - ESG_1 :
         The current channel's TCD specifies a scatter gather format. The DLASTS
         GA field provides a memory pointer to the next TCD to be loaded into th
         is channel after the major loop completes its execution.
 (rw) (01)  [0;32mMAJORELINK[0m  - [05:05] -  Enable channel-to-channel linking on major loop complete
      0 - MAJORELINK_0 :
         The channel-to-channel linking is disabled.
      0x1 - MAJORELINK_1 :
         The channel-to-channel linking is enabled.
 (ro) (01)  [0;32mACTIVE[0m  - [06:06] -  Channel Active
 (rw) (01)  [0;32mDONE[0m  - [07:07] -  Channel Done
 (rw) (05)  [0;32mMAJORLINKCH[0m  - [12:08] -  Major Loop Link Channel Number
 (rw) (02)  [0;32mBWC[0m  - [15:14] -  Bandwidth Control
      0 - BWC_0 :
         No eDMA engine stalls.
      0x2 - BWC_2 :
         eDMA engine stalls for 4 cycles after each R/W.
      0x3 - BWC_3 :
         eDMA engine stalls for 8 cycles after each R/W.
</lang>
#### dma0.tcd28_nbytes_mloffyes
<link=p.DMA0.TCD28_NBYTES_MLOFFYES>
#### DMA0.TCD28_DADDR
<link=p.DMA0.TCD28_DADDR>
#### p.DMA0.TCD28_DOFF
<lang=dft>
 (rw)  [1;33m0x400e9394[0m (0x400e8000 + 0x1394)
TCD Signed Destination Address Offset
 (rw) (16)  [0;32mDOFF[0m  - [15:00] -  Destination Address Signed Offset
</lang>
#### p.dma0.tcd28_citer_elinkyes
<link=p.DMA0.TCD28_CITER_ELINKYES>
#### p.DMA0.TCD29_NBYTES_MLNO
<lang=dft>
 (rw)  [1;33m0x400e93a8[0m (0x400e8000 + 0x13a8)
TCD Minor Byte Count (Minor Loop Mapping Disabled)
 (rw) (32)  [0;32mNBYTES[0m  - [31:00] -  Minor Byte Transfer Count
</lang>
#### DMA0.TCD29_NBYTES_MLOFFYES
<link=p.DMA0.TCD29_NBYTES_MLOFFYES>
#### DMA0.TCD29_SLAST
<link=p.DMA0.TCD29_SLAST>
#### DMA0.TCD29_DADDR
<link=p.DMA0.TCD29_DADDR>
#### p.DMA0.TCD29_CITER_ELINKYES
<lang=dft>
 (rw)  [1;33m0x400e93b6[0m (0x400e8000 + 0x13b6)
TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 (rw) (09)  [0;32mCITER[0m  - [08:00] -  Current Major Iteration Count
 (rw) (05)  [0;32mLINKCH[0m  - [13:09] -  Minor Loop Link Channel Number
 (rw) (01)  [0;32mELINK[0m  - [15:15] -  Enable channel-to-channel linking on minor-loop complete
      0 - ELINK_0 :
         The channel-to-channel linking is disabled
      0x1 - ELINK_1 :
         The channel-to-channel linking is enabled
</lang>
#### dma0.tcd29_dlastsga
<link=p.DMA0.TCD29_DLASTSGA>
#### p.DMA0.TCD30_SADDR
<lang=dft>
 (rw)  [1;33m0x400e93c0[0m (0x400e8000 + 0x13c0)
TCD Source Address
 (rw) (32)  [0;32mSADDR[0m  - [31:00] -  Source Address
</lang>
#### p.dma0.tcd30_daddr
<link=p.DMA0.TCD30_DADDR>
#### dma0.tcd30_doff
<link=p.DMA0.TCD30_DOFF>
#### dma0.tcd30_citer_elinkno
<link=p.DMA0.TCD30_CITER_ELINKNO>
#### dma0.tcd30_csr
<link=p.DMA0.TCD30_CSR>
#### p.DMA0.TCD31_ATTR
<lang=dft>
 (rw)  [1;33m0x400e93e6[0m (0x400e8000 + 0x13e6)
TCD Transfer Attributes
 (rw) (03)  [0;32mDSIZE[0m  - [02:00] -  Destination data transfer size
 (rw) (05)  [0;32mDMOD[0m  - [07:03] -  Destination Address Modulo
 (rw) (03)  [0;32mSSIZE[0m  - [10:08] -  Source data transfer size
      0 - SSIZE_0 :
         8-bit
      0x1 - SSIZE_1 :
         16-bit
      0x2 - SSIZE_2 :
         32-bit
      0x3 - SSIZE_3 :
         64-bit
      0x5 - SSIZE_5 :
         32-byte burst (4 beats of 64 bits)
 (rw) (05)  [0;32mSMOD[0m  - [15:11] -  Source Address Modulo
      0 - SMOD_0 :
         Source address modulo feature is disabled
      0x1 - SMOD_1 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x2 - SMOD_2 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x3 - SMOD_3 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x4 - SMOD_4 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x5 - SMOD_5 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x6 - SMOD_6 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x7 - SMOD_7 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x8 - SMOD_8 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
      0x9 - SMOD_9 :
         This value defines a specific address range specified to be the value a
         fter SADDR + SOFF calculation is performed on the original register val
         ue. Setting this field provides the ability to implement a circular dat
         a queue easily. For data queues requiring power-of-2 size bytes, the qu
         eue should start at a 0-modulo-size address and the SMOD field should b
         e set to the appropriate value for the queue, freezing the desired numb
         er of upper address bits. The value programmed into this field specifie
         s the number of lower address bits allowed to change. For a circular qu
         eue application, the SOFF is typically set to the transfer size to impl
         ement post-increment addressing with the SMOD function constraining the
          addresses to a 0-modulo-size range.
</lang>
#### dma0.tcd31_nbytes_mloffno
<link=p.DMA0.TCD31_NBYTES_MLOFFNO>
#### dma0.tcd31_nbytes_mloffyes
<link=p.DMA0.TCD31_NBYTES_MLOFFYES>
#### dmamux.chcfg[3]
<link=p.DMAMUX.CHCFG[3]>
#### p.dmamux.chcfg[12]
<link=p.DMAMUX.CHCFG[12]>
#### dmamux.chcfg[13]
<link=p.DMAMUX.CHCFG[13]>
#### DMAMUX.CHCFG[15]
<link=p.DMAMUX.CHCFG[15]>
#### p.dmamux.chcfg[17]
<link=p.DMAMUX.CHCFG[17]>
#### dmamux.chcfg[26]
<link=p.DMAMUX.CHCFG[26]>
#### p.DMAMUX.CHCFG[30]
<lang=dft>
 (rw)  [1;33m0x400ec078[0m (0x400ec000 + 0x0078)
Channel 0 Configuration Register
 (rw) (07)  [0;32mSOURCE[0m  - [06:00] -  DMA Channel Source (Slot Number)
 (rw) (01)  [0;32mA_ON[0m  - [29:29] -  DMA Channel Always Enable
      0 - A_ON_0 :
         DMA Channel Always ON function is disabled
      0x1 - A_ON_1 :
         DMA Channel Always ON function is enabled
 (rw) (01)  [0;32mTRIG[0m  - [30:30] -  DMA Channel Trigger Enable
      0 - TRIG_0 :
         Triggering is disabled. If triggering is disabled and ENBL is set, the 
         DMA Channel will simply route the specified source to the DMA channel. 
         (Normal mode)
      0x1 - TRIG_1 :
         Triggering is enabled. If triggering is enabled and ENBL is set, the DM
         A_CH_MUX is in Periodic Trigger mode.
 (rw) (01)  [0;32mENBL[0m  - [31:31] -  DMA Mux Channel Enable
      0 - ENBL_0 :
         DMA Mux channel is disabled
      0x1 - ENBL_1 :
         DMA Mux channel is enabled
</lang>
#### DMAMUX.CHCFG[30]
<link=p.DMAMUX.CHCFG[30]>
#### p.gpc
<link=p.GPC>
#### gpc.cntr
<link=p.GPC.CNTR>
#### p.GPC.IMR2
<lang=dft>
 (rw)  [1;33m0x400f400c[0m (0x400f4000 + 0x000c)
IRQ masking register 2
 (rw) (32)  [0;32mIMR2[0m  - [31:00] -  IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked
</lang>
#### GPC.IMR3
<link=p.GPC.IMR3>
#### p.GPC.ISR3
<lang=dft>
 (ro)  [1;33m0x400f4020[0m (0x400f4000 + 0x0020)
IRQ status resister 3
 (ro) (32)  [0;32mISR3[0m  - [31:00] -  IRQ[95:64] status, read only
</lang>
#### GPC.ISR3
<link=p.GPC.ISR3>
#### PGC.MEGA_SR
<link=p.PGC.MEGA_SR>
#### p.pgc.cpu_pdnscr
<link=p.PGC.CPU_PDNSCR>
#### src.scr
<link=p.SRC.SCR>
#### p.SRC.SRSR
<lang=dft>
 (rw)  [1;33m0x400f8008[0m (0x400f8000 + 0x0008)
SRC Reset Status Register
 (rw) (01)  [0;32mipp_reset_b[0m  - [00:00] -  Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)
      0 - ipp_reset_b_0 :
         Reset is not a result of ipp_reset_b pin.
      0x1 - ipp_reset_b_1 :
         Reset is a result of ipp_reset_b pin.
 (rw) (01)  [0;32mlockup_sysresetreq[0m  - [01:01] -  Indicates a reset has been caused by CPU lockup or software setting of SYSRESET
 REQ bit in Application Interrupt and Reset Control Register of the ARM core
      0 - lockup_sysresetreq_0 :
         Reset is not a result of the mentioned case.
      0x1 - lockup_sysresetreq_1 :
         Reset is a result of the mentioned case.
 (rw) (01)  [0;32mcsu_reset_b[0m  - [02:02] -  Indicates whether the reset was the result of the csu_reset_b input.
      0 - csu_reset_b_0 :
         Reset is not a result of the csu_reset_b event.
      0x1 - csu_reset_b_1 :
         Reset is a result of the csu_reset_b event.
 (rw) (01)  [0;32mipp_user_reset_b[0m  - [03:03] -  Indicates whether the reset was the result of the ipp_user_reset_b qualified re
 set.
      0 - ipp_user_reset_b_0 :
         Reset is not a result of the ipp_user_reset_b qualified as COLD reset e
         vent.
      0x1 - ipp_user_reset_b_1 :
         Reset is a result of the ipp_user_reset_b qualified as COLD reset event
         .
 (rw) (01)  [0;32mwdog_rst_b[0m  - [04:04] -  IC Watchdog Time-out reset
      0 - wdog_rst_b_0 :
         Reset is not a result of the watchdog time-out event.
      0x1 - wdog_rst_b_1 :
         Reset is a result of the watchdog time-out event.
 (rw) (01)  [0;32mjtag_rst_b[0m  - [05:05] -  HIGH - Z JTAG reset. Indicates whether the reset was the result of HIGH-Z reset
  from JTAG.
      0 - jtag_rst_b_0 :
         Reset is not a result of HIGH-Z reset from JTAG.
      0x1 - jtag_rst_b_1 :
         Reset is a result of HIGH-Z reset from JTAG.
 (rw) (01)  [0;32mjtag_sw_rst[0m  - [06:06] -  JTAG software reset. Indicates whether the reset was the result of software res
 et from JTAG.
      0 - jtag_sw_rst_0 :
         Reset is not a result of software reset from JTAG.
      0x1 - jtag_sw_rst_1 :
         Reset is a result of software reset from JTAG.
 (rw) (01)  [0;32mwdog3_rst_b[0m  - [07:07] -  IC Watchdog3 Time-out reset
      0 - wdog3_rst_b_0 :
         Reset is not a result of the watchdog3 time-out event.
      0x1 - wdog3_rst_b_1 :
         Reset is a result of the watchdog3 time-out event.
 (rw) (01)  [0;32mtempsense_rst_b[0m  - [08:08] -  Temper Sensor software reset
      0 - tempsense_rst_b_0 :
         Reset is not a result of software reset from Temperature Sensor.
      0x1 - tempsense_rst_b_1 :
         Reset is a result of software reset from Temperature Sensor.
</lang>
#### p.src.gpr1
<link=p.SRC.GPR1>
#### src.gpr4
<link=p.SRC.GPR4>
#### ccm.cbcmr
<link=p.CCM.CBCMR>
#### ccm.cscdr1
<link=p.CCM.CSCDR1>
#### p.ccm.cs2cdr
<link=p.CCM.CS2CDR>
#### ccm.cisr
<link=p.CCM.CISR>
#### p.CCM.CCGR0
<lang=dft>
 (rw)  [1;33m0x400fc068[0m (0x400fc000 + 0x0068)
CCM Clock Gating Register 0
 (rw) (02)  [0;32mCG0[0m  - [01:00] -  aips_tz1 clocks (aips_tz1_clk_enable)
 (rw) (02)  [0;32mCG1[0m  - [03:02] -  aips_tz2 clocks (aips_tz2_clk_enable)
 (rw) (02)  [0;32mCG2[0m  - [05:04] -  mqs clock ( mqs_hmclk_clock_enable)
 (rw) (02)  [0;32mCG3[0m  - [07:06] -  flexspi_exsc clock (flexspi_exsc_clk_enable)
 (rw) (02)  [0;32mCG4[0m  - [09:08] -  sim_m or sim_main register access clock (sim_m_mainclk_r_enable)
 (rw) (02)  [0;32mCG5[0m  - [11:10] -  dcp clock (dcp_clk_enable)
 (rw) (02)  [0;32mCG6[0m  - [13:12] -  lpuart3 clock (lpuart3_clk_enable)
 (rw) (02)  [0;32mCG7[0m  - [15:14] -  can1 clock (can1_clk_enable)
 (rw) (02)  [0;32mCG8[0m  - [17:16] -  can1_serial clock (can1_serial_clk_enable)
 (rw) (02)  [0;32mCG9[0m  - [19:18] -  can2 clock (can2_clk_enable)
 (rw) (02)  [0;32mCG10[0m  - [21:20] -  can2_serial clock (can2_serial_clk_enable)
 (rw) (02)  [0;32mCG11[0m  - [23:22] -  trace clock (trace_clk_enable)
 (rw) (02)  [0;32mCG12[0m  - [25:24] -  gpt2 bus clocks (gpt2_bus_clk_enable)
 (rw) (02)  [0;32mCG13[0m  - [27:26] -  gpt2 serial clocks (gpt2_serial_clk_enable)
 (rw) (02)  [0;32mCG14[0m  - [29:28] -  lpuart2 clock (lpuart2_clk_enable)
 (rw) (02)  [0;32mCG15[0m  - [31:30] -  gpio2_clocks (gpio2_clk_enable)
</lang>
#### CCM.CCGR2
<link=p.CCM.CCGR2>
#### p.ccm.ccgr6
<link=p.CCM.CCGR6>
#### romc.rompatch2d
<link=p.ROMC.ROMPATCH2D>
#### p.romc.rompatch7a
<link=p.ROMC.ROMPATCH7A>
#### p.lpuart1.verid
<link=p.LPUART1.VERID>
#### lpuart1.fifo
<link=p.LPUART1.FIFO>
#### p.lpuart1.water
<link=p.LPUART1.WATER>
#### LPUART2.GLOBAL
<link=p.LPUART2.GLOBAL>
#### p.lpuart2.baud
<link=p.LPUART2.BAUD>
#### p.LPUART2.MODIR
<lang=dft>
 (rw)  [1;33m0x40188024[0m (0x40188000 + 0x0024)
LPUART Modem IrDA Register
 (rw) (01)  [0;32mTXCTSE[0m  - [00:00] -  Transmitter clear-to-send enable
      0 - TXCTSE_0 :
         CTS has no effect on the transmitter.
      0x1 - TXCTSE_1 :
         Enables clear-to-send operation. The transmitter checks the state of CT
         S each time it is ready to send a character. If CTS is asserted, the ch
         aracter is sent. If CTS is deasserted, the signal TXD remains in the ma
         rk state and transmission is delayed until CTS is asserted. Changes in 
         CTS as a character is being sent do not affect its transmission.
 (rw) (01)  [0;32mTXRTSE[0m  - [01:01] -  Transmitter request-to-send enable
      0 - TXRTSE_0 :
         The transmitter has no effect on RTS.
      0x1 - TXRTSE_1 :
         When a character is placed into an empty transmitter data buffer , RTS 
         asserts one bit time before the start bit is transmitted. RTS deasserts
          one bit time after all characters in the transmitter data buffer and s
         hift register are completely sent, including the last stop bit.
 (rw) (01)  [0;32mTXRTSPOL[0m  - [02:02] -  Transmitter request-to-send polarity
      0 - TXRTSPOL_0 :
         Transmitter RTS is active low.
      0x1 - TXRTSPOL_1 :
         Transmitter RTS is active high.
 (rw) (01)  [0;32mRXRTSE[0m  - [03:03] -  Receiver request-to-send enable
      0 - RXRTSE_0 :
         The receiver has no effect on RTS.
      0x1 - RXRTSE_1 :
         RTS is deasserted if the receiver data register is full or a start bit 
         has been detected that would cause the receiver data register to become
          full. RTS is asserted if the receiver data register is not full and ha
         s not detected a start bit that would cause the receiver data register 
         to become full.
 (rw) (01)  [0;32mTXCTSC[0m  - [04:04] -  Transmit CTS Configuration
      0 - TXCTSC_0 :
         CTS input is sampled at the start of each character.
      0x1 - TXCTSC_1 :
         CTS input is sampled when the transmitter is idle.
 (rw) (01)  [0;32mTXCTSSRC[0m  - [05:05] -  Transmit CTS Source
      0 - TXCTSSRC_0 :
         CTS input is the CTS_B pin.
      0x1 - TXCTSSRC_1 :
         CTS input is the inverted Receiver Match result.
 (rw) (02)  [0;32mRTSWATER[0m  - [09:08] -  Receive RTS Configuration
 (rw) (02)  [0;32mTNP[0m  - [17:16] -  Transmitter narrow pulse
      0 - TNP_0 :
         1/OSR.
      0x1 - TNP_1 :
         2/OSR.
      0x2 - TNP_2 :
         3/OSR.
      0x3 - TNP_3 :
         4/OSR.
 (rw) (01)  [0;32mIREN[0m  - [18:18] -  Infrared enable
      0 - IREN_0 :
         IR disabled.
      0x1 - IREN_1 :
         IR enabled.
</lang>
#### LPUART3.MODIR
<link=p.LPUART3.MODIR>
#### p.LPUART3.FIFO
<lang=dft>
 (rw)  [1;33m0x4018c028[0m (0x4018c000 + 0x0028)
LPUART FIFO Register
 (ro) (03)  [0;32mRXFIFOSIZE[0m  - [02:00] -  Receive FIFO Buffer Depth
      0 - RXFIFOSIZE_0 :
         Receive FIFO/Buffer depth = 1 dataword.
      0x1 - RXFIFOSIZE_1 :
         Receive FIFO/Buffer depth = 4 datawords.
      0x2 - RXFIFOSIZE_2 :
         Receive FIFO/Buffer depth = 8 datawords.
      0x3 - RXFIFOSIZE_3 :
         Receive FIFO/Buffer depth = 16 datawords.
      0x4 - RXFIFOSIZE_4 :
         Receive FIFO/Buffer depth = 32 datawords.
      0x5 - RXFIFOSIZE_5 :
         Receive FIFO/Buffer depth = 64 datawords.
      0x6 - RXFIFOSIZE_6 :
         Receive FIFO/Buffer depth = 128 datawords.
      0x7 - RXFIFOSIZE_7 :
         Receive FIFO/Buffer depth = 256 datawords.
 (rw) (01)  [0;32mRXFE[0m  - [03:03] -  Receive FIFO Enable
      0 - RXFE_0 :
         Receive FIFO is not enabled. Buffer is depth 1.
      0x1 - RXFE_1 :
         Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 (ro) (03)  [0;32mTXFIFOSIZE[0m  - [06:04] -  Transmit FIFO Buffer Depth
      0 - TXFIFOSIZE_0 :
         Transmit FIFO/Buffer depth = 1 dataword.
      0x1 - TXFIFOSIZE_1 :
         Transmit FIFO/Buffer depth = 4 datawords.
      0x2 - TXFIFOSIZE_2 :
         Transmit FIFO/Buffer depth = 8 datawords.
      0x3 - TXFIFOSIZE_3 :
         Transmit FIFO/Buffer depth = 16 datawords.
      0x4 - TXFIFOSIZE_4 :
         Transmit FIFO/Buffer depth = 32 datawords.
      0x5 - TXFIFOSIZE_5 :
         Transmit FIFO/Buffer depth = 64 datawords.
      0x6 - TXFIFOSIZE_6 :
         Transmit FIFO/Buffer depth = 128 datawords.
      0x7 - TXFIFOSIZE_7 :
         Transmit FIFO/Buffer depth = 256 datawords
 (rw) (01)  [0;32mTXFE[0m  - [07:07] -  Transmit FIFO Enable
      0 - TXFE_0 :
         Transmit FIFO is not enabled. Buffer is depth 1.
      0x1 - TXFE_1 :
         Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 (rw) (01)  [0;32mRXUFE[0m  - [08:08] -  Receive FIFO Underflow Interrupt Enable
      0 - RXUFE_0 :
         RXUF flag does not generate an interrupt to the host.
      0x1 - RXUFE_1 :
         RXUF flag generates an interrupt to the host.
 (rw) (01)  [0;32mTXOFE[0m  - [09:09] -  Transmit FIFO Overflow Interrupt Enable
      0 - TXOFE_0 :
         TXOF flag does not generate an interrupt to the host.
      0x1 - TXOFE_1 :
         TXOF flag generates an interrupt to the host.
 (rw) (03)  [0;32mRXIDEN[0m  - [12:10] -  Receiver Idle Empty Enable
      0 - RXIDEN_0 :
         Disable RDRF assertion due to partially filled FIFO when receiver is id
         le.
      0x1 - RXIDEN_1 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 1 character.
      0x2 - RXIDEN_2 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 2 characters.
      0x3 - RXIDEN_3 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 4 characters.
      0x4 - RXIDEN_4 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 8 characters.
      0x5 - RXIDEN_5 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 16 characters.
      0x6 - RXIDEN_6 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 32 characters.
      0x7 - RXIDEN_7 :
         Enable RDRF assertion due to partially filled FIFO when receiver is idl
         e for 64 characters.
 (rw) (01)  [0;32mRXFLUSH[0m  - [14:14] -  Receive FIFO/Buffer Flush
      0 - RXFLUSH_0 :
         No flush operation occurs.
      0x1 - RXFLUSH_1 :
         All data in the receive FIFO/buffer is cleared out.
 (rw) (01)  [0;32mTXFLUSH[0m  - [15:15] -  Transmit FIFO/Buffer Flush
      0 - TXFLUSH_0 :
         No flush operation occurs.
      0x1 - TXFLUSH_1 :
         All data in the transmit FIFO/Buffer is cleared out.
 (rw) (01)  [0;32mRXUF[0m  - [16:16] -  Receiver Buffer Underflow Flag
      0 - RXUF_0 :
         No receive buffer underflow has occurred since the last time the flag w
         as cleared.
      0x1 - RXUF_1 :
         At least one receive buffer underflow has occurred since the last time 
         the flag was cleared.
 (rw) (01)  [0;32mTXOF[0m  - [17:17] -  Transmitter Buffer Overflow Flag
      0 - TXOF_0 :
         No transmit buffer overflow has occurred since the last time the flag w
         as cleared.
      0x1 - TXOF_1 :
         At least one transmit buffer overflow has occurred since the last time 
         the flag was cleared.
 (ro) (01)  [0;32mRXEMPT[0m  - [22:22] -  Receive Buffer/FIFO Empty
      0 - RXEMPT_0 :
         Receive buffer is not empty.
      0x1 - RXEMPT_1 :
         Receive buffer is empty.
 (ro) (01)  [0;32mTXEMPT[0m  - [23:23] -  Transmit Buffer/FIFO Empty
      0 - TXEMPT_0 :
         Transmit buffer is not empty.
      0x1 - TXEMPT_1 :
         Transmit buffer is empty.
</lang>
#### p.LPUART4
<lang=dft>
base: 0x40190000
BAUD            CTRL            DATA            FIFO            
GLOBAL          MATCH           MODIR           PARAM           
PINCFG          STAT            VERID           WATER           
输入 p.LPUART4.{reg_name} 以查看寄存器的详细信息
type p.LPUART4.{reg_name} to check details of registers
</lang>
#### LPUART4.VERID
<link=p.LPUART4.VERID>
#### lpuart4.ctrl
<link=p.LPUART4.CTRL>
#### p.LPUART4.MODIR
<lang=dft>
 (rw)  [1;33m0x40190024[0m (0x40190000 + 0x0024)
LPUART Modem IrDA Register
 (rw) (01)  [0;32mTXCTSE[0m  - [00:00] -  Transmitter clear-to-send enable
      0 - TXCTSE_0 :
         CTS has no effect on the transmitter.
      0x1 - TXCTSE_1 :
         Enables clear-to-send operation. The transmitter checks the state of CT
         S each time it is ready to send a character. If CTS is asserted, the ch
         aracter is sent. If CTS is deasserted, the signal TXD remains in the ma
         rk state and transmission is delayed until CTS is asserted. Changes in 
         CTS as a character is being sent do not affect its transmission.
 (rw) (01)  [0;32mTXRTSE[0m  - [01:01] -  Transmitter request-to-send enable
      0 - TXRTSE_0 :
         The transmitter has no effect on RTS.
      0x1 - TXRTSE_1 :
         When a character is placed into an empty transmitter data buffer , RTS 
         asserts one bit time before the start bit is transmitted. RTS deasserts
          one bit time after all characters in the transmitter data buffer and s
         hift register are completely sent, including the last stop bit.
 (rw) (01)  [0;32mTXRTSPOL[0m  - [02:02] -  Transmitter request-to-send polarity
      0 - TXRTSPOL_0 :
         Transmitter RTS is active low.
      0x1 - TXRTSPOL_1 :
         Transmitter RTS is active high.
 (rw) (01)  [0;32mRXRTSE[0m  - [03:03] -  Receiver request-to-send enable
      0 - RXRTSE_0 :
         The receiver has no effect on RTS.
      0x1 - RXRTSE_1 :
         RTS is deasserted if the receiver data register is full or a start bit 
         has been detected that would cause the receiver data register to become
          full. RTS is asserted if the receiver data register is not full and ha
         s not detected a start bit that would cause the receiver data register 
         to become full.
 (rw) (01)  [0;32mTXCTSC[0m  - [04:04] -  Transmit CTS Configuration
      0 - TXCTSC_0 :
         CTS input is sampled at the start of each character.
      0x1 - TXCTSC_1 :
         CTS input is sampled when the transmitter is idle.
 (rw) (01)  [0;32mTXCTSSRC[0m  - [05:05] -  Transmit CTS Source
      0 - TXCTSSRC_0 :
         CTS input is the CTS_B pin.
      0x1 - TXCTSSRC_1 :
         CTS input is the inverted Receiver Match result.
 (rw) (02)  [0;32mRTSWATER[0m  - [09:08] -  Receive RTS Configuration
 (rw) (02)  [0;32mTNP[0m  - [17:16] -  Transmitter narrow pulse
      0 - TNP_0 :
         1/OSR.
      0x1 - TNP_1 :
         2/OSR.
      0x2 - TNP_2 :
         3/OSR.
      0x3 - TNP_3 :
         4/OSR.
 (rw) (01)  [0;32mIREN[0m  - [18:18] -  Infrared enable
      0 - IREN_0 :
         IR disabled.
      0x1 - IREN_1 :
         IR enabled.
</lang>
#### p.LPUART5.GLOBAL
<lang=dft>
 (rw)  [1;33m0x40194008[0m (0x40194000 + 0x0008)
LPUART Global Register
 (rw) (01)  [0;32mRST[0m  - [01:01] -  Software Reset
      0 - RST_0 :
         Module is not reset.
      0x1 - RST_1 :
         Module is reset.
</lang>
#### LPUART6.BAUD
<link=p.LPUART6.BAUD>
#### p.LPUART6.STAT
<lang=dft>
 (rw)  [1;33m0x40198014[0m (0x40198000 + 0x0014)
LPUART Status Register
 (rw) (01)  [0;32mMA2F[0m  - [14:14] -  Match 2 Flag
      0 - MA2F_0 :
         Received data is not equal to MA2
      0x1 - MA2F_1 :
         Received data is equal to MA2
 (rw) (01)  [0;32mMA1F[0m  - [15:15] -  Match 1 Flag
      0 - MA1F_0 :
         Received data is not equal to MA1
      0x1 - MA1F_1 :
         Received data is equal to MA1
 (rw) (01)  [0;32mPF[0m  - [16:16] -  Parity Error Flag
      0 - PF_0 :
         No parity error.
      0x1 - PF_1 :
         Parity error.
 (rw) (01)  [0;32mFE[0m  - [17:17] -  Framing Error Flag
      0 - FE_0 :
         No framing error detected. This does not guarantee the framing is corre
         ct.
      0x1 - FE_1 :
         Framing error.
 (rw) (01)  [0;32mNF[0m  - [18:18] -  Noise Flag
      0 - NF_0 :
         No noise detected.
      0x1 - NF_1 :
         Noise detected in the received character in the DATA register.
 (rw) (01)  [0;32mOR[0m  - [19:19] -  Receiver Overrun Flag
      0 - OR_0 :
         No overrun.
      0x1 - OR_1 :
         Receive overrun (new LPUART data lost).
 (rw) (01)  [0;32mIDLE[0m  - [20:20] -  Idle Line Flag
      0 - IDLE_0 :
         No idle line detected.
      0x1 - IDLE_1 :
         Idle line was detected.
 (ro) (01)  [0;32mRDRF[0m  - [21:21] -  Receive Data Register Full Flag
      0 - RDRF_0 :
         Receive data buffer empty.
      0x1 - RDRF_1 :
         Receive data buffer full.
 (ro) (01)  [0;32mTC[0m  - [22:22] -  Transmission Complete Flag
      0 - TC_0 :
         Transmitter active (sending data, a preamble, or a break).
      0x1 - TC_1 :
         Transmitter idle (transmission activity complete).
 (ro) (01)  [0;32mTDRE[0m  - [23:23] -  Transmit Data Register Empty Flag
      0 - TDRE_0 :
         Transmit data buffer full.
      0x1 - TDRE_1 :
         Transmit data buffer empty.
 (ro) (01)  [0;32mRAF[0m  - [24:24] -  Receiver Active Flag
      0 - RAF_0 :
         LPUART receiver idle waiting for a start bit.
      0x1 - RAF_1 :
         LPUART receiver active (RXD input not idle).
 (rw) (01)  [0;32mLBKDE[0m  - [25:25] -  LIN Break Detection Enable
      0 - LBKDE_0 :
         LIN break detect is disabled, normal break character can be detected.
      0x1 - LBKDE_1 :
         LIN break detect is enabled. LIN break character is detected at length 
         of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
 (rw) (01)  [0;32mBRK13[0m  - [26:26] -  Break Character Generation Length
      0 - BRK13_0 :
         Break character is transmitted with length of 9 to 13 bit times.
      0x1 - BRK13_1 :
         Break character is transmitted with length of 12 to 15 bit times.
 (rw) (01)  [0;32mRWUID[0m  - [27:27] -  Receive Wake Up Idle Detect
      0 - RWUID_0 :
         During receive standby state (RWU = 1), the IDLE bit does not get set u
         pon detection of an idle character. During address match wakeup, the ID
         LE bit does not set when an address does not match.
      0x1 - RWUID_1 :
         During receive standby state (RWU = 1), the IDLE bit gets set upon dete
         ction of an idle character. During address match wakeup, the IDLE bit d
         oes set when an address does not match.
 (rw) (01)  [0;32mRXINV[0m  - [28:28] -  Receive Data Inversion
      0 - RXINV_0 :
         Receive data not inverted.
      0x1 - RXINV_1 :
         Receive data inverted.
 (rw) (01)  [0;32mMSBF[0m  - [29:29] -  MSB First
      0 - MSBF_0 :
         LSB (bit0) is the first bit that is transmitted following the start bit
         . Further, the first bit received after the start bit is identified as 
         bit0.
      0x1 - MSBF_1 :
         MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted fol
         lowing the start bit depending on the setting of CTRL[M], CTRL[PE] and 
         BAUD[M10]. Further, the first bit received after the start bit is ident
         ified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] a
         nd CTRL[PE].
 (rw) (01)  [0;32mRXEDGIF[0m  - [30:30] -  RXD Pin Active Edge Interrupt Flag
      0 - RXEDGIF_0 :
         No active edge on the receive pin has occurred.
      0x1 - RXEDGIF_1 :
         An active edge on the receive pin has occurred.
 (rw) (01)  [0;32mLBKDIF[0m  - [31:31] -  LIN Break Detect Interrupt Flag
      0 - LBKDIF_0 :
         No LIN break character has been detected.
      0x1 - LBKDIF_1 :
         LIN break character has been detected.
</lang>
#### p.LPUART6.CTRL
<lang=dft>
 (rw)  [1;33m0x40198018[0m (0x40198000 + 0x0018)
LPUART Control Register
 (rw) (01)  [0;32mPT[0m  - [00:00] -  Parity Type
      0 - PT_0 :
         Even parity.
      0x1 - PT_1 :
         Odd parity.
 (rw) (01)  [0;32mPE[0m  - [01:01] -  Parity Enable
      0 - PE_0 :
         No hardware parity generation or checking.
      0x1 - PE_1 :
         Parity enabled.
 (rw) (01)  [0;32mILT[0m  - [02:02] -  Idle Line Type Select
      0 - ILT_0 :
         Idle character bit count starts after start bit.
      0x1 - ILT_1 :
         Idle character bit count starts after stop bit.
 (rw) (01)  [0;32mWAKE[0m  - [03:03] -  Receiver Wakeup Method Select
      0 - WAKE_0 :
         Configures RWU for idle-line wakeup.
      0x1 - WAKE_1 :
         Configures RWU with address-mark wakeup.
 (rw) (01)  [0;32mM[0m  - [04:04] -  9-Bit or 8-Bit Mode Select
      0 - M_0 :
         Receiver and transmitter use 8-bit data characters.
      0x1 - M_1 :
         Receiver and transmitter use 9-bit data characters.
 (rw) (01)  [0;32mRSRC[0m  - [05:05] -  Receiver Source Select
      0 - RSRC_0 :
         Provided LOOPS is set, RSRC is cleared, selects internal loop back mode
          and the LPUART does not use the RXD pin.
      0x1 - RSRC_1 :
         Single-wire LPUART mode where the TXD pin is connected to the transmitt
         er output and receiver input.
 (rw) (01)  [0;32mDOZEEN[0m  - [06:06] -  Doze Enable
      0 - DOZEEN_0 :
         LPUART is enabled in Doze mode.
      0x1 - DOZEEN_1 :
         LPUART is disabled in Doze mode.
 (rw) (01)  [0;32mLOOPS[0m  - [07:07] -  Loop Mode Select
      0 - LOOPS_0 :
         Normal operation - RXD and TXD use separate pins.
      0x1 - LOOPS_1 :
         Loop mode or single-wire mode where transmitter outputs are internally 
         connected to receiver input (see RSRC bit).
 (rw) (03)  [0;32mIDLECFG[0m  - [10:08] -  Idle Configuration
      0 - IDLECFG_0 :
         1 idle character
      0x1 - IDLECFG_1 :
         2 idle characters
      0x2 - IDLECFG_2 :
         4 idle characters
      0x3 - IDLECFG_3 :
         8 idle characters
      0x4 - IDLECFG_4 :
         16 idle characters
      0x5 - IDLECFG_5 :
         32 idle characters
      0x6 - IDLECFG_6 :
         64 idle characters
      0x7 - IDLECFG_7 :
         128 idle characters
 (rw) (01)  [0;32mM7[0m  - [11:11] -  7-Bit Mode Select
      0 - M7_0 :
         Receiver and transmitter use 8-bit to 10-bit data characters.
      0x1 - M7_1 :
         Receiver and transmitter use 7-bit data characters.
 (rw) (01)  [0;32mMA2IE[0m  - [14:14] -  Match 2 Interrupt Enable
      0 - MA2IE_0 :
         MA2F interrupt disabled
      0x1 - MA2IE_1 :
         MA2F interrupt enabled
 (rw) (01)  [0;32mMA1IE[0m  - [15:15] -  Match 1 Interrupt Enable
      0 - MA1IE_0 :
         MA1F interrupt disabled
      0x1 - MA1IE_1 :
         MA1F interrupt enabled
 (rw) (01)  [0;32mSBK[0m  - [16:16] -  Send Break
      0 - SBK_0 :
         Normal transmitter operation.
      0x1 - SBK_1 :
         Queue break character(s) to be sent.
 (rw) (01)  [0;32mRWU[0m  - [17:17] -  Receiver Wakeup Control
      0 - RWU_0 :
         Normal receiver operation.
      0x1 - RWU_1 :
         LPUART receiver in standby waiting for wakeup condition.
 (rw) (01)  [0;32mRE[0m  - [18:18] -  Receiver Enable
      0 - RE_0 :
         Receiver disabled.
      0x1 - RE_1 :
         Receiver enabled.
 (rw) (01)  [0;32mTE[0m  - [19:19] -  Transmitter Enable
      0 - TE_0 :
         Transmitter disabled.
      0x1 - TE_1 :
         Transmitter enabled.
 (rw) (01)  [0;32mILIE[0m  - [20:20] -  Idle Line Interrupt Enable
      0 - ILIE_0 :
         Hardware interrupts from IDLE disabled; use polling.
      0x1 - ILIE_1 :
         Hardware interrupt requested when IDLE flag is 1.
 (rw) (01)  [0;32mRIE[0m  - [21:21] -  Receiver Interrupt Enable
      0 - RIE_0 :
         Hardware interrupts from RDRF disabled; use polling.
      0x1 - RIE_1 :
         Hardware interrupt requested when RDRF flag is 1.
 (rw) (01)  [0;32mTCIE[0m  - [22:22] -  Transmission Complete Interrupt Enable for
      0 - TCIE_0 :
         Hardware interrupts from TC disabled; use polling.
      0x1 - TCIE_1 :
         Hardware interrupt requested when TC flag is 1.
 (rw) (01)  [0;32mTIE[0m  - [23:23] -  Transmit Interrupt Enable
      0 - TIE_0 :
         Hardware interrupts from TDRE disabled; use polling.
      0x1 - TIE_1 :
         Hardware interrupt requested when TDRE flag is 1.
 (rw) (01)  [0;32mPEIE[0m  - [24:24] -  Parity Error Interrupt Enable
      0 - PEIE_0 :
         PF interrupts disabled; use polling).
      0x1 - PEIE_1 :
         Hardware interrupt requested when PF is set.
 (rw) (01)  [0;32mFEIE[0m  - [25:25] -  Framing Error Interrupt Enable
      0 - FEIE_0 :
         FE interrupts disabled; use polling.
      0x1 - FEIE_1 :
         Hardware interrupt requested when FE is set.
 (rw) (01)  [0;32mNEIE[0m  - [26:26] -  Noise Error Interrupt Enable
      0 - NEIE_0 :
         NF interrupts disabled; use polling.
      0x1 - NEIE_1 :
         Hardware interrupt requested when NF is set.
 (rw) (01)  [0;32mORIE[0m  - [27:27] -  Overrun Interrupt Enable
      0 - ORIE_0 :
         OR interrupts disabled; use polling.
      0x1 - ORIE_1 :
         Hardware interrupt requested when OR is set.
 (rw) (01)  [0;32mTXINV[0m  - [28:28] -  Transmit Data Inversion
      0 - TXINV_0 :
         Transmit data not inverted.
      0x1 - TXINV_1 :
         Transmit data inverted.
 (rw) (01)  [0;32mTXDIR[0m  - [29:29] -  TXD Pin Direction in Single-Wire Mode
      0 - TXDIR_0 :
         TXD pin is an input in single-wire mode.
      0x1 - TXDIR_1 :
         TXD pin is an output in single-wire mode.
 (rw) (01)  [0;32mR9T8[0m  - [30:30] -  Receive Bit 9 / Transmit Bit 8
 (rw) (01)  [0;32mR8T9[0m  - [31:31] -  Receive Bit 8 / Transmit Bit 9
</lang>
#### LPUART6.DATA
<link=p.LPUART6.DATA>
#### LPUART7.BAUD
<link=p.LPUART7.BAUD>
#### p.lpuart7.ctrl
<link=p.LPUART7.CTRL>
#### p.lpuart8.param
<link=p.LPUART8.PARAM>
#### LPUART8.PARAM
<link=p.LPUART8.PARAM>
#### LPUART8.GLOBAL
<link=p.LPUART8.GLOBAL>
#### p.lpuart8.stat
<link=p.LPUART8.STAT>
#### LPUART8.CTRL
<link=p.LPUART8.CTRL>
#### lpuart8.match
<link=p.LPUART8.MATCH>
#### p.lpuart8.fifo
<link=p.LPUART8.FIFO>
#### p.FLEXIO1.SHIFTERR
<lang=dft>
 (rw)  [1;33m0x401ac014[0m (0x401ac000 + 0x0014)
Shifter Error Register
 (rw) (04)  [0;32mSEF[0m  - [03:00] -  Shifter Error Flags
</lang>
#### FLEXIO1.SHIFTSIEN
<link=p.FLEXIO1.SHIFTSIEN>
#### FLEXIO1.SHIFTSDEN
<link=p.FLEXIO1.SHIFTSDEN>
#### FLEXIO1.SHIFTCTL[2]
<link=p.FLEXIO1.SHIFTCTL[2]>
#### p.flexio1.shiftcfg[0]
<link=p.FLEXIO1.SHIFTCFG[0]>
#### p.FLEXIO1.SHIFTCFG[2]
<lang=dft>
 (rw)  [1;33m0x401ac108[0m (0x401ac000 + 0x0108)
Shifter Configuration N Register
 (rw) (02)  [0;32mSSTART[0m  - [01:00] -  Shifter Start bit
      0 - SSTART_0 :
         Start bit disabled for transmitter/receiver/match store, transmitter lo
         ads data on enable
      0x1 - SSTART_1 :
         Start bit disabled for transmitter/receiver/match store, transmitter lo
         ads data on first shift
      0x2 - SSTART_2 :
         Transmitter outputs start bit value 0 before loading data on first shif
         t, receiver/match store sets error flag if start bit is not 0
      0x3 - SSTART_3 :
         Transmitter outputs start bit value 1 before loading data on first shif
         t, receiver/match store sets error flag if start bit is not 1
 (rw) (02)  [0;32mSSTOP[0m  - [05:04] -  Shifter Stop bit
      0 - SSTOP_0 :
         Stop bit disabled for transmitter/receiver/match store
      0x2 - SSTOP_2 :
         Transmitter outputs stop bit value 0 on store, receiver/match store set
         s error flag if stop bit is not 0
      0x3 - SSTOP_3 :
         Transmitter outputs stop bit value 1 on store, receiver/match store set
         s error flag if stop bit is not 1
 (rw) (01)  [0;32mINSRC[0m  - [08:08] -  Input Source
      0 - INSRC_0 :
         Pin
      0x1 - INSRC_1 :
         Shifter N+1 Output
 (rw) (04)  [0;32mPWIDTH[0m  - [19:16] -  Parallel Width
</lang>
#### flexio1.shiftbuf[0]
<link=p.FLEXIO1.SHIFTBUF[0]>
#### p.FLEXIO1.SHIFTBUFBIS[3]
<lang=dft>
 (rw)  [1;33m0x401ac28c[0m (0x401ac000 + 0x028c)
Shifter Buffer N Bit Swapped Register
 (rw) (32)  [0;32mSHIFTBUFBIS[0m  - [31:00] -  Shift Buffer
</lang>
#### p.flexio1.shiftbufbys[3]
<link=p.FLEXIO1.SHIFTBUFBYS[3]>
#### p.flexio1.timcfg[2]
<link=p.FLEXIO1.TIMCFG[2]>
#### p.flexio1.shiftbufnbs[2]
<link=p.FLEXIO1.SHIFTBUFNBS[2]>
#### FLEXIO1.SHIFTBUFNBS[2]
<link=p.FLEXIO1.SHIFTBUFNBS[2]>
#### p.FLEXIO1.SHIFTBUFHWS[3]
<lang=dft>
 (rw)  [1;33m0x401ac70c[0m (0x401ac000 + 0x070c)
Shifter Buffer N Half Word Swapped Register
 (rw) (32)  [0;32mSHIFTBUFHWS[0m  - [31:00] -  Shift Buffer
</lang>
#### p.FLEXIO1.SHIFTBUFNIS[0]
<lang=dft>
 (rw)  [1;33m0x401ac780[0m (0x401ac000 + 0x0780)
Shifter Buffer N Nibble Swapped Register
 (rw) (32)  [0;32mSHIFTBUFNIS[0m  - [31:00] -  Shift Buffer
</lang>
#### p.flexio1.shiftbufnis[0]
<link=p.FLEXIO1.SHIFTBUFNIS[0]>
#### p.flexio2.timstat
<link=p.FLEXIO2.TIMSTAT>
#### flexio2.shiftsien
<link=p.FLEXIO2.SHIFTSIEN>
#### flexio2.shifteien
<link=p.FLEXIO2.SHIFTEIEN>
#### p.FLEXIO2.SHIFTCTL[1]
<lang=dft>
 (rw)  [1;33m0x401b0084[0m (0x401b0000 + 0x0084)
Shifter Control N Register
 (rw) (03)  [0;32mSMOD[0m  - [02:00] -  Shifter Mode
      0 - SMOD_0 :
         Disabled.
      0x1 - SMOD_1 :
         Receive mode. Captures the current Shifter content into the SHIFTBUF on
          expiration of the Timer.
      0x2 - SMOD_2 :
         Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of
          the Timer.
      0x4 - SMOD_4 :
         Match Store mode. Shifter data is compared to SHIFTBUF content on expir
         ation of the Timer.
      0x5 - SMOD_5 :
         Match Continuous mode. Shifter data is continuously compared to SHIFTBU
         F contents.
      0x6 - SMOD_6 :
         State mode. SHIFTBUF contents are used for storing programmable state a
         ttributes.
      0x7 - SMOD_7 :
         Logic mode. SHIFTBUF contents are used for implementing programmable lo
         gic look up table.
 (rw) (01)  [0;32mPINPOL[0m  - [07:07] -  Shifter Pin Polarity
      0 - PINPOL_0 :
         Pin is active high
      0x1 - PINPOL_1 :
         Pin is active low
 (rw) (04)  [0;32mPINSEL[0m  - [11:08] -  Shifter Pin Select
 (rw) (02)  [0;32mPINCFG[0m  - [17:16] -  Shifter Pin Configuration
      0 - PINCFG_0 :
         Shifter pin output disabled
      0x1 - PINCFG_1 :
         Shifter pin open drain or bidirectional output enable
      0x2 - PINCFG_2 :
         Shifter pin bidirectional output data
      0x3 - PINCFG_3 :
         Shifter pin output
 (rw) (01)  [0;32mTIMPOL[0m  - [23:23] -  Timer Polarity
      0 - TIMPOL_0 :
         Shift on posedge of Shift clock
      0x1 - TIMPOL_1 :
         Shift on negedge of Shift clock
 (rw) (02)  [0;32mTIMSEL[0m  - [25:24] -  Timer Select
</lang>
#### FLEXIO2.SHIFTCTL[2]
<link=p.FLEXIO2.SHIFTCTL[2]>
#### FLEXIO2.SHIFTBUFBIS[2]
<link=p.FLEXIO2.SHIFTBUFBIS[2]>
#### p.FLEXIO2.SHIFTBUFBYS[3]
<lang=dft>
 (rw)  [1;33m0x401b030c[0m (0x401b0000 + 0x030c)
Shifter Buffer N Byte Swapped Register
 (rw) (32)  [0;32mSHIFTBUFBYS[0m  - [31:00] -  Shift Buffer
</lang>
#### FLEXIO2.TIMCTL[1]
<link=p.FLEXIO2.TIMCTL[1]>
#### flexio2.timcfg[2]
<link=p.FLEXIO2.TIMCFG[2]>
#### p.flexio2.timcfg[3]
<link=p.FLEXIO2.TIMCFG[3]>
#### p.FLEXIO2.TIMCMP[2]
<lang=dft>
 (rw)  [1;33m0x401b0508[0m (0x401b0000 + 0x0508)
Timer Compare N Register
 (rw) (16)  [0;32mCMP[0m  - [15:00] -  Timer Compare Value
</lang>
#### FLEXIO2.SHIFTBUFNBS[0]
<link=p.FLEXIO2.SHIFTBUFNBS[0]>
#### flexio2.shiftbufnbs[2]
<link=p.FLEXIO2.SHIFTBUFNBS[2]>
#### p.FLEXIO2.SHIFTBUFHWS[3]
<lang=dft>
 (rw)  [1;33m0x401b070c[0m (0x401b0000 + 0x070c)
Shifter Buffer N Half Word Swapped Register
 (rw) (32)  [0;32mSHIFTBUFHWS[0m  - [31:00] -  Shift Buffer
</lang>
#### flexio2.shiftbufnis[0]
<link=p.FLEXIO2.SHIFTBUFNIS[0]>
#### p.flexio2.shiftbufnis[3]
<link=p.FLEXIO2.SHIFTBUFNIS[3]>
#### p.FLEXIO3.VERID
<lang=dft>
 (ro)  [1;33m0x42020000[0m (0x42020000 + 0x0000)
Version ID Register
 (ro) (16)  [0;32mFEATURE[0m  - [15:00] -  Feature Specification Number
      0 - FEATURE_0 :
         Standard features implemented.
      0x1 - FEATURE_1 :
         Supports state, logic and parallel modes.
 (ro) (08)  [0;32mMINOR[0m  - [23:16] -  Minor Version Number
 (ro) (08)  [0;32mMAJOR[0m  - [31:24] -  Major Version Number
</lang>
#### p.FLEXIO3.PIN
<lang=dft>
 (ro)  [1;33m0x4202000c[0m (0x42020000 + 0x000c)
Pin State Register
 (ro) (16)  [0;32mPDI[0m  - [15:00] -  Pin Data Input
</lang>
#### flexio3.shifterr
<link=p.FLEXIO3.SHIFTERR>
#### flexio3.shiftctl[0]
<link=p.FLEXIO3.SHIFTCTL[0]>
#### p.FLEXIO3.SHIFTCTL[1]
<lang=dft>
 (rw)  [1;33m0x42020084[0m (0x42020000 + 0x0084)
Shifter Control N Register
 (rw) (03)  [0;32mSMOD[0m  - [02:00] -  Shifter Mode
      0 - SMOD_0 :
         Disabled.
      0x1 - SMOD_1 :
         Receive mode. Captures the current Shifter content into the SHIFTBUF on
          expiration of the Timer.
      0x2 - SMOD_2 :
         Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of
          the Timer.
      0x4 - SMOD_4 :
         Match Store mode. Shifter data is compared to SHIFTBUF content on expir
         ation of the Timer.
      0x5 - SMOD_5 :
         Match Continuous mode. Shifter data is continuously compared to SHIFTBU
         F contents.
      0x6 - SMOD_6 :
         State mode. SHIFTBUF contents are used for storing programmable state a
         ttributes.
      0x7 - SMOD_7 :
         Logic mode. SHIFTBUF contents are used for implementing programmable lo
         gic look up table.
 (rw) (01)  [0;32mPINPOL[0m  - [07:07] -  Shifter Pin Polarity
      0 - PINPOL_0 :
         Pin is active high
      0x1 - PINPOL_1 :
         Pin is active low
 (rw) (04)  [0;32mPINSEL[0m  - [11:08] -  Shifter Pin Select
 (rw) (02)  [0;32mPINCFG[0m  - [17:16] -  Shifter Pin Configuration
      0 - PINCFG_0 :
         Shifter pin output disabled
      0x1 - PINCFG_1 :
         Shifter pin open drain or bidirectional output enable
      0x2 - PINCFG_2 :
         Shifter pin bidirectional output data
      0x3 - PINCFG_3 :
         Shifter pin output
 (rw) (01)  [0;32mTIMPOL[0m  - [23:23] -  Timer Polarity
      0 - TIMPOL_0 :
         Shift on posedge of Shift clock
      0x1 - TIMPOL_1 :
         Shift on negedge of Shift clock
 (rw) (02)  [0;32mTIMSEL[0m  - [25:24] -  Timer Select
</lang>
#### p.flexio3.shiftbuf[0]
<link=p.FLEXIO3.SHIFTBUF[0]>
#### p.flexio3.shiftbufbis[1]
<link=p.FLEXIO3.SHIFTBUFBIS[1]>
#### FLEXIO3.SHIFTBUFBYS[0]
<link=p.FLEXIO3.SHIFTBUFBYS[0]>
#### p.FLEXIO3.TIMCTL[1]
<lang=dft>
 (rw)  [1;33m0x42020404[0m (0x42020000 + 0x0404)
Timer Control N Register
 (rw) (02)  [0;32mTIMOD[0m  - [01:00] -  Timer Mode
      0 - TIMOD_0 :
         Timer Disabled.
      0x1 - TIMOD_1 :
         Dual 8-bit counters baud mode.
      0x2 - TIMOD_2 :
         Dual 8-bit counters PWM high mode.
      0x3 - TIMOD_3 :
         Single 16-bit counter mode.
 (rw) (01)  [0;32mPINPOL[0m  - [07:07] -  Timer Pin Polarity
      0 - PINPOL_0 :
         Pin is active high
      0x1 - PINPOL_1 :
         Pin is active low
 (rw) (04)  [0;32mPINSEL[0m  - [11:08] -  Timer Pin Select
 (rw) (02)  [0;32mPINCFG[0m  - [17:16] -  Timer Pin Configuration
      0 - PINCFG_0 :
         Timer pin output disabled
      0x1 - PINCFG_1 :
         Timer pin open drain or bidirectional output enable
      0x2 - PINCFG_2 :
         Timer pin bidirectional output data
      0x3 - PINCFG_3 :
         Timer pin output
 (rw) (01)  [0;32mTRGSRC[0m  - [22:22] -  Trigger Source
      0 - TRGSRC_0 :
         External trigger selected
      0x1 - TRGSRC_1 :
         Internal trigger selected
 (rw) (01)  [0;32mTRGPOL[0m  - [23:23] -  Trigger Polarity
      0 - TRGPOL_0 :
         Trigger active high
      0x1 - TRGPOL_1 :
         Trigger active low
 (rw) (05)  [0;32mTRGSEL[0m  - [28:24] -  Trigger Select
</lang>
#### FLEXIO3.TIMCTL[2]
<link=p.FLEXIO3.TIMCTL[2]>
#### FLEXIO3.TIMCFG[2]
<link=p.FLEXIO3.TIMCFG[2]>
#### flexio3.shiftbufnbs[0]
<link=p.FLEXIO3.SHIFTBUFNBS[0]>
#### p.FLEXIO3.SHIFTBUFNBS[1]
<lang=dft>
 (rw)  [1;33m0x42020684[0m (0x42020000 + 0x0684)
Shifter Buffer N Nibble Byte Swapped Register
 (rw) (32)  [0;32mSHIFTBUFNBS[0m  - [31:00] -  Shift Buffer
</lang>
#### FLEXIO3.SHIFTBUFNBS[1]
<link=p.FLEXIO3.SHIFTBUFNBS[1]>
#### p.gpio1.dr
<link=p.GPIO1.DR>
#### GPIO1.GDIR
<link=p.GPIO1.GDIR>
#### p.gpio1.psr
<link=p.GPIO1.PSR>
#### gpio1.dr_clear
<link=p.GPIO1.DR_CLEAR>
#### p.GPIO1.DR_TOGGLE
<lang=dft>
 (wo)  [1;33m0x401b808c[0m (0x401b8000 + 0x008c)
GPIO data register TOGGLE
 (wo) (32)  [0;32mDR_TOGGLE[0m  - [31:00] -  DR_TOGGLE
</lang>
#### p.GPIO5.ICR1
<lang=dft>
 (rw)  [1;33m0x400c000c[0m (0x400c0000 + 0x000c)
GPIO interrupt configuration register1
 (rw) (02)  [0;32mICR0[0m  - [01:00] -  ICR0
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR1[0m  - [03:02] -  ICR1
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR2[0m  - [05:04] -  ICR2
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR3[0m  - [07:06] -  ICR3
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR4[0m  - [09:08] -  ICR4
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR5[0m  - [11:10] -  ICR5
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR6[0m  - [13:12] -  ICR6
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR7[0m  - [15:14] -  ICR7
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR8[0m  - [17:16] -  ICR8
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR9[0m  - [19:18] -  ICR9
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR10[0m  - [21:20] -  ICR10
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR11[0m  - [23:22] -  ICR11
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR12[0m  - [25:24] -  ICR12
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR13[0m  - [27:26] -  ICR13
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR14[0m  - [29:28] -  ICR14
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR15[0m  - [31:30] -  ICR15
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
</lang>
#### GPIO5.ICR1
<link=p.GPIO5.ICR1>
#### p.GPIO3.ICR2
<lang=dft>
 (rw)  [1;33m0x401c0010[0m (0x401c0000 + 0x0010)
GPIO interrupt configuration register2
 (rw) (02)  [0;32mICR16[0m  - [01:00] -  ICR16
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR17[0m  - [03:02] -  ICR17
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR18[0m  - [05:04] -  ICR18
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR19[0m  - [07:06] -  ICR19
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR20[0m  - [09:08] -  ICR20
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR21[0m  - [11:10] -  ICR21
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR22[0m  - [13:12] -  ICR22
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR23[0m  - [15:14] -  ICR23
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR24[0m  - [17:16] -  ICR24
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR25[0m  - [19:18] -  ICR25
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR26[0m  - [21:20] -  ICR26
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR27[0m  - [23:22] -  ICR27
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR28[0m  - [25:24] -  ICR28
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR29[0m  - [27:26] -  ICR29
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR30[0m  - [29:28] -  ICR30
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
 (rw) (02)  [0;32mICR31[0m  - [31:30] -  ICR31
      0 - LOW_LEVEL :
         Interrupt n is low-level sensitive.
      0x1 - HIGH_LEVEL :
         Interrupt n is high-level sensitive.
      0x2 - RISING_EDGE :
         Interrupt n is rising-edge sensitive.
      0x3 - FALLING_EDGE :
         Interrupt n is falling-edge sensitive.
</lang>
#### gpio3.edge_sel
<link=p.GPIO3.EDGE_SEL>
#### p.gpio3.dr_set
<link=p.GPIO3.DR_SET>
#### p.GPIO6.DR
<lang=dft>
 (rw)  [1;33m0x42000000[0m (0x42000000 + 0x0000)
GPIO data register
 (rw) (32)  [0;32mDR[0m  - [31:00] -  DR
</lang>
#### p.GPIO7
<lang=dft>
base: 0x42004000
DR              DR_CLEAR        DR_SET          DR_TOGGLE       
EDGE_SEL        GDIR            ICR1            ICR2            
IMR             ISR             PSR             
输入 p.GPIO7.{reg_name} 以查看寄存器的详细信息
type p.GPIO7.{reg_name} to check details of registers
</lang>
#### p.GPIO7.DR_CLEAR
<lang=dft>
 (wo)  [1;33m0x42004088[0m (0x42004000 + 0x0088)
GPIO data register CLEAR
 (wo) (32)  [0;32mDR_CLEAR[0m  - [31:00] -  DR_CLEAR
</lang>
#### p.GPIO8.DR
<lang=dft>
 (rw)  [1;33m0x42008000[0m (0x42008000 + 0x0000)
GPIO data register
 (rw) (32)  [0;32mDR[0m  - [31:00] -  DR
</lang>
#### p.GPIO9.IMR
<lang=dft>
 (rw)  [1;33m0x4200c014[0m (0x4200c000 + 0x0014)
GPIO interrupt mask register
 (rw) (32)  [0;32mIMR[0m  - [31:00] -  IMR
</lang>
#### GPIO9.IMR
<link=p.GPIO9.IMR>
#### GPIO9.DR_CLEAR
<link=p.GPIO9.DR_CLEAR>
#### p.can1.imask2
<link=p.CAN1.IMASK2>
#### can1.imask1
<link=p.CAN1.IMASK1>
#### p.CAN1.IFLAG1
<lang=dft>
 (rw)  [1;33m0x401d0030[0m (0x401d0000 + 0x0030)
Interrupt Flags 1 Register
 (rw) (05)  [0;32mBUF4TO0I[0m  - [04:00] -  If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 to MB4
      0 - BUF4TO0I_0 :
         No such occurrence
      0x1 - BUF4TO0I_1 :
         Corresponding MB completed transmission/reception
 (rw) (01)  [0;32mBUF5I[0m  - [05:05] -  If the Rx FIFO is not enabled, this bit flags the interrupt for MB5
      0 - BUF5I_0 :
         No such occurrence
      0x1 - BUF5I_1 :
         MB5 completed transmission/reception or frames available in the FIFO
 (rw) (01)  [0;32mBUF6I[0m  - [06:06] -  If the Rx FIFO is not enabled, this bit flags the interrupt for MB6
      0 - BUF6I_0 :
         No such occurrence
      0x1 - BUF6I_1 :
         MB6 completed transmission/reception or FIFO almost full
 (rw) (01)  [0;32mBUF7I[0m  - [07:07] -  If the Rx FIFO is not enabled, this bit flags the interrupt for MB7
      0 - BUF7I_0 :
         No such occurrence
      0x1 - BUF7I_1 :
         MB7 completed transmission/reception or FIFO overflow
 (rw) (24)  [0;32mBUF31TO8I[0m  - [31:08] -  Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt.
      0 - BUF31TO8I_0 :
         No such occurrence
      0x1 - BUF31TO8I_1 :
         The corresponding MB has successfully completed transmission or recepti
         on
</lang>
#### can1.ctrl2
<link=p.CAN1.CTRL2>
#### p.CAN1.RXIMR8
<lang=dft>
 (rw)  [1;33m0x401d08a0[0m (0x401d0000 + 0x08a0)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### CAN1.RXIMR9
<link=p.CAN1.RXIMR9>
#### can1.rximr10
<link=p.CAN1.RXIMR10>
#### p.CAN1.RXIMR13
<lang=dft>
 (rw)  [1;33m0x401d08b4[0m (0x401d0000 + 0x08b4)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### CAN1.RXIMR13
<link=p.CAN1.RXIMR13>
#### p.CAN1.RXIMR22
<lang=dft>
 (rw)  [1;33m0x401d08d8[0m (0x401d0000 + 0x08d8)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### CAN1.RXIMR27
<link=p.CAN1.RXIMR27>
#### can1.rximr29
<link=p.CAN1.RXIMR29>
#### p.can1.rximr39
<link=p.CAN1.RXIMR39>
#### can1.rximr43
<link=p.CAN1.RXIMR43>
#### CAN1.RXIMR44
<link=p.CAN1.RXIMR44>
#### p.CAN1.RXIMR49
<lang=dft>
 (rw)  [1;33m0x401d0944[0m (0x401d0000 + 0x0944)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### p.can1.rximr53
<link=p.CAN1.RXIMR53>
#### p.can1.rximr62
<link=p.CAN1.RXIMR62>
#### p.can2.ctrl1
<link=p.CAN2.CTRL1>
#### CAN2.CTRL1
<link=p.CAN2.CTRL1>
#### can2.timer
<link=p.CAN2.TIMER>
#### p.can2.esr1
<link=p.CAN2.ESR1>
#### p.CAN2.RXFGMASK
<lang=dft>
 (rw)  [1;33m0x401d4048[0m (0x401d4000 + 0x0048)
Rx FIFO Global Mask Register
 (rw) (32)  [0;32mFGM[0m  - [31:00] -  These bits mask the ID Filter Table elements bits in a perfect alignment
      0 - FGM_0 :
         The corresponding bit in the filter is "don't care"
      0x1 - FGM_1 :
         The corresponding bit in the filter is checked
</lang>
#### p.CAN2.RXIMR1
<lang=dft>
 (rw)  [1;33m0x401d4884[0m (0x401d4000 + 0x0884)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### can2.rximr2
<link=p.CAN2.RXIMR2>
#### can2.rximr13
<link=p.CAN2.RXIMR13>
#### p.CAN2.RXIMR18
<lang=dft>
 (rw)  [1;33m0x401d48c8[0m (0x401d4000 + 0x08c8)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### CAN2.RXIMR18
<link=p.CAN2.RXIMR18>
#### p.can2.rximr21
<link=p.CAN2.RXIMR21>
#### can2.rximr26
<link=p.CAN2.RXIMR26>
#### CAN2.RXIMR29
<link=p.CAN2.RXIMR29>
#### p.can2.rximr32
<link=p.CAN2.RXIMR32>
#### can2.rximr35
<link=p.CAN2.RXIMR35>
#### p.can2.rximr43
<link=p.CAN2.RXIMR43>
#### p.CAN2.RXIMR47
<lang=dft>
 (rw)  [1;33m0x401d493c[0m (0x401d4000 + 0x093c)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### p.can2.rximr50
<link=p.CAN2.RXIMR50>
#### p.CAN2.RXIMR54
<lang=dft>
 (rw)  [1;33m0x401d4958[0m (0x401d4000 + 0x0958)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### CAN2.RXIMR54
<link=p.CAN2.RXIMR54>
#### p.CAN2.RXIMR61
<lang=dft>
 (rw)  [1;33m0x401d4974[0m (0x401d4000 + 0x0974)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in dist
 inct ways
      0 - MI_0 :
         the corresponding bit in the filter is "don't care"
      0x1 - MI_1 :
         The corresponding bit in the filter is checked
</lang>
#### p.CAN3.CTRL1
<lang=dft>
 (rw)  [1;33m0x401d8004[0m (0x401d8000 + 0x0004)
Control 1 register
 (rw) (03)  [0;32mPROPSEG[0m  - [02:00] -  Propagation Segment
 (rw) (01)  [0;32mLOM[0m  - [03:03] -  Listen-Only Mode
      0 - LOM_0 :
         Listen-Only mode is deactivated.
      0x1 - LOM_1 :
         FlexCAN module operates in Listen-Only mode.
 (rw) (01)  [0;32mLBUF[0m  - [04:04] -  Lowest Buffer Transmitted First
      0 - LBUF_0 :
         Buffer with highest priority is transmitted first.
      0x1 - LBUF_1 :
         Lowest number buffer is transmitted first.
 (rw) (01)  [0;32mTSYN[0m  - [05:05] -  Timer Sync
      0 - TSYN_0 :
         Timer Sync feature disabled
      0x1 - TSYN_1 :
         Timer Sync feature enabled
 (rw) (01)  [0;32mBOFFREC[0m  - [06:06] -  Bus Off Recovery
      0 - BOFFREC_0 :
         Automatic recovering from Bus Off state enabled.
      0x1 - BOFFREC_1 :
         Automatic recovering from Bus Off state disabled.
 (rw) (01)  [0;32mSMP[0m  - [07:07] -  CAN Bit Sampling
      0 - SMP_0 :
         Just one sample is used to determine the bit value.
      0x1 - SMP_1 :
         Three samples are used to determine the value of the received bit: the 
         regular one (sample point) and 2 preceding samples; a majority rule is 
         used.
 (rw) (01)  [0;32mRWRNMSK[0m  - [10:10] -  Rx Warning Interrupt Mask
      0 - RWRNMSK_0 :
         Rx Warning Interrupt disabled.
      0x1 - RWRNMSK_1 :
         Rx Warning Interrupt enabled.
 (rw) (01)  [0;32mTWRNMSK[0m  - [11:11] -  Tx Warning Interrupt Mask
      0 - TWRNMSK_0 :
         Tx Warning Interrupt disabled.
      0x1 - TWRNMSK_1 :
         Tx Warning Interrupt enabled.
 (rw) (01)  [0;32mLPB[0m  - [12:12] -  Loop Back Mode
      0 - LPB_0 :
         Loop Back disabled.
      0x1 - LPB_1 :
         Loop Back enabled.
 (rw) (01)  [0;32mCLKSRC[0m  - [13:13] -  CAN Engine Clock Source
      0 - CLKSRC_0 :
         The CAN engine clock source is the oscillator clock. Under this conditi
         on, the oscillator clock frequency must be lower than the bus clock.
      0x1 - CLKSRC_1 :
         The CAN engine clock source is the peripheral clock.
 (rw) (01)  [0;32mERRMSK[0m  - [14:14] -  Error Interrupt Mask
      0 - ERRMSK_0 :
         Error interrupt disabled.
      0x1 - ERRMSK_1 :
         Error interrupt enabled.
 (rw) (01)  [0;32mBOFFMSK[0m  - [15:15] -  Bus Off Interrupt Mask
      0 - BOFFMSK_0 :
         Bus Off interrupt disabled.
      0x1 - BOFFMSK_1 :
         Bus Off interrupt enabled.
 (rw) (03)  [0;32mPSEG2[0m  - [18:16] -  Phase Segment 2
 (rw) (03)  [0;32mPSEG1[0m  - [21:19] -  Phase Segment 1
 (rw) (02)  [0;32mRJW[0m  - [23:22] -  Resync Jump Width
 (rw) (08)  [0;32mPRESDIV[0m  - [31:24] -  Prescaler Division Factor
</lang>
#### CAN3.RX14MASK
<link=p.CAN3.RX14MASK>
#### p.can3.rx15mask
<link=p.CAN3.RX15MASK>
#### CAN3.RX15MASK
<link=p.CAN3.RX15MASK>
#### can3.mb0_16b_word2
<link=p.CAN3.MB0_16B_WORD2>
#### CAN3.ID1
<link=p.CAN3.ID1>
#### p.CAN3.MB0_16B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d8094[0m (0x401d8000 + 0x0094)
Message Buffer 0 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb0_64b_word4
<link=p.CAN3.MB0_64B_WORD4>
#### CAN3.MB1_8B_WORD0
<link=p.CAN3.MB1_8B_WORD0>
#### can3.mb0_64b_word5
<link=p.CAN3.MB0_64B_WORD5>
#### p.can3.mb0_32b_word6
<link=p.CAN3.MB0_32B_WORD6>
#### CAN3.MB0_32B_WORD6
<link=p.CAN3.MB0_32B_WORD6>
#### can3.mb1_16b_word0
<link=p.CAN3.MB1_16B_WORD0>
#### can3.mb2_8b_cs
<link=p.CAN3.MB2_8B_CS>
#### p.CAN3.WORD12
<lang=dft>
 (rw)  [1;33m0x401d80ac[0m (0x401d8000 + 0x00ac)
Message Buffer 2 WORD1 Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB0_64B_WORD12
<link=p.CAN3.MB0_64B_WORD12>
#### p.CAN3.MB1_32B_WORD2
<lang=dft>
 (rw)  [1;33m0x401d80b8[0m (0x401d8000 + 0x00b8)
Message Buffer 1 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_11[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_10[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_9[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_8[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB3_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d80bc[0m (0x401d8000 + 0x00bc)
Message Buffer 3 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.WORD13
<link=p.CAN3.WORD13>
#### p.CAN3.CS4
<lang=dft>
 (rw)  [1;33m0x401d80c0[0m (0x401d8000 + 0x00c0)
Message Buffer 4 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.can3.mb1_32b_word4
<link=p.CAN3.MB1_32B_WORD4>
#### CAN3.MB4_8B_CS
<link=p.CAN3.MB4_8B_CS>
#### CAN3.MB1_64B_CS
<link=p.CAN3.MB1_64B_CS>
#### p.CAN3.MB3_16B_CS
<lang=dft>
 (rw)  [1;33m0x401d80c8[0m (0x401d8000 + 0x00c8)
Message Buffer 3 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.CAN3.MB2_32B_CS
<lang=dft>
 (rw)  [1;33m0x401d80d0[0m (0x401d8000 + 0x00d0)
Message Buffer 2 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### CAN3.MB5_8B_CS
<link=p.CAN3.MB5_8B_CS>
#### p.can3.mb2_32b_id
<link=p.CAN3.MB2_32B_ID>
#### can3.mb3_16b_word2
<link=p.CAN3.MB3_16B_WORD2>
#### can3.mb5_8b_word0
<link=p.CAN3.MB5_8B_WORD0>
#### p.CAN3.WORD05
<lang=dft>
 (rw)  [1;33m0x401d80d8[0m (0x401d8000 + 0x00d8)
Message Buffer 5 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb1_64b_word3
<link=p.CAN3.MB1_64B_WORD3>
#### CAN3.MB1_64B_WORD3
<link=p.CAN3.MB1_64B_WORD3>
#### p.can3.word15
<link=p.CAN3.WORD15>
#### CAN3.MB4_16B_CS
<link=p.CAN3.MB4_16B_CS>
#### p.CAN3.MB6_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d80e0[0m (0x401d8000 + 0x00e0)
Message Buffer 6 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.can3.mb6_8b_cs
<link=p.CAN3.MB6_8B_CS>
#### p.can3.word06
<link=p.CAN3.WORD06>
#### p.CAN3.MB1_64B_WORD9
<lang=dft>
 (rw)  [1;33m0x401d80f4[0m (0x401d8000 + 0x00f4)
Message Buffer 1 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_39[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_38[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_37[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_36[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb7_8b_id
<link=p.CAN3.MB7_8B_ID>
#### CAN3.MB1_64B_WORD10
<link=p.CAN3.MB1_64B_WORD10>
#### can3.mb3_32b_id
<link=p.CAN3.MB3_32B_ID>
#### p.CAN3.MB3_32B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d8100[0m (0x401d8000 + 0x0100)
Message Buffer 3 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB3_32B_WORD0
<link=p.CAN3.MB3_32B_WORD0>
#### CAN3.WORD08
<link=p.CAN3.WORD08>
#### can3.word18
<link=p.CAN3.WORD18>
#### p.can3.cs9
<link=p.CAN3.CS9>
#### p.can3.mb3_32b_word4
<link=p.CAN3.MB3_32B_WORD4>
#### can3.mb9_8b_cs
<link=p.CAN3.MB9_8B_CS>
#### CAN3.MB2_64B_ID
<link=p.CAN3.MB2_64B_ID>
#### can3.mb9_8b_word0
<link=p.CAN3.MB9_8B_WORD0>
#### p.CAN3.MB6_16B_WORD2
<lang=dft>
 (rw)  [1;33m0x401d8120[0m (0x401d8000 + 0x0120)
Message Buffer 6 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_11[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_10[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_9[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_8[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.id10
<link=p.CAN3.ID10>
#### p.CAN3.MB2_64B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d8124[0m (0x401d8000 + 0x0124)
Message Buffer 2 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb4_32b_id
<link=p.CAN3.MB4_32B_ID>
#### CAN3.MB4_32B_ID
<link=p.CAN3.MB4_32B_ID>
#### can3.mb6_16b_word3
<link=p.CAN3.MB6_16B_WORD3>
#### CAN3.MB7_16B_ID
<link=p.CAN3.MB7_16B_ID>
#### p.can3.mb4_32b_word2
<link=p.CAN3.MB4_32B_WORD2>
#### CAN3.MB4_32B_WORD2
<link=p.CAN3.MB4_32B_WORD2>
#### CAN3.MB2_64B_WORD8
<link=p.CAN3.MB2_64B_WORD8>
#### CAN3.MB11_8B_WORD1
<link=p.CAN3.MB11_8B_WORD1>
#### p.CAN3.WORD111
<lang=dft>
 (rw)  [1;33m0x401d813c[0m (0x401d8000 + 0x013c)
Message Buffer 11 WORD1 Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.CS12
<link=p.CAN3.CS12>
#### p.can3.mb12_8b_word0
<link=p.CAN3.MB12_8B_WORD0>
#### CAN3.MB12_8B_WORD0
<link=p.CAN3.MB12_8B_WORD0>
#### p.CAN3.MB12_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d814c[0m (0x401d8000 + 0x014c)
Message Buffer 12 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb5_32b_id
<link=p.CAN3.MB5_32B_ID>
#### p.can3.mb5_32b_word0
<link=p.CAN3.MB5_32B_WORD0>
#### CAN3.MB2_64B_WORD15
<link=p.CAN3.MB2_64B_WORD15>
#### p.CAN3.MB14_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8160[0m (0x401d8000 + 0x0160)
Message Buffer 14 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.CAN3.MB5_32B_WORD6
<lang=dft>
 (rw)  [1;33m0x401d8168[0m (0x401d8000 + 0x0168)
Message Buffer 5 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_27[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_26[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_25[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_24[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB9_16B_WORD2
<lang=dft>
 (rw)  [1;33m0x401d8168[0m (0x401d8000 + 0x0168)
Message Buffer 9 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_11[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_10[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_9[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_8[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB3_64B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d816c[0m (0x401d8000 + 0x016c)
Message Buffer 3 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.WORD114
<link=p.CAN3.WORD114>
#### p.can3.mb10_16b_word0
<link=p.CAN3.MB10_16B_WORD0>
#### CAN3.MB10_16B_WORD1
<link=p.CAN3.MB10_16B_WORD1>
#### p.CAN3.MB15_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d817c[0m (0x401d8000 + 0x017c)
Message Buffer 15 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb3_64b_word7
<link=p.CAN3.MB3_64B_WORD7>
#### p.CAN3.MB3_64B_WORD12
<lang=dft>
 (rw)  [1;33m0x401d8190[0m (0x401d8000 + 0x0190)
Message Buffer 3 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_51[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_50[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_49[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_48[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.id17
<link=p.CAN3.ID17>
#### CAN3.MB11_16B_WORD1
<link=p.CAN3.MB11_16B_WORD1>
#### can3.mb11_16b_word2
<link=p.CAN3.MB11_16B_WORD2>
#### p.can3.mb7_32b_word0
<link=p.CAN3.MB7_32B_WORD0>
#### can3.mb4_64b_word0
<link=p.CAN3.MB4_64B_WORD0>
#### p.CAN3.WORD018
<lang=dft>
 (rw)  [1;33m0x401d81a8[0m (0x401d8000 + 0x01a8)
Message Buffer 18 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb4_64b_word1
<link=p.CAN3.MB4_64B_WORD1>
#### CAN3.MB12_16B_WORD2
<link=p.CAN3.MB12_16B_WORD2>
#### p.CAN3.MB7_32B_WORD4
<lang=dft>
 (rw)  [1;33m0x401d81b0[0m (0x401d8000 + 0x01b0)
Message Buffer 7 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_19[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_18[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_17[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_16[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB7_32B_WORD4
<link=p.CAN3.MB7_32B_WORD4>
#### p.can3.mb12_16b_word3
<link=p.CAN3.MB12_16B_WORD3>
#### p.can3.mb13_16b_cs
<link=p.CAN3.MB13_16B_CS>
#### CAN3.MB13_16B_ID
<link=p.CAN3.MB13_16B_ID>
#### p.CAN3.MB19_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d81bc[0m (0x401d8000 + 0x01bc)
Message Buffer 19 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB13_16B_WORD0
<link=p.CAN3.MB13_16B_WORD0>
#### can3.mb13_16b_word1
<link=p.CAN3.MB13_16B_WORD1>
#### CAN3.MB4_64B_WORD8
<link=p.CAN3.MB4_64B_WORD8>
#### CAN3.MB8_32B_WORD1
<link=p.CAN3.MB8_32B_WORD1>
#### p.CAN3.MB8_32B_WORD4
<lang=dft>
 (rw)  [1;33m0x401d81d8[0m (0x401d8000 + 0x01d8)
Message Buffer 8 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_19[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_18[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_17[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_16[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb8_32b_word5
<link=p.CAN3.MB8_32B_WORD5>
#### can3.cs22
<link=p.CAN3.CS22>
#### can3.mb4_64b_word15
<link=p.CAN3.MB4_64B_WORD15>
#### CAN3.CS23
<link=p.CAN3.CS23>
#### can3.id23
<link=p.CAN3.ID23>
#### CAN3.MB23_8B_WORD1
<link=p.CAN3.MB23_8B_WORD1>
#### p.CAN3.MB24_8B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d8208[0m (0x401d8000 + 0x0208)
Message Buffer 24 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb5_64b_word6
<link=p.CAN3.MB5_64B_WORD6>
#### can3.mb9_32b_word6
<link=p.CAN3.MB9_32B_WORD6>
#### p.CAN3.WORD024
<lang=dft>
 (rw)  [1;33m0x401d8208[0m (0x401d8000 + 0x0208)
Message Buffer 24 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb25_8b_cs
<link=p.CAN3.MB25_8B_CS>
#### CAN3.MB5_64B_WORD8
<link=p.CAN3.MB5_64B_WORD8>
#### p.can3.mb10_32b_id
<link=p.CAN3.MB10_32B_ID>
#### p.CAN3.MB25_8B_ID
<lang=dft>
 (rw)  [1;33m0x401d8214[0m (0x401d8000 + 0x0214)
Message Buffer 25 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.can3.mb25_8b_word0
<link=p.CAN3.MB25_8B_WORD0>
#### p.CAN3.MB5_64B_WORD10
<lang=dft>
 (rw)  [1;33m0x401d8218[0m (0x401d8000 + 0x0218)
Message Buffer 5 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_43[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_42[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_41[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_40[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.word025
<link=p.CAN3.WORD025>
#### p.CAN3.MB10_32B_WORD4
<lang=dft>
 (rw)  [1;33m0x401d8228[0m (0x401d8000 + 0x0228)
Message Buffer 10 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_19[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_18[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_17[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_16[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb10_32b_word4
<link=p.CAN3.MB10_32B_WORD4>
#### can3.mb17_16b_word2
<link=p.CAN3.MB17_16B_WORD2>
#### CAN3.MB26_8B_WORD1
<link=p.CAN3.MB26_8B_WORD1>
#### p.can3.word126
<link=p.CAN3.WORD126>
#### p.CAN3.ID27
<lang=dft>
 (rw)  [1;33m0x401d8234[0m (0x401d8000 + 0x0234)
Message Buffer 27 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### CAN3.MB27_8B_ID
<link=p.CAN3.MB27_8B_ID>
#### can3.mb18_16b_word1
<link=p.CAN3.MB18_16B_WORD1>
#### p.CAN3.MB28_8B_ID
<lang=dft>
 (rw)  [1;33m0x401d8244[0m (0x401d8000 + 0x0244)
Message Buffer 28 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.CAN3.MB28_8B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d8248[0m (0x401d8000 + 0x0248)
Message Buffer 28 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB6_64B_WORD4
<lang=dft>
 (rw)  [1;33m0x401d8248[0m (0x401d8000 + 0x0248)
Message Buffer 6 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_19[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_18[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_17[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_16[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.word028
<link=p.CAN3.WORD028>
#### p.CAN3.MB19_16B_ID
<lang=dft>
 (rw)  [1;33m0x401d824c[0m (0x401d8000 + 0x024c)
Message Buffer 19 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.CAN3.WORD128
<lang=dft>
 (rw)  [1;33m0x401d824c[0m (0x401d8000 + 0x024c)
Message Buffer 28 WORD1 Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB11_32B_WORD5
<lang=dft>
 (rw)  [1;33m0x401d8254[0m (0x401d8000 + 0x0254)
Message Buffer 11 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_23[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_22[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_21[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_20[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb11_32b_word6
<link=p.CAN3.MB11_32B_WORD6>
#### p.can3.mb29_8b_word0
<link=p.CAN3.MB29_8B_WORD0>
#### can3.mb6_64b_word8
<link=p.CAN3.MB6_64B_WORD8>
#### can3.word129
<link=p.CAN3.WORD129>
#### CAN3.MB12_32B_CS
<link=p.CAN3.MB12_32B_CS>
#### p.CAN3.ID30
<lang=dft>
 (rw)  [1;33m0x401d8264[0m (0x401d8000 + 0x0264)
Message Buffer 30 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### can3.mb12_32b_id
<link=p.CAN3.MB12_32B_ID>
#### p.can3.mb30_8b_id
<link=p.CAN3.MB30_8B_ID>
#### can3.mb31_8b_cs
<link=p.CAN3.MB31_8B_CS>
#### p.can3.mb6_64b_word15
<link=p.CAN3.MB6_64B_WORD15>
#### p.CAN3.MB12_32B_WORD5
<lang=dft>
 (rw)  [1;33m0x401d827c[0m (0x401d8000 + 0x027c)
Message Buffer 12 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_23[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_22[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_21[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_20[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB7_64B_ID
<lang=dft>
 (rw)  [1;33m0x401d827c[0m (0x401d8000 + 0x027c)
Message Buffer 7 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### can3.mb7_64b_word0
<link=p.CAN3.MB7_64B_WORD0>
#### can3.mb12_32b_word7
<link=p.CAN3.MB12_32B_WORD7>
#### CAN3.MB7_64B_WORD2
<link=p.CAN3.MB7_64B_WORD2>
#### p.can3.mb21_16b_word3
<link=p.CAN3.MB21_16B_WORD3>
#### CAN3.MB21_16B_WORD3
<link=p.CAN3.MB21_16B_WORD3>
#### p.can3.mb32_8b_word1
<link=p.CAN3.MB32_8B_WORD1>
#### p.can3.mb7_64b_word3
<link=p.CAN3.MB7_64B_WORD3>
#### CAN3.WORD132
<link=p.CAN3.WORD132>
#### p.CAN3.MB22_16B_CS
<lang=dft>
 (rw)  [1;33m0x401d8290[0m (0x401d8000 + 0x0290)
Message Buffer 22 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### CAN3.MB22_16B_CS
<link=p.CAN3.MB22_16B_CS>
#### p.CAN3.MB33_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8290[0m (0x401d8000 + 0x0290)
Message Buffer 33 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.CAN3.MB7_64B_WORD6
<lang=dft>
 (rw)  [1;33m0x401d8298[0m (0x401d8000 + 0x0298)
Message Buffer 7 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_27[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_26[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_25[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_24[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB33_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d829c[0m (0x401d8000 + 0x029c)
Message Buffer 33 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb13_32b_word5
<link=p.CAN3.MB13_32B_WORD5>
#### p.can3.word034
<link=p.CAN3.WORD034>
#### can3.mb23_16b_id
<link=p.CAN3.MB23_16B_ID>
#### p.CAN3.CS35
<lang=dft>
 (rw)  [1;33m0x401d82b0[0m (0x401d8000 + 0x02b0)
Message Buffer 35 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### can3.cs35
<link=p.CAN3.CS35>
#### p.can3.mb7_64b_word12
<link=p.CAN3.MB7_64B_WORD12>
#### p.CAN3.MB35_8B_ID
<lang=dft>
 (rw)  [1;33m0x401d82b4[0m (0x401d8000 + 0x02b4)
Message Buffer 35 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.CAN3.MB14_32B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d82b8[0m (0x401d8000 + 0x02b8)
Message Buffer 14 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb14_32b_word0
<link=p.CAN3.MB14_32B_WORD0>
#### p.CAN3.MB23_16B_WORD2
<lang=dft>
 (rw)  [1;33m0x401d82b8[0m (0x401d8000 + 0x02b8)
Message Buffer 23 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_11[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_10[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_9[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_8[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb23_16b_word3
<link=p.CAN3.MB23_16B_WORD3>
#### can3.mb7_64b_word15
<link=p.CAN3.MB7_64B_WORD15>
#### p.can3.word135
<link=p.CAN3.WORD135>
#### p.can3.mb36_8b_cs
<link=p.CAN3.MB36_8B_CS>
#### p.can3.id36
<link=p.CAN3.ID36>
#### p.can3.mb8_64b_id
<link=p.CAN3.MB8_64B_ID>
#### can3.mb8_64b_id
<link=p.CAN3.MB8_64B_ID>
#### CAN3.MB37_8B_CS
<link=p.CAN3.MB37_8B_CS>
#### can3.mb8_64b_word2
<link=p.CAN3.MB8_64B_WORD2>
#### can3.mb24_16b_word3
<link=p.CAN3.MB24_16B_WORD3>
#### CAN3.MB37_8B_ID
<link=p.CAN3.MB37_8B_ID>
#### p.can3.mb8_64b_word3
<link=p.CAN3.MB8_64B_WORD3>
#### can3.mb37_8b_word0
<link=p.CAN3.MB37_8B_WORD0>
#### p.CAN3.WORD037
<lang=dft>
 (rw)  [1;33m0x401d82d8[0m (0x401d8000 + 0x02d8)
Message Buffer 37 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb37_8b_word1
<link=p.CAN3.MB37_8B_WORD1>
#### p.CAN3.MB8_64B_WORD5
<lang=dft>
 (rw)  [1;33m0x401d82dc[0m (0x401d8000 + 0x02dc)
Message Buffer 8 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_23[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_22[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_21[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_20[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.id38
<link=p.CAN3.ID38>
#### p.CAN3.MB15_32B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d82e4[0m (0x401d8000 + 0x02e4)
Message Buffer 15 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb15_32b_word2
<link=p.CAN3.MB15_32B_WORD2>
#### can3.mb25_16b_word2
<link=p.CAN3.MB25_16B_WORD2>
#### CAN3.WORD038
<link=p.CAN3.WORD038>
#### p.CAN3.MB25_16B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d82ec[0m (0x401d8000 + 0x02ec)
Message Buffer 25 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.ID39
<link=p.CAN3.ID39>
#### can3.mb26_16b_word1
<link=p.CAN3.MB26_16B_WORD1>
#### can3.mb8_64b_word13
<link=p.CAN3.MB8_64B_WORD13>
#### p.CAN3.MB8_64B_WORD14
<lang=dft>
 (rw)  [1;33m0x401d8300[0m (0x401d8000 + 0x0300)
Message Buffer 8 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_59[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_58[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_57[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_56[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB40_8B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d8308[0m (0x401d8000 + 0x0308)
Message Buffer 40 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB16_32B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d830c[0m (0x401d8000 + 0x030c)
Message Buffer 16 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb9_64b_id
<link=p.CAN3.MB9_64B_ID>
#### can3.mb9_64b_id
<link=p.CAN3.MB9_64B_ID>
#### can3.id41
<link=p.CAN3.ID41>
#### can3.mb16_32b_word3
<link=p.CAN3.MB16_32B_WORD3>
#### CAN3.WORD041
<link=p.CAN3.WORD041>
#### p.can3.mb41_8b_word1
<link=p.CAN3.MB41_8B_WORD1>
#### can3.mb9_64b_word4
<link=p.CAN3.MB9_64B_WORD4>
#### p.CAN3.MB28_16B_ID
<lang=dft>
 (rw)  [1;33m0x401d8324[0m (0x401d8000 + 0x0324)
Message Buffer 28 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.can3.word042
<link=p.CAN3.WORD042>
#### p.CAN3.MB9_64B_WORD7
<lang=dft>
 (rw)  [1;33m0x401d832c[0m (0x401d8000 + 0x032c)
Message Buffer 9 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_31[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_30[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_29[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_28[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.WORD142
<lang=dft>
 (rw)  [1;33m0x401d832c[0m (0x401d8000 + 0x032c)
Message Buffer 42 WORD1 Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB28_16B_WORD2
<lang=dft>
 (rw)  [1;33m0x401d8330[0m (0x401d8000 + 0x0330)
Message Buffer 28 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_11[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_10[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_9[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_8[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb17_32b_word1
<link=p.CAN3.MB17_32B_WORD1>
#### p.can3.mb9_64b_word9
<link=p.CAN3.MB9_64B_WORD9>
#### CAN3.MB9_64B_WORD9
<link=p.CAN3.MB9_64B_WORD9>
#### can3.word143
<link=p.CAN3.WORD143>
#### p.CAN3.MB44_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8340[0m (0x401d8000 + 0x0340)
Message Buffer 44 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### can3.mb44_8b_id
<link=p.CAN3.MB44_8B_ID>
#### CAN3.MB44_8B_ID
<link=p.CAN3.MB44_8B_ID>
#### CAN3.WORD144
<link=p.CAN3.WORD144>
#### p.CAN3.MB45_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8350[0m (0x401d8000 + 0x0350)
Message Buffer 45 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### CAN3.MB30_16B_ID
<link=p.CAN3.MB30_16B_ID>
#### p.can3.mb45_8b_id
<link=p.CAN3.MB45_8B_ID>
#### CAN3.MB45_8B_ID
<link=p.CAN3.MB45_8B_ID>
#### p.can3.mb46_8b_cs
<link=p.CAN3.MB46_8B_CS>
#### p.CAN3.MB31_16B_CS
<lang=dft>
 (rw)  [1;33m0x401d8368[0m (0x401d8000 + 0x0368)
Message Buffer 31 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### can3.word046
<link=p.CAN3.WORD046>
#### p.can3.mb10_64b_word5
<link=p.CAN3.MB10_64B_WORD5>
#### can3.mb10_64b_word5
<link=p.CAN3.MB10_64B_WORD5>
#### p.can3.mb18_32b_word6
<link=p.CAN3.MB18_32B_WORD6>
#### can3.mb47_8b_cs
<link=p.CAN3.MB47_8B_CS>
#### p.can3.id47
<link=p.CAN3.ID47>
#### CAN3.MB18_32B_WORD7
<link=p.CAN3.MB18_32B_WORD7>
#### p.CAN3.WORD047
<lang=dft>
 (rw)  [1;33m0x401d8378[0m (0x401d8000 + 0x0378)
Message Buffer 47 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.word147
<link=p.CAN3.WORD147>
#### CAN3.ID48
<link=p.CAN3.ID48>
#### p.CAN3.MB32_16B_ID
<lang=dft>
 (rw)  [1;33m0x401d8384[0m (0x401d8000 + 0x0384)
Message Buffer 32 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### can3.mb32_16b_id
<link=p.CAN3.MB32_16B_ID>
#### p.can3.mb48_8b_word1
<link=p.CAN3.MB48_8B_WORD1>
#### can3.mb48_8b_word1
<link=p.CAN3.MB48_8B_WORD1>
#### can3.cs49
<link=p.CAN3.CS49>
#### can3.mb19_32b_word4
<link=p.CAN3.MB19_32B_WORD4>
#### CAN3.MB19_32B_WORD4
<link=p.CAN3.MB19_32B_WORD4>
#### can3.mb10_64b_word15
<link=p.CAN3.MB10_64B_WORD15>
#### can3.word150
<link=p.CAN3.WORD150>
#### p.can3.cs51
<link=p.CAN3.CS51>
#### p.can3.mb20_32b_word2
<link=p.CAN3.MB20_32B_WORD2>
#### p.CAN3.MB11_64B_WORD5
<lang=dft>
 (rw)  [1;33m0x401d83b4[0m (0x401d8000 + 0x03b4)
Message Buffer 11 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_23[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_22[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_21[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_20[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB11_64B_WORD5
<link=p.CAN3.MB11_64B_WORD5>
#### p.can3.mb34_16b_word0
<link=p.CAN3.MB34_16B_WORD0>
#### can3.word051
<link=p.CAN3.WORD051>
#### can3.mb11_64b_word7
<link=p.CAN3.MB11_64B_WORD7>
#### CAN3.MB34_16B_WORD1
<link=p.CAN3.MB34_16B_WORD1>
#### can3.mb52_8b_cs
<link=p.CAN3.MB52_8B_CS>
#### p.CAN3.ID52
<lang=dft>
 (rw)  [1;33m0x401d83c4[0m (0x401d8000 + 0x03c4)
Message Buffer 52 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.CAN3.MB20_32B_WORD7
<lang=dft>
 (rw)  [1;33m0x401d83c4[0m (0x401d8000 + 0x03c4)
Message Buffer 20 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_31[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_30[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_29[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_28[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB52_8B_ID
<link=p.CAN3.MB52_8B_ID>
#### CAN3.WORD052
<link=p.CAN3.WORD052>
#### p.CAN3.MB11_64B_WORD12
<lang=dft>
 (rw)  [1;33m0x401d83d0[0m (0x401d8000 + 0x03d0)
Message Buffer 11 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_51[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_50[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_49[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_48[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB35_16B_WORD1
<link=p.CAN3.MB35_16B_WORD1>
#### CAN3.MB21_32B_WORD3
<link=p.CAN3.MB21_32B_WORD3>
#### CAN3.MB53_8B_WORD1
<link=p.CAN3.MB53_8B_WORD1>
#### CAN3.MB36_16B_WORD0
<link=p.CAN3.MB36_16B_WORD0>
#### p.CAN3.WORD054
<lang=dft>
 (rw)  [1;33m0x401d83e8[0m (0x401d8000 + 0x03e8)
Message Buffer 54 WORD0 Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb36_16b_word1
<link=p.CAN3.MB36_16B_WORD1>
#### can3.cs56
<link=p.CAN3.CS56>
#### p.CAN3.MB12_64B_WORD6
<lang=dft>
 (rw)  [1;33m0x401d8400[0m (0x401d8000 + 0x0400)
Message Buffer 12 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_27[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_26[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_25[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_24[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB12_64B_WORD7
<link=p.CAN3.MB12_64B_WORD7>
#### p.CAN3.MB22_32B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d8404[0m (0x401d8000 + 0x0404)
Message Buffer 22 WORD_32B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb56_8b_id
<link=p.CAN3.MB56_8B_ID>
#### CAN3.MB37_16B_WORD2
<link=p.CAN3.MB37_16B_WORD2>
#### can3.mb37_16b_word3
<link=p.CAN3.MB37_16B_WORD3>
#### CAN3.MB22_32B_WORD7
<link=p.CAN3.MB22_32B_WORD7>
#### p.can3.mb57_8b_word0
<link=p.CAN3.MB57_8B_WORD0>
#### can3.mb57_8b_word0
<link=p.CAN3.MB57_8B_WORD0>
#### p.CAN3.MB12_64B_WORD13
<lang=dft>
 (rw)  [1;33m0x401d841c[0m (0x401d8000 + 0x041c)
Message Buffer 12 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_55[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_54[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_53[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_52[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### CAN3.MB12_64B_WORD13
<link=p.CAN3.MB12_64B_WORD13>
#### p.CAN3.MB23_32B_ID
<lang=dft>
 (rw)  [1;33m0x401d841c[0m (0x401d8000 + 0x041c)
Message Buffer 23 ID Register
 (rw) (18)  [0;32mEXT[0m  - [17:00] -  Contains extended (LOW word) identifier of message buffer.
 (rw) (11)  [0;32mSTD[0m  - [28:18] -  Contains standard/extended (HIGH word) identifier of message buffer.
 (rw) (03)  [0;32mPRIO[0m  - [31:29] -  Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR an
 d it only makes sense for Tx buffers. These bits are not transmitted. They are 
 appended to the regular ID to define the transmission priority.
</lang>
#### p.CAN3.CS58
<lang=dft>
 (rw)  [1;33m0x401d8420[0m (0x401d8000 + 0x0420)
Message Buffer 58 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.CAN3.MB58_8B_WORD0
<lang=dft>
 (rw)  [1;33m0x401d8428[0m (0x401d8000 + 0x0428)
Message Buffer 58 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_3[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_2[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_1[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_0[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.can3.mb58_8b_word0
<link=p.CAN3.MB58_8B_WORD0>
#### p.can3.mb13_64b_id
<link=p.CAN3.MB13_64B_ID>
#### CAN3.MB58_8B_WORD1
<link=p.CAN3.MB58_8B_WORD1>
#### p.can3.word158
<link=p.CAN3.WORD158>
#### p.can3.word059
<link=p.CAN3.WORD059>
#### p.can3.cs60
<link=p.CAN3.CS60>
#### p.CAN3.MB60_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8440[0m (0x401d8000 + 0x0440)
Message Buffer 60 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### can3.mb60_8b_id
<link=p.CAN3.MB60_8B_ID>
#### CAN3.MB60_8B_ID
<link=p.CAN3.MB60_8B_ID>
#### p.can3.mb60_8b_word0
<link=p.CAN3.MB60_8B_WORD0>
#### p.CAN3.MB61_8B_CS
<lang=dft>
 (rw)  [1;33m0x401d8450[0m (0x401d8000 + 0x0450)
Message Buffer 61 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### p.can3.id61
<link=p.CAN3.ID61>
#### CAN3.MB13_64B_WORD11
<link=p.CAN3.MB13_64B_WORD11>
#### CAN3.MB61_8B_WORD1
<link=p.CAN3.MB61_8B_WORD1>
#### p.CAN3.CS62
<lang=dft>
 (rw)  [1;33m0x401d8460[0m (0x401d8000 + 0x0460)
Message Buffer 62 CS Register
 (rw) (16)  [0;32mTIME_STAMP[0m  - [15:00] -  Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Runnin
 g Timer, captured for Tx and Rx frames at the time when the beginning of the Id
 entifier field appears on the CAN bus.
 (rw) (04)  [0;32mDLC[0m  - [19:16] -  Length of the data to be stored/transmitted.
 (rw) (01)  [0;32mRTR[0m  - [20:20] -  Remote Transmission Request. One/zero for remote/data frame.
 (rw) (01)  [0;32mIDE[0m  - [21:21] -  ID Extended. One/zero for extended/standard format frame.
 (rw) (01)  [0;32mSRR[0m  - [22:22] -  Substitute Remote Request. Contains a fixed recessive bit.
 (rw) (04)  [0;32mCODE[0m  - [27:24] -  Message Buffer Code. This 4-bit field can be accessed (read or write) by the CP
 U and by the FlexCAN module itself, as part of the message buffer matching and 
 arbitration process.
 (rw) (01)  [0;32mESI[0m  - [29:29] -  Error State Indicator. This bit indicates if the transmitting node is error act
 ive or error passive.
 (rw) (01)  [0;32mBRS[0m  - [30:30] -  Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN
  FD format frame.
 (rw) (01)  [0;32mEDL[0m  - [31:31] -  Extended Data Length. This bit distinguishes between CAN format and CAN FD form
 at frames. The EDL bit must not be set for Message Buffers configured to RANSWE
 R with code field 0b1010.
</lang>
#### can3.mb13_64b_word12
<link=p.CAN3.MB13_64B_WORD12>
#### p.can3.mb41_16b_word0
<link=p.CAN3.MB41_16B_WORD0>
#### CAN3.MB41_16B_WORD1
<link=p.CAN3.MB41_16B_WORD1>
#### p.can3.mb62_8b_id
<link=p.CAN3.MB62_8B_ID>
#### p.can3.mb13_64b_word14
<link=p.CAN3.MB13_64B_WORD14>
#### p.CAN3.MB13_64B_WORD15
<lang=dft>
 (rw)  [1;33m0x401d846c[0m (0x401d8000 + 0x046c)
Message Buffer 13 WORD_64B Register
 (rw) (08)  [0;32mDATA_BYTE_63[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_62[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_61[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_60[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.MB41_16B_WORD3
<lang=dft>
 (rw)  [1;33m0x401d846c[0m (0x401d8000 + 0x046c)
Message Buffer 41 WORD_16B Register
 (rw) (08)  [0;32mDATA_BYTE_15[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_14[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_13[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_12[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### can3.mb62_8b_word1
<link=p.CAN3.MB62_8B_WORD1>
#### p.CAN3.MB63_8B_WORD1
<lang=dft>
 (rw)  [1;33m0x401d847c[0m (0x401d8000 + 0x047c)
Message Buffer 63 WORD_8B Register
 (rw) (08)  [0;32mDATA_BYTE_7[0m  - [07:00] -  Data byte 0 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_6[0m  - [15:08] -  Data byte 1 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_5[0m  - [23:16] -  Data byte 2 of Rx/Tx frame.
 (rw) (08)  [0;32mDATA_BYTE_4[0m  - [31:24] -  Data byte 3 of Rx/Tx frame.
</lang>
#### p.CAN3.RXIMR[2]
<lang=dft>
 (rw)  [1;33m0x401d8888[0m (0x401d8000 + 0x0888)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### p.can3.rximr[6]
<link=p.CAN3.RXIMR[6]>
#### p.can3.rximr[16]
<link=p.CAN3.RXIMR[16]>
#### can3.rximr[17]
<link=p.CAN3.RXIMR[17]>
#### p.CAN3.RXIMR[20]
<lang=dft>
 (rw)  [1;33m0x401d88d0[0m (0x401d8000 + 0x08d0)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### CAN3.RXIMR[25]
<link=p.CAN3.RXIMR[25]>
#### can3.rximr[26]
<link=p.CAN3.RXIMR[26]>
#### p.can3.rximr[30]
<link=p.CAN3.RXIMR[30]>
#### can3.rximr[32]
<link=p.CAN3.RXIMR[32]>
#### p.CAN3.RXIMR[34]
<lang=dft>
 (rw)  [1;33m0x401d8908[0m (0x401d8000 + 0x0908)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### p.CAN3.RXIMR[39]
<lang=dft>
 (rw)  [1;33m0x401d891c[0m (0x401d8000 + 0x091c)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### p.can3.rximr[41]
<link=p.CAN3.RXIMR[41]>
#### can3.rximr[43]
<link=p.CAN3.RXIMR[43]>
#### CAN3.RXIMR[48]
<link=p.CAN3.RXIMR[48]>
#### can3.rximr[49]
<link=p.CAN3.RXIMR[49]>
#### p.CAN3.RXIMR[55]
<lang=dft>
 (rw)  [1;33m0x401d895c[0m (0x401d8000 + 0x095c)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### p.CAN3.RXIMR[63]
<lang=dft>
 (rw)  [1;33m0x401d897c[0m (0x401d8000 + 0x097c)
Rx Individual Mask Registers
 (rw) (32)  [0;32mMI[0m  - [31:00] -  Individual Mask Bits
</lang>
#### p.CAN3.EPRS
<lang=dft>
 (rw)  [1;33m0x401d8bf0[0m (0x401d8000 + 0x0bf0)
Enhanced CAN Bit Timing Prescalers
 (rw) (10)  [0;32mENPRESDIV[0m  - [09:00] -  Extended Nominal Prescaler Division Factor
 (rw) (10)  [0;32mEDPRESDIV[0m  - [25:16] -  Extended Data Phase Prescaler Division Factor
</lang>
#### can3.edcbt
<link=p.CAN3.EDCBT>
#### can3.hr_time_stamp[3]
<link=p.CAN3.HR_TIME_STAMP[3]>
#### p.can3.hr_time_stamp[5]
<link=p.CAN3.HR_TIME_STAMP[5]>
#### CAN3.HR_TIME_STAMP[13]
<link=p.CAN3.HR_TIME_STAMP[13]>
#### CAN3.HR_TIME_STAMP[16]
<link=p.CAN3.HR_TIME_STAMP[16]>
#### p.can3.hr_time_stamp[22]
<link=p.CAN3.HR_TIME_STAMP[22]>
#### p.can3.hr_time_stamp[31]
<link=p.CAN3.HR_TIME_STAMP[31]>
#### p.can3.hr_time_stamp[36]
<link=p.CAN3.HR_TIME_STAMP[36]>
#### p.CAN3.HR_TIME_STAMP[43]
<lang=dft>
 (ro)  [1;33m0x401d8cdc[0m (0x401d8000 + 0x0cdc)
High Resolution Time Stamp
 (ro) (32)  [0;32mTS[0m  - [31:00] -  High Resolution Time Stamp
</lang>
#### CAN3.HR_TIME_STAMP[63]
<link=p.CAN3.HR_TIME_STAMP[63]>
#### CAN3.ERFFEL[0]
<link=p.CAN3.ERFFEL[0]>
#### CAN3.ERFFEL[10]
<link=p.CAN3.ERFFEL[10]>
#### p.can3.erffel[11]
<link=p.CAN3.ERFFEL[11]>
#### p.can3.erffel[16]
<link=p.CAN3.ERFFEL[16]>
#### CAN3.ERFFEL[21]
<link=p.CAN3.ERFFEL[21]>
#### p.CAN3.ERFFEL[32]
<lang=dft>
 (rw)  [1;33m0x401db080[0m (0x401d8000 + 0x3080)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### p.CAN3.ERFFEL[38]
<lang=dft>
 (rw)  [1;33m0x401db098[0m (0x401d8000 + 0x3098)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### CAN3.ERFFEL[43]
<link=p.CAN3.ERFFEL[43]>
#### p.can3.erffel[48]
<link=p.CAN3.ERFFEL[48]>
#### can3.erffel[49]
<link=p.CAN3.ERFFEL[49]>
#### CAN3.ERFFEL[53]
<link=p.CAN3.ERFFEL[53]>
#### p.CAN3.ERFFEL[60]
<lang=dft>
 (rw)  [1;33m0x401db0f0[0m (0x401d8000 + 0x30f0)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### can3.erffel[62]
<link=p.CAN3.ERFFEL[62]>
#### p.CAN3.ERFFEL[65]
<lang=dft>
 (rw)  [1;33m0x401db104[0m (0x401d8000 + 0x3104)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### can3.erffel[71]
<link=p.CAN3.ERFFEL[71]>
#### can3.erffel[76]
<link=p.CAN3.ERFFEL[76]>
#### can3.erffel[80]
<link=p.CAN3.ERFFEL[80]>
#### p.can3.erffel[81]
<link=p.CAN3.ERFFEL[81]>
#### p.CAN3.ERFFEL[82]
<lang=dft>
 (rw)  [1;33m0x401db148[0m (0x401d8000 + 0x3148)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### CAN3.ERFFEL[84]
<link=p.CAN3.ERFFEL[84]>
#### p.CAN3.ERFFEL[91]
<lang=dft>
 (rw)  [1;33m0x401db16c[0m (0x401d8000 + 0x316c)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### can3.erffel[93]
<link=p.CAN3.ERFFEL[93]>
#### can3.erffel[96]
<link=p.CAN3.ERFFEL[96]>
#### can3.erffel[103]
<link=p.CAN3.ERFFEL[103]>
#### p.can3.erffel[106]
<link=p.CAN3.ERFFEL[106]>
#### can3.erffel[113]
<link=p.CAN3.ERFFEL[113]>
#### p.CAN3.ERFFEL[118]
<lang=dft>
 (rw)  [1;33m0x401db1d8[0m (0x401d8000 + 0x31d8)
Enhanced Rx FIFO Filter Element
 (rw) (32)  [0;32mFEL[0m  - [31:00] -  Filter Element Bits
</lang>
#### can3.erffel[125]
<link=p.CAN3.ERFFEL[125]>
#### tmr1.hold2
<link=p.TMR1.HOLD2>
#### p.tmr1.hold3
<link=p.TMR1.HOLD3>
#### p.tmr1.cntr0
<link=p.TMR1.CNTR0>
#### p.TMR1.CTRL0
<lang=dft>
 (rw)  [1;33m0x401dc00c[0m (0x401dc000 + 0x000c)
Timer Channel Control Register
 (rw) (03)  [0;32mOUTMODE[0m  - [02:00] -  Output Mode
      0 - OUTMODE_0 :
         Asserted while counter is active
      0x1 - OUTMODE_1 :
         Clear OFLAG output on successful compare
      0x2 - OUTMODE_2 :
         Set OFLAG output on successful compare
      0x3 - OUTMODE_3 :
         Toggle OFLAG output on successful compare
      0x4 - OUTMODE_4 :
         Toggle OFLAG output using alternating compare registers
      0x5 - OUTMODE_5 :
         Set on compare, cleared on secondary source input edge
      0x6 - OUTMODE_6 :
         Set on compare, cleared on counter rollover
      0x7 - OUTMODE_7 :
         Enable gated clock output while counter is active
 (rw) (01)  [0;32mCOINIT[0m  - [03:03] -  Co-Channel Initialization
      0 - COINIT_0 :
         Co-channel counter/timers cannot force a re-initialization of this coun
         ter/timer
      0x1 - COINIT_1 :
         Co-channel counter/timers may force a re-initialization of this counter
         /timer
 (rw) (01)  [0;32mDIR[0m  - [04:04] -  Count Direction
      0 - DIR_0 :
         Count up.
      0x1 - DIR_1 :
         Count down.
 (rw) (01)  [0;32mLENGTH[0m  - [05:05] -  Count Length
      0 - LENGTH_0 :
         Count until roll over at $FFFF and continue from $0000.
      0x1 - LENGTH_1 :
         Count until compare, then re-initialize. If counting up, a successful c
         ompare occurs when the counter reaches a COMP1 value. If counting down,
          a successful compare occurs when the counter reaches a COMP2 value. Wh
         en output mode $4 is used, alternating values of COMP1 and COMP2 are us
         ed to generate successful comparisons. For example, the counter counts 
         until a COMP1 value is reached, re-initializes, counts until COMP2 valu
         e is reached, re-initializes, counts until COMP1 value is reached, and 
         so on.
 (rw) (01)  [0;32mONCE[0m  - [06:06] -  Count Once
      0 - ONCE_0 :
         Count repeatedly.
      0x1 - ONCE_1 :
         Count until compare and then stop. If counting up, a successful compare
          occurs when the counter reaches a COMP1 value. If counting down, a suc
         cessful compare occurs when the counter reaches a COMP2 value. When out
         put mode $4 is used, the counter re-initializes after reaching the COMP
         1 value, continues to count to the COMP2 value, and then stops.
 (rw) (02)  [0;32mSCS[0m  - [08:07] -  Secondary Count Source
      0 - SCS_0 :
         Counter 0 input pin
      0x1 - SCS_1 :
         Counter 1 input pin
      0x2 - SCS_2 :
         Counter 2 input pin
      0x3 - SCS_3 :
         Counter 3 input pin
 (rw) (04)  [0;32mPCS[0m  - [12:09] -  Primary Count Source
      0 - PCS_0 :
         Counter 0 input pin
      0x1 - PCS_1 :
         Counter 1 input pin
      0x2 - PCS_2 :
         Counter 2 input pin
      0x3 - PCS_3 :
         Counter 3 input pin
      0x4 - PCS_4 :
         Counter 0 output
      0x5 - PCS_5 :
         Counter 1 output
      0x6 - PCS_6 :
         Counter 2 output
      0x7 - PCS_7 :
         Counter 3 output
      0x8 - PCS_8 :
         IP bus clock divide by 1 prescaler
      0x9 - PCS_9 :
         IP bus clock divide by 2 prescaler
      0xA - PCS_10 :
         IP bus clock divide by 4 prescaler
      0xB - PCS_11 :
         IP bus clock divide by 8 prescaler
      0xC - PCS_12 :
         IP bus clock divide by 16 prescaler
      0xD - PCS_13 :
         IP bus clock divide by 32 prescaler
      0xE - PCS_14 :
         IP bus clock divide by 64 prescaler
      0xF - PCS_15 :
         IP bus clock divide by 128 prescaler
 (rw) (03)  [0;32mCM[0m  - [15:13] -  Count Mode
      0 - CM_0 :
         No operation
      0x1 - CM_1 :
         Count rising edges of primary sourceRising edges are counted only when 
         SCTRL[IPS] = 0. Falling edges are counted when SCTRL[IPS] = 1. If the p
         rimary count source is IP bus clock divide by 1, only rising edges are 
         counted regardless of the value of SCTRL[IPS].
      0x2 - CM_2 :
         Count rising and falling edges of primary sourceIP bus clock divide by 
         1 cannot be used as a primary count source in edge count mode.
      0x3 - CM_3 :
         Count rising edges of primary source while secondary input high active
      0x4 - CM_4 :
         Quadrature count mode, uses primary and secondary sources
      0x5 - CM_5 :
         Count rising edges of primary source; secondary source specifies direct
         ionRising edges are counted only when SCTRL[IPS] = 0. Falling edges are
          counted when SCTRL[IPS] = 1.
      0x6 - CM_6 :
         Edge of secondary source triggers primary count until compare
      0x7 - CM_7 :
         Cascaded counter mode (up/down)The primary count source must be set to 
         one of the counter outputs.
</lang>
#### p.tmr1.cmpld13
<link=p.TMR1.CMPLD13>
#### tmr1.csctrl0
<link=p.TMR1.CSCTRL0>
#### p.tmr1.csctrl3
<link=p.TMR1.CSCTRL3>
#### p.TMR1.DMA0
<lang=dft>
 (rw)  [1;33m0x401dc018[0m (0x401dc000 + 0x0018)
Timer Channel DMA Enable Register
 (rw) (01)  [0;32mIEFDE[0m  - [00:00] -  Input Edge Flag DMA Enable
 (rw) (01)  [0;32mCMPLD1DE[0m  - [01:01] -  Comparator Preload Register 1 DMA Enable
 (rw) (01)  [0;32mCMPLD2DE[0m  - [02:02] -  Comparator Preload Register 2 DMA Enable
</lang>
#### TMR1.DMA0
<link=p.TMR1.DMA0>
#### p.tmr1.enbl
<link=p.TMR1.ENBL>
#### tmr1.enbl
<link=p.TMR1.ENBL>
#### TMR2.COMP22
<link=p.TMR2.COMP22>
#### p.tmr2.hold1
<link=p.TMR2.HOLD1>
#### tmr2.hold1
<link=p.TMR2.HOLD1>
#### tmr2.cntr2
<link=p.TMR2.CNTR2>
#### p.tmr2.ctrl1
<link=p.TMR2.CTRL1>
#### tmr2.sctrl2
<link=p.TMR2.SCTRL2>
#### p.TMR2.SCTRL3
<lang=dft>
 (rw)  [1;33m0x401e006e[0m (0x401e0000 + 0x006e)
Timer Channel Status and Control Register
 (rw) (01)  [0;32mOEN[0m  - [00:00] -  Output Enable
      0 - OEN_0 :
         The external pin is configured as an input.
      0x1 - OEN_1 :
         The OFLAG output signal is driven on the external pin. Other timer grou
         ps using this external pin as their input see the driven value. The pol
         arity of the signal is determined by OPS.
 (rw) (01)  [0;32mOPS[0m  - [01:01] -  Output Polarity Select
      0 - OPS_0 :
         True polarity.
      0x1 - OPS_1 :
         Inverted polarity.
 (rw) (01)  [0;32mFORCE[0m  - [02:02] -  Force OFLAG Output
 (rw) (01)  [0;32mVAL[0m  - [03:03] -  Forced OFLAG Value
 (rw) (01)  [0;32mEEOF[0m  - [04:04] -  Enable External OFLAG Force
 (rw) (01)  [0;32mMSTR[0m  - [05:05] -  Master Mode
 (rw) (02)  [0;32mCAPTURE_MODE[0m  - [07:06] -  Input Capture Mode
      0 - CAPTURE_MODE_0 :
         Capture function is disabled
      0x1 - CAPTURE_MODE_1 :
         Load capture register on rising edge (when IPS=0) or falling edge (when
          IPS=1) of input
      0x2 - CAPTURE_MODE_2 :
         Load capture register on falling edge (when IPS=0) or rising edge (when
          IPS=1) of input
      0x3 - CAPTURE_MODE_3 :
         Load capture register on both edges of input
 (ro) (01)  [0;32mINPUT[0m  - [08:08] -  External Input Signal
 (rw) (01)  [0;32mIPS[0m  - [09:09] -  Input Polarity Select
 (rw) (01)  [0;32mIEFIE[0m  - [10:10] -  Input Edge Flag Interrupt Enable
 (rw) (01)  [0;32mIEF[0m  - [11:11] -  Input Edge Flag
 (rw) (01)  [0;32mTOFIE[0m  - [12:12] -  Timer Overflow Flag Interrupt Enable
 (rw) (01)  [0;32mTOF[0m  - [13:13] -  Timer Overflow Flag
 (rw) (01)  [0;32mTCFIE[0m  - [14:14] -  Timer Compare Flag Interrupt Enable
 (rw) (01)  [0;32mTCF[0m  - [15:15] -  Timer Compare Flag
</lang>
#### p.tmr2.cmpld10
<link=p.TMR2.CMPLD10>
#### tmr2.cmpld20
<link=p.TMR2.CMPLD20>
#### p.tmr2.cmpld21
<link=p.TMR2.CMPLD21>
#### p.tmr2.csctrl1
<link=p.TMR2.CSCTRL1>
#### p.TMR2.FILT3
<lang=dft>
 (rw)  [1;33m0x401e0076[0m (0x401e0000 + 0x0076)
Timer Channel Input Filter Register
 (rw) (08)  [0;32mFILT_PER[0m  - [07:00] -  Input Filter Sample Period
 (rw) (03)  [0;32mFILT_CNT[0m  - [10:08] -  Input Filter Sample Count
</lang>
#### tmr2.dma0
<link=p.TMR2.DMA0>
#### p.TMR2.DMA1
<lang=dft>
 (rw)  [1;33m0x401e0038[0m (0x401e0000 + 0x0038)
Timer Channel DMA Enable Register
 (rw) (01)  [0;32mIEFDE[0m  - [00:00] -  Input Edge Flag DMA Enable
 (rw) (01)  [0;32mCMPLD1DE[0m  - [01:01] -  Comparator Preload Register 1 DMA Enable
 (rw) (01)  [0;32mCMPLD2DE[0m  - [02:02] -  Comparator Preload Register 2 DMA Enable
</lang>
#### p.TMR3
<lang=dft>
base: 0x401e4000
CAPT0           CAPT1           CAPT2           CAPT3           
CMPLD10         CMPLD11         CMPLD12         CMPLD13         
CMPLD20         CMPLD21         CMPLD22         CMPLD23         
CNTR0           CNTR1           CNTR2           CNTR3           
COMP10          COMP11          COMP12          COMP13          
COMP20          COMP21          COMP22          COMP23          
CSCTRL0         CSCTRL1         CSCTRL2         CSCTRL3         
CTRL0           CTRL1           CTRL2           CTRL3           
DMA0            DMA1            DMA2            DMA3            
ENBL            FILT0           FILT1           FILT2           
FILT3           HOLD0           HOLD1           HOLD2           
HOLD3           LOAD0           LOAD1           LOAD2           
LOAD3           SCTRL0          SCTRL1          SCTRL2          
SCTRL3          
输入 p.TMR3.{reg_name} 以查看寄存器的详细信息
type p.TMR3.{reg_name} to check details of registers
</lang>
#### p.TMR3.COMP13
<lang=dft>
 (rw)  [1;33m0x401e4060[0m (0x401e4000 + 0x0060)
Timer Channel Compare Register 1
 (rw) (16)  [0;32mCOMPARISON_1[0m  - [15:00] -  Comparison Value 1
</lang>
#### p.tmr3.comp20
<link=p.TMR3.COMP20>
#### p.TMR3.CAPT3
<lang=dft>
 (rw)  [1;33m0x401e4064[0m (0x401e4000 + 0x0064)
Timer Channel Capture Register
 (rw) (16)  [0;32mCAPTURE[0m  - [15:00] -  Capture Value
</lang>
#### p.tmr3.hold0
<link=p.TMR3.HOLD0>
#### p.tmr3.sctrl1
<link=p.TMR3.SCTRL1>
#### TMR3.CSCTRL2
<link=p.TMR3.CSCTRL2>
#### p.TMR3.FILT2
<lang=dft>
 (rw)  [1;33m0x401e4056[0m (0x401e4000 + 0x0056)
Timer Channel Input Filter Register
 (rw) (08)  [0;32mFILT_PER[0m  - [07:00] -  Input Filter Sample Period
 (rw) (03)  [0;32mFILT_CNT[0m  - [10:08] -  Input Filter Sample Count
</lang>
#### p.tmr4.comp21
<link=p.TMR4.COMP21>
#### tmr4.comp21
<link=p.TMR4.COMP21>
#### TMR4.CAPT0
<link=p.TMR4.CAPT0>
#### tmr4.capt3
<link=p.TMR4.CAPT3>
#### p.tmr4.load3
<link=p.TMR4.LOAD3>
#### TMR4.CNTR0
<link=p.TMR4.CNTR0>
#### tmr4.ctrl2
<link=p.TMR4.CTRL2>
#### p.TMR4.SCTRL0
<lang=dft>
 (rw)  [1;33m0x401e800e[0m (0x401e8000 + 0x000e)
Timer Channel Status and Control Register
 (rw) (01)  [0;32mOEN[0m  - [00:00] -  Output Enable
      0 - OEN_0 :
         The external pin is configured as an input.
      0x1 - OEN_1 :
         The OFLAG output signal is driven on the external pin. Other timer grou
         ps using this external pin as their input see the driven value. The pol
         arity of the signal is determined by OPS.
 (rw) (01)  [0;32mOPS[0m  - [01:01] -  Output Polarity Select
      0 - OPS_0 :
         True polarity.
      0x1 - OPS_1 :
         Inverted polarity.
 (rw) (01)  [0;32mFORCE[0m  - [02:02] -  Force OFLAG Output
 (rw) (01)  [0;32mVAL[0m  - [03:03] -  Forced OFLAG Value
 (rw) (01)  [0;32mEEOF[0m  - [04:04] -  Enable External OFLAG Force
 (rw) (01)  [0;32mMSTR[0m  - [05:05] -  Master Mode
 (rw) (02)  [0;32mCAPTURE_MODE[0m  - [07:06] -  Input Capture Mode
      0 - CAPTURE_MODE_0 :
         Capture function is disabled
      0x1 - CAPTURE_MODE_1 :
         Load capture register on rising edge (when IPS=0) or falling edge (when
          IPS=1) of input
      0x2 - CAPTURE_MODE_2 :
         Load capture register on falling edge (when IPS=0) or rising edge (when
          IPS=1) of input
      0x3 - CAPTURE_MODE_3 :
         Load capture register on both edges of input
 (ro) (01)  [0;32mINPUT[0m  - [08:08] -  External Input Signal
 (rw) (01)  [0;32mIPS[0m  - [09:09] -  Input Polarity Select
 (rw) (01)  [0;32mIEFIE[0m  - [10:10] -  Input Edge Flag Interrupt Enable
 (rw) (01)  [0;32mIEF[0m  - [11:11] -  Input Edge Flag
 (rw) (01)  [0;32mTOFIE[0m  - [12:12] -  Timer Overflow Flag Interrupt Enable
 (rw) (01)  [0;32mTOF[0m  - [13:13] -  Timer Overflow Flag
 (rw) (01)  [0;32mTCFIE[0m  - [14:14] -  Timer Compare Flag Interrupt Enable
 (rw) (01)  [0;32mTCF[0m  - [15:15] -  Timer Compare Flag
</lang>
#### tmr4.sctrl1
<link=p.TMR4.SCTRL1>
#### TMR4.CMPLD12
<link=p.TMR4.CMPLD12>
#### p.TMR4.CSCTRL1
<lang=dft>
 (rw)  [1;33m0x401e8034[0m (0x401e8000 + 0x0034)
Timer Channel Comparator Status and Control Register
 (rw) (02)  [0;32mCL1[0m  - [01:00] -  Compare Load Control 1
      0 - CL1_0 :
         Never preload
      0x1 - CL1_1 :
         Load upon successful compare with the value in COMP1
      0x2 - CL1_2 :
         Load upon successful compare with the value in COMP2
 (rw) (02)  [0;32mCL2[0m  - [03:02] -  Compare Load Control 2
      0 - CL2_0 :
         Never preload
      0x1 - CL2_1 :
         Load upon successful compare with the value in COMP1
      0x2 - CL2_2 :
         Load upon successful compare with the value in COMP2
 (rw) (01)  [0;32mTCF1[0m  - [04:04] -  Timer Compare 1 Interrupt Flag
 (rw) (01)  [0;32mTCF2[0m  - [05:05] -  Timer Compare 2 Interrupt Flag
 (rw) (01)  [0;32mTCF1EN[0m  - [06:06] -  Timer Compare 1 Interrupt Enable
 (rw) (01)  [0;32mTCF2EN[0m  - [07:07] -  Timer Compare 2 Interrupt Enable
 (ro) (01)  [0;32mUP[0m  - [09:09] -  Counting Direction Indicator
      0 - UP_0 :
         The last count was in the DOWN direction.
      0x1 - UP_1 :
         The last count was in the UP direction.
 (rw) (01)  [0;32mTCI[0m  - [10:10] -  Triggered Count Initialization Control
      0 - TCI_0 :
         Stop counter upon receiving a second trigger event while still counting
          from the first trigger event.
      0x1 - TCI_1 :
         Reload the counter upon receiving a second trigger event while still co
         unting from the first trigger event.
 (rw) (01)  [0;32mROC[0m  - [11:11] -  Reload on Capture
      0 - ROC_0 :
         Do not reload the counter on a capture event.
      0x1 - ROC_1 :
         Reload the counter on a capture event.
 (rw) (01)  [0;32mALT_LOAD[0m  - [12:12] -  Alternative Load Enable
      0 - ALT_LOAD_0 :
         Counter can be re-initialized only with the LOAD register.
      0x1 - ALT_LOAD_1 :
         Counter can be re-initialized with the LOAD or CMPLD2 registers dependi
         ng on count direction.
 (rw) (01)  [0;32mFAULT[0m  - [13:13] -  Fault Enable
      0 - FAULT_0 :
         Fault function disabled.
      0x1 - FAULT_1 :
         Fault function enabled.
 (rw) (02)  [0;32mDBG_EN[0m  - [15:14] -  Debug Actions Enable
      0 - DBG_EN_0 :
         Continue with normal operation during debug mode. (default)
      0x1 - DBG_EN_1 :
         Halt TMR counter during debug mode.
      0x2 - DBG_EN_2 :
         Force TMR output to logic 0 (prior to consideration of SCTRL[OPS]).
      0x3 - DBG_EN_3 :
         Both halt counter and force output to 0 during debug mode.
</lang>
#### TMR4.FILT2
<link=p.TMR4.FILT2>
#### p.TMR4.DMA2
<lang=dft>
 (rw)  [1;33m0x401e8058[0m (0x401e8000 + 0x0058)
Timer Channel DMA Enable Register
 (rw) (01)  [0;32mIEFDE[0m  - [00:00] -  Input Edge Flag DMA Enable
 (rw) (01)  [0;32mCMPLD1DE[0m  - [01:01] -  Comparator Preload Register 1 DMA Enable
 (rw) (01)  [0;32mCMPLD2DE[0m  - [02:02] -  Comparator Preload Register 2 DMA Enable
</lang>
#### tmr4.dma3
<link=p.TMR4.DMA3>
#### p.tmr4.enbl
<link=p.TMR4.ENBL>
#### p.gpt2.ocr2
<link=p.GPT2.OCR2>
#### gpt2.icr1
<link=p.GPT2.ICR1>
#### p.ocotp
<link=p.OCOTP>
#### OCOTP.CTRL_TOG
<link=p.OCOTP.CTRL_TOG>
#### OCOTP.READ_CTRL
<link=p.OCOTP.READ_CTRL>
#### ocotp.crc_addr
<link=p.OCOTP.CRC_ADDR>
#### ocotp.cfg0
<link=p.OCOTP.CFG0>
#### OCOTP.CFG0
<link=p.OCOTP.CFG0>
#### p.ocotp.otpmk6
<link=p.OCOTP.OTPMK6>
#### OCOTP.OTPMK7
<link=p.OCOTP.OTPMK7>
#### ocotp.srk3
<link=p.OCOTP.SRK3>
#### OCOTP.SRK3
<link=p.OCOTP.SRK3>
#### p.OCOTP.SW_GP20
<lang=dft>
 (rw)  [1;33m0x401f4690[0m (0x401f4000 + 0x0690)
Value of OTP Bank5 Word1 (SW GP2)
 (rw) (32)  [0;32mBITS[0m  - [31:00] -  BITS
</lang>
#### OCOTP.SW_GP20
<link=p.OCOTP.SW_GP20>
#### p.OCOTP.MISC_CONF0
<lang=dft>
 (rw)  [1;33m0x401f46d0[0m (0x401f4000 + 0x06d0)
Value of OTP Bank5 Word5 (Misc Conf)
 (rw) (32)  [0;32mBITS[0m  - [31:00] -  BITS
</lang>
#### p.ocotp.srk_revoke
<link=p.OCOTP.SRK_REVOKE>
#### OCOTP.ROM_PATCH2
<link=p.OCOTP.ROM_PATCH2>
#### ocotp.rom_patch4
<link=p.OCOTP.ROM_PATCH4>
#### p.ocotp.rom_patch7
<link=p.OCOTP.ROM_PATCH7>
#### OCOTP.GP43
<link=p.OCOTP.GP43>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_02
<lang=dft>
 (rw)  [1;33m0x401f801c[0m (0x401f8000 + 0x001c)
SW_MUX_CTL_PAD_GPIO_EMC_02 SW MUX Control Register
 (rw) (03)  [0;32mMUX_MODE[0m  - [02:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: SEMC_DATA02 of instance: semc
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: FLEXPWM4_PWMA01 of instance: flexpwm4
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPSPI2_SDO of instance: lpspi2
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: XBAR1_INOUT04 of instance: xbar1
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO02 of instance: flexio1
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO4_IO02 of instance: gpio4
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_EMC_02
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_emc_02
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_02>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_11
<lang=dft>
 (rw)  [1;33m0x401f8040[0m (0x401f8000 + 0x0040)
SW_MUX_CTL_PAD_GPIO_EMC_11 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: SEMC_ADDR02 of instance: semc
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: FLEXPWM2_PWMB02 of instance: flexpwm2
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPI2C4_SDA of instance: lpi2c4
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: USDHC2_RESET_B of instance: usdhc2
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO11 of instance: flexio1
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO4_IO11 of instance: gpio4
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: FLEXSPI2_B_DQS of instance: flexspi2
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_EMC_11
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_emc_15
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_15>
#### p.iomuxc.sw_mux_ctl_pad_gpio_emc_19
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_19>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_24
<lang=dft>
 (rw)  [1;33m0x401f8074[0m (0x401f8000 + 0x0074)
SW_MUX_CTL_PAD_GPIO_EMC_24 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: SEMC_CAS of instance: semc
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: FLEXPWM1_PWMB00 of instance: flexpwm1
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPUART5_RX of instance: lpuart5
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: ENET_TX_EN of instance: enet
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: GPT1_CAPTURE1 of instance: gpt1
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO4_IO24 of instance: gpio4
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_EMC_24
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_emc_24
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_24>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_32
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_32>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_37
<lang=dft>
 (rw)  [1;33m0x401f80a8[0m (0x401f8000 + 0x00a8)
SW_MUX_CTL_PAD_GPIO_EMC_37 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: SEMC_DATA15 of instance: semc
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: XBAR1_IN23 of instance: xbar1
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: GPT1_COMPARE3 of instance: gpt1
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: SAI3_MCLK of instance: sai3
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: CSI_DATA16 of instance: csi
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO3_IO23 of instance: gpio3
      0x6 - ALT6 :
         Select mux mode: ALT6 mux port: USDHC2_WP of instance: usdhc2
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
      0x9 - ALT9 :
         Select mux mode: ALT9 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_EMC_37
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_ad_b0_00
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_00>
#### p.iomuxc.sw_mux_ctl_pad_gpio_ad_b0_05
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_05>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_09
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_09>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_12
<lang=dft>
 (rw)  [1;33m0x401f80ec[0m (0x401f8000 + 0x00ec)
SW_MUX_CTL_PAD_GPIO_AD_B0_12 SW MUX Control Register
 (rw) (03)  [0;32mMUX_MODE[0m  - [02:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: LPI2C4_SCL of instance: lpi2c4
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: CCM_PMIC_READY of instance: ccm
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPUART1_TX of instance: lpuart1
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: WDOG2_WDOG_B of instance: wdog2
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: FLEXPWM1_PWMX02 of instance: flexpwm1
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO1_IO12 of instance: gpio1
      0x6 - ALT6 :
         Select mux mode: ALT6 mux port: ENET_1588_EVENT1_OUT of instance: enet
      0x7 - ALT7 :
         Select mux mode: ALT7 mux port: NMI_GLUE_NMI of instance: nmi_glue
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_AD_B0_12
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_ad_b0_13
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_13>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_06
<lang=dft>
 (rw)  [1;33m0x401f8114[0m (0x401f8000 + 0x0114)
SW_MUX_CTL_PAD_GPIO_AD_B1_06 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: FLEXSPIB_DATA01 of instance: flexspi
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: LPI2C3_SDA of instance: lpi2c3
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPUART3_TX of instance: lpuart3
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: SPDIF_LOCK of instance: spdif
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: CSI_VSYNC of instance: csi
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO1_IO22 of instance: gpio1
      0x6 - ALT6 :
         Select mux mode: ALT6 mux port: USDHC2_DATA2 of instance: usdhc2
      0x7 - ALT7 :
         Select mux mode: ALT7 mux port: KPP_ROW04 of instance: kpp
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: GPT2_COMPARE2 of instance: gpt2
      0x9 - ALT9 :
         Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO06 of instance: flexio3
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_AD_B1_06
</lang>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_06
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_06>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_11
<lang=dft>
 (rw)  [1;33m0x401f8128[0m (0x401f8000 + 0x0128)
SW_MUX_CTL_PAD_GPIO_AD_B1_11 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: FLEXSPIA_DATA02 of instance: flexspi
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: EWM_OUT_B of instance: ewm
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: CSI_DATA06 of instance: csi
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO1_IO27 of instance: gpio1
      0x6 - ALT6 :
         Select mux mode: ALT6 mux port: USDHC2_RESET_B of instance: usdhc2
      0x7 - ALT7 :
         Select mux mode: ALT7 mux port: KPP_COL02 of instance: kpp
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: ENET2_1588_EVENT1_IN of instance: enet2
      0x9 - ALT9 :
         Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO11 of instance: flexio3
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_AD_B1_11
</lang>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_15
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B1_15>
#### p.iomuxc.sw_mux_ctl_pad_gpio_b0_07
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_07>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_07
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_07>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_08
<lang=dft>
 (rw)  [1;33m0x401f815c[0m (0x401f8000 + 0x015c)
SW_MUX_CTL_PAD_GPIO_B0_08 SW MUX Control Register
 (rw) (04)  [0;32mMUX_MODE[0m  - [03:00] -  MUX Mode Select Field.
      0 - ALT0 :
         Select mux mode: ALT0 mux port: LCD_DATA04 of instance: lcdif
      0x1 - ALT1 :
         Select mux mode: ALT1 mux port: QTIMER3_TIMER2 of instance: qtimer3
      0x2 - ALT2 :
         Select mux mode: ALT2 mux port: FLEXPWM2_PWMA01 of instance: flexpwm2
      0x3 - ALT3 :
         Select mux mode: ALT3 mux port: LPUART3_TX of instance: lpuart3
      0x4 - ALT4 :
         Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO08 of instance: flexio2
      0x5 - ALT5 :
         Select mux mode: ALT5 mux port: GPIO2_IO08 of instance: gpio2
      0x6 - ALT6 :
         Select mux mode: ALT6 mux port: SRC_BOOT_CFG04 of instance: src
      0x8 - ALT8 :
         Select mux mode: ALT8 mux port: ENET2_RDATA03 of instance: enet2
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_B0_08
</lang>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_14
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_14>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_B1_00
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B1_00>
#### iomuxc.sw_mux_ctl_pad_gpio_b1_04
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B1_04>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_B1_13
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B1_13>
#### p.iomuxc.sw_mux_ctl_pad_gpio_sd_b0_01
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B0_01>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B0_05
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B0_05>
#### p.iomuxc.sw_mux_ctl_pad_gpio_sd_b1_06
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B1_06>
#### iomuxc.sw_mux_ctl_pad_gpio_sd_b1_09
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B1_09>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B1_11
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_B1_11>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_09
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_09>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_10
<lang=dft>
 (rw)  [1;33m0x401f822c[0m (0x401f8000 + 0x022c)
SW_PAD_CTL_PAD_GPIO_EMC_10 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_17
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_17>
#### p.iomuxc.sw_pad_ctl_pad_gpio_emc_24
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_24>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_26
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_26>
#### iomuxc.sw_pad_ctl_pad_gpio_emc_28
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_28>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_29
<lang=dft>
 (rw)  [1;33m0x401f8278[0m (0x401f8000 + 0x0278)
SW_PAD_CTL_PAD_GPIO_EMC_29 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_31
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_31>
#### iomuxc.sw_pad_ctl_pad_gpio_emc_34
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_34>
#### p.iomuxc.sw_pad_ctl_pad_gpio_emc_38
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_38>
#### p.iomuxc.sw_pad_ctl_pad_gpio_ad_b0_08
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_08>
#### iomuxc.sw_pad_ctl_pad_gpio_ad_b0_11
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_11>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_13
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_13>
#### p.iomuxc.sw_pad_ctl_pad_gpio_ad_b0_14
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_14>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_01
<lang=dft>
 (rw)  [1;33m0x401f82f0[0m (0x401f8000 + 0x02f0)
SW_PAD_CTL_PAD_GPIO_AD_B1_01 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### iomuxc.sw_pad_ctl_pad_gpio_ad_b1_04
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_04>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_06
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_06>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_11
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_11>
#### p.iomuxc.sw_pad_ctl_pad_gpio_ad_b1_14
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_14>
#### p.iomuxc.sw_pad_ctl_pad_gpio_b0_01
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B0_01>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_01
<lang=dft>
 (rw)  [1;33m0x401f8370[0m (0x401f8000 + 0x0370)
SW_PAD_CTL_PAD_GPIO_B1_01 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### iomuxc.sw_pad_ctl_pad_gpio_b1_04
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_04>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_09
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_09>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_12
<lang=dft>
 (rw)  [1;33m0x401f839c[0m (0x401f8000 + 0x039c)
SW_PAD_CTL_PAD_GPIO_B1_12 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### p.iomuxc.sw_pad_ctl_pad_gpio_b1_15
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_15>
#### p.iomuxc.sw_pad_ctl_pad_gpio_sd_b1_01
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_01>
#### iomuxc.sw_pad_ctl_pad_gpio_sd_b1_05
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_05>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_06
<lang=dft>
 (rw)  [1;33m0x401f83dc[0m (0x401f8000 + 0x03dc)
SW_PAD_CTL_PAD_GPIO_SD_B1_06 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_11
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_11>
#### p.iomuxc.anatop_usb_otg1_id_select_input
<link=p.IOMUXC.ANATOP_USB_OTG1_ID_SELECT_INPUT>
#### IOMUXC.CSI_VSYNC_SELECT_INPUT
<link=p.IOMUXC.CSI_VSYNC_SELECT_INPUT>
#### IOMUXC.ENET1_RXDATA_SELECT_INPUT
<link=p.IOMUXC.ENET1_RXDATA_SELECT_INPUT>
#### IOMUXC.ENET_TXCLK_SELECT_INPUT
<link=p.IOMUXC.ENET_TXCLK_SELECT_INPUT>
#### p.iomuxc.flexcan2_rx_select_input
<link=p.IOMUXC.FLEXCAN2_RX_SELECT_INPUT>
#### p.iomuxc.flexpwm2_pwma0_select_input
<link=p.IOMUXC.FLEXPWM2_PWMA0_SELECT_INPUT>
#### IOMUXC.FLEXPWM2_PWMA2_SELECT_INPUT
<link=p.IOMUXC.FLEXPWM2_PWMA2_SELECT_INPUT>
#### p.IOMUXC.FLEXPWM2_PWMB3_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f8484[0m (0x401f8000 + 0x0484)
FLEXPWM2_PWMB3_SELECT_INPUT DAISY Register
 (rw) (02)  [0;32mDAISY[0m  - [01:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_SD_B1_03_ALT2 :
         Selecting Pad: GPIO_SD_B1_03 for Mode: ALT2
      0x1 - GPIO_EMC_20_ALT1 :
         Selecting Pad: GPIO_EMC_20 for Mode: ALT1
      0x2 - GPIO_AD_B0_01_ALT0 :
         Selecting Pad: GPIO_AD_B0_01 for Mode: ALT0
      0x3 - GPIO_B1_03_ALT6 :
         Selecting Pad: GPIO_B1_03 for Mode: ALT6
</lang>
#### p.iomuxc.flexspia_dqs_select_input
<link=p.IOMUXC.FLEXSPIA_DQS_SELECT_INPUT>
#### iomuxc.flexspia_data0_select_input
<link=p.IOMUXC.FLEXSPIA_DATA0_SELECT_INPUT>
#### p.iomuxc.lpspi1_sdi_select_input
<link=p.IOMUXC.LPSPI1_SDI_SELECT_INPUT>
#### iomuxc.lpspi1_sdo_select_input
<link=p.IOMUXC.LPSPI1_SDO_SELECT_INPUT>
#### IOMUXC.LPUART2_RX_SELECT_INPUT
<link=p.IOMUXC.LPUART2_RX_SELECT_INPUT>
#### p.iomuxc.lpuart3_cts_b_select_input
<link=p.IOMUXC.LPUART3_CTS_B_SELECT_INPUT>
#### p.IOMUXC.LPUART3_RX_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f8538[0m (0x401f8000 + 0x0538)
LPUART3_RX_SELECT_INPUT DAISY Register
 (rw) (02)  [0;32mDAISY[0m  - [01:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_AD_B1_07_ALT2 :
         Selecting Pad: GPIO_AD_B1_07 for Mode: ALT2
      0x1 - GPIO_EMC_14_ALT2 :
         Selecting Pad: GPIO_EMC_14 for Mode: ALT2
      0x2 - GPIO_B0_09_ALT3 :
         Selecting Pad: GPIO_B0_09 for Mode: ALT3
</lang>
#### iomuxc.lpuart3_tx_select_input
<link=p.IOMUXC.LPUART3_TX_SELECT_INPUT>
#### iomuxc.lpuart5_rx_select_input
<link=p.IOMUXC.LPUART5_RX_SELECT_INPUT>
#### iomuxc.lpuart6_rx_select_input
<link=p.IOMUXC.LPUART6_RX_SELECT_INPUT>
#### iomuxc.lpuart8_rx_select_input
<link=p.IOMUXC.LPUART8_RX_SELECT_INPUT>
#### IOMUXC.QTIMER2_TIMER0_SELECT_INPUT
<link=p.IOMUXC.QTIMER2_TIMER0_SELECT_INPUT>
#### p.iomuxc.qtimer2_timer1_select_input
<link=p.IOMUXC.QTIMER2_TIMER1_SELECT_INPUT>
#### IOMUXC.QTIMER2_TIMER2_SELECT_INPUT
<link=p.IOMUXC.QTIMER2_TIMER2_SELECT_INPUT>
#### p.IOMUXC.QTIMER3_TIMER2_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f8584[0m (0x401f8000 + 0x0584)
QTIMER3_TIMER2_SELECT_INPUT DAISY Register
 (rw) (02)  [0;32mDAISY[0m  - [01:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_EMC_17_ALT4 :
         Selecting Pad: GPIO_EMC_17 for Mode: ALT4
      0x1 - GPIO_AD_B1_02_ALT1 :
         Selecting Pad: GPIO_AD_B1_02 for Mode: ALT1
      0x2 - GPIO_B0_08_ALT1 :
         Selecting Pad: GPIO_B0_08 for Mode: ALT1
</lang>
#### IOMUXC.QTIMER3_TIMER2_SELECT_INPUT
<link=p.IOMUXC.QTIMER3_TIMER2_SELECT_INPUT>
#### IOMUXC.QTIMER3_TIMER3_SELECT_INPUT
<link=p.IOMUXC.QTIMER3_TIMER3_SELECT_INPUT>
#### iomuxc.sai1_rx_bclk_select_input
<link=p.IOMUXC.SAI1_RX_BCLK_SELECT_INPUT>
#### p.iomuxc.sai1_rx_data0_select_input
<link=p.IOMUXC.SAI1_RX_DATA0_SELECT_INPUT>
#### iomuxc.sai1_rx_data1_select_input
<link=p.IOMUXC.SAI1_RX_DATA1_SELECT_INPUT>
#### p.iomuxc.sai1_rx_data2_select_input
<link=p.IOMUXC.SAI1_RX_DATA2_SELECT_INPUT>
#### p.IOMUXC.SAI2_MCLK2_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f85b0[0m (0x401f8000 + 0x05b0)
SAI2_MCLK2_SELECT_INPUT DAISY Register
 (rw) (01)  [0;32mDAISY[0m  - [00:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_EMC_07_ALT2 :
         Selecting Pad: GPIO_EMC_07 for Mode: ALT2
      0x1 - GPIO_AD_B0_10_ALT3 :
         Selecting Pad: GPIO_AD_B0_10 for Mode: ALT3
</lang>
#### p.iomuxc.sai2_rx_sync_select_input
<link=p.IOMUXC.SAI2_RX_SYNC_SELECT_INPUT>
#### IOMUXC.USB_OTG2_OC_SELECT_INPUT
<link=p.IOMUXC.USB_OTG2_OC_SELECT_INPUT>
#### p.IOMUXC.USDHC2_CD_B_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f85e0[0m (0x401f8000 + 0x05e0)
USDHC2_CD_B_SELECT_INPUT DAISY Register
 (rw) (01)  [0;32mDAISY[0m  - [00:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_AD_B1_03_ALT6 :
         Selecting Pad:GPIO_AD_B1_03 for Mode: ALT6
      0x1 - GPIO_EMC_39_ALT6 :
         Selecting Pad: GPIO_EMC_39 for Mode: ALT6
</lang>
#### p.IOMUXC.USDHC2_DATA3_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f85f4[0m (0x401f8000 + 0x05f4)
USDHC2_DATA3_SELECT_INPUT DAISY Register
 (rw) (01)  [0;32mDAISY[0m  - [00:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_SD_B1_00_ALT0 :
         Selecting Pad: GPIO_SD_B1_00 for Mode: ALT0
      0x1 - GPIO_AD_B1_07_ALT6 :
         Selecting Pad: GPIO_AD_B1_07 for Mode: ALT6
</lang>
#### p.iomuxc.usdhc2_wp_select_input
<link=p.IOMUXC.USDHC2_WP_SELECT_INPUT>
#### p.IOMUXC.XBAR1_IN02_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f860c[0m (0x401f8000 + 0x060c)
XBAR1_IN02_SELECT_INPUT DAISY Register
 (rw) (01)  [0;32mDAISY[0m  - [00:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_EMC_00_ALT3 :
         Selecting Pad: GPIO_EMC_00 for Mode: ALT3
      0x1 - GPIO_B1_14_ALT3 :
         Selecting Pad: GPIO_B1_14 for Mode: ALT3
</lang>
#### iomuxc.xbar1_in04_select_input
<link=p.IOMUXC.XBAR1_IN04_SELECT_INPUT>
#### iomuxc.xbar1_in06_select_input
<link=p.IOMUXC.XBAR1_IN06_SELECT_INPUT>
#### IOMUXC.XBAR1_IN08_SELECT_INPUT
<link=p.IOMUXC.XBAR1_IN08_SELECT_INPUT>
#### iomuxc.xbar1_in18_select_input
<link=p.IOMUXC.XBAR1_IN18_SELECT_INPUT>
#### iomuxc.xbar1_in16_select_input
<link=p.IOMUXC.XBAR1_IN16_SELECT_INPUT>
#### p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B0_00
<lang=dft>
 (rw)  [1;33m0x401f865c[0m (0x401f8000 + 0x065c)
SW_MUX_CTL_PAD_GPIO_SPI_B0_00 SW MUX Control Register
 (rw) (01)  [0;32mSION[0m  - [04:04] -  Software Input On Field.
      0 - DISABLED :
         Input Path is determined by functionality
      0x1 - ENABLED :
         Force input path of pad GPIO_SPI_B0_00
</lang>
#### iomuxc.sw_mux_ctl_pad_gpio_spi_b0_01
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B0_01>
#### IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B0_02
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B0_02>
#### p.iomuxc.sw_mux_ctl_pad_gpio_spi_b1_07
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B1_07>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B0_00
<lang=dft>
 (rw)  [1;33m0x401f86b4[0m (0x401f8000 + 0x06b4)
SW_PAD_CTL_PAD_GPIO_SPI_B0_00 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled_ :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz_ :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz_ :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz_ :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz_ :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### p.iomuxc.sw_pad_ctl_pad_gpio_spi_b0_02
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B0_02>
#### iomuxc.sw_pad_ctl_pad_gpio_spi_b0_06
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B0_06>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B0_13
<lang=dft>
 (rw)  [1;33m0x401f86e8[0m (0x401f8000 + 0x06e8)
SW_PAD_CTL_PAD_GPIO_SPI_B0_13 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled_ :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz_ :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz_ :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz_ :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz_ :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### iomuxc.sw_pad_ctl_pad_gpio_spi_b1_01
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B1_01>
#### p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B1_07
<lang=dft>
 (rw)  [1;33m0x401f8708[0m (0x401f8000 + 0x0708)
SW_PAD_CTL_PAD_GPIO_SPI_B1_07 SW PAD Control Register
 (rw) (01)  [0;32mSRE[0m  - [00:00] -  Slew Rate Field
      0 - SRE_0_Slow_Slew_Rate :
         Slow Slew Rate
      0x1 - SRE_1_Fast_Slew_Rate :
         Fast Slew Rate
 (rw) (03)  [0;32mDSE[0m  - [05:03] -  Drive Strength Field
      0 - DSE_0_output_driver_disabled_ :
         output driver disabled;
      0x1 - DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ :
         R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
      0x2 - DSE_2_R0_2 :
         R0/2
      0x3 - DSE_3_R0_3 :
         R0/3
      0x4 - DSE_4_R0_4 :
         R0/4
      0x5 - DSE_5_R0_5 :
         R0/5
      0x6 - DSE_6_R0_6 :
         R0/6
      0x7 - DSE_7_R0_7 :
         R0/7
 (rw) (02)  [0;32mSPEED[0m  - [07:06] -  Speed Field
      0 - SPEED_0_low_50MHz_ :
         low(50MHz)
      0x1 - SPEED_1_medium_100MHz_ :
         medium(100MHz)
      0x2 - SPEED_2_medium_100MHz_ :
         medium(100MHz)
      0x3 - SPEED_3_max_200MHz_ :
         max(200MHz)
 (rw) (01)  [0;32mODE[0m  - [11:11] -  Open Drain Enable Field
      0 - ODE_0_Open_Drain_Disabled :
         Open Drain Disabled
      0x1 - ODE_1_Open_Drain_Enabled :
         Open Drain Enabled
 (rw) (01)  [0;32mPKE[0m  - [12:12] -  Pull / Keep Enable Field
      0 - PKE_0_Pull_Keeper_Disabled :
         Pull/Keeper Disabled
      0x1 - PKE_1_Pull_Keeper_Enabled :
         Pull/Keeper Enabled
 (rw) (01)  [0;32mPUE[0m  - [13:13] -  Pull / Keep Select Field
      0 - PUE_0_Keeper :
         Keeper
      0x1 - PUE_1_Pull :
         Pull
 (rw) (02)  [0;32mPUS[0m  - [15:14] -  Pull Up / Down Config. Field
      0 - PUS_0_100K_Ohm_Pull_Down :
         100K Ohm Pull Down
      0x1 - PUS_1_47K_Ohm_Pull_Up :
         47K Ohm Pull Up
      0x2 - PUS_2_100K_Ohm_Pull_Up :
         100K Ohm Pull Up
      0x3 - PUS_3_22K_Ohm_Pull_Up :
         22K Ohm Pull Up
 (rw) (01)  [0;32mHYS[0m  - [16:16] -  Hyst. Enable Field
      0 - HYS_0_Hysteresis_Disabled :
         Hysteresis Disabled
      0x1 - HYS_1_Hysteresis_Enabled :
         Hysteresis Enabled
</lang>
#### IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B1_07
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B1_07>
#### IOMUXC.FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT
<link=p.IOMUXC.FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT>
#### IOMUXC.GPT1_IPP_IND_CAPIN1_SELECT_INPUT
<link=p.IOMUXC.GPT1_IPP_IND_CAPIN1_SELECT_INPUT>
#### iomuxc.sai3_ipg_clk_sai_mclk_select_input_2
<link=p.IOMUXC.SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2>
#### iomuxc.sai3_ipp_ind_sai_rxsync_select_input
<link=p.IOMUXC.SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT>
#### p.iomuxc.sai3_ipp_ind_sai_txsync_select_input
<link=p.IOMUXC.SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT>
#### p.IOMUXC.SEMC_I_IPP_IND_DQS4_SELECT_INPUT
<lang=dft>
 (rw)  [1;33m0x401f8788[0m (0x401f8000 + 0x0788)
SEMC_I_IPP_IND_DQS4_SELECT_INPUT DAISY Register
 (rw) (02)  [0;32mDAISY[0m  - [01:00] -  Selecting Pads Involved in Daisy Chain.
      0 - GPIO_SD_B0_00_ALT9 :
         Selecting Pad: GPIO_SD_B0_00 for Mode: ALT9
      0x1 - GPIO_EMC_39_ALT9 :
         Selecting Pad: GPIO_EMC_39 for Mode: ALT9
      0x2 - GPIO_AD_B0_09_ALT9 :
         Selecting Pad: GPIO_AD_B0_09 for Mode: ALT9
      0x3 - GPIO_B1_13_ALT8 :
         Selecting Pad: GPIO_B1_13 for Mode: ALT8
</lang>
#### p.FLEXSPI.MCR2
<lang=dft>
 (rw)  [1;33m0x402a8008[0m (0x402a8000 + 0x0008)
Module Control Register 2
 (rw) (01)  [0;32mCLRAHBBUFOPT[0m  - [11:11] -  This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned aut
 omaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if A
 HB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB r
 ead access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but t
 heir data entries are invalid.
      0 - CLRAHBBUFOPT_0 :
         AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return 
         Stop mode ACK.
      0x1 - CLRAHBBUFOPT_1 :
         AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop
          mode ACK.
 (rw) (01)  [0;32mCLRLEARNPHASE[0m  - [14:14] -  The sampling clock phase selection will be reset to phase 0 when this bit is wr
 itten with 0x1. This bit will be auto-cleared immediately.
 (rw) (01)  [0;32mSAMEDEVICEEN[0m  - [15:15] -  All external devices are same devices (both in types and size) for A1/A2/B1/B2.
      0 - SAMEDEVICEEN_0 :
         In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register se
         tting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel mode
         , FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2
         CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSH
         B2CRx register settings will be ignored.
      0x1 - SAMEDEVICEEN_1 :
         FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flas
         h A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
 (rw) (01)  [0;32mSCKBDIFFOPT[0m  - [19:19] -  SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA)
 . In this case, port B flash access is not available. After change the value of
  this feild, MCR0[SWRESET] should be set.
      0 - SCKBDIFFOPT_0 :
         SCKB pad is used as port B SCK clock output. Port B flash access is ava
         ilable.
      0x1 - SCKBDIFFOPT_1 :
         SCKB pad is used as port A SCK inverted clock output (Differential cloc
         k to SCKA). Port B flash access is not available.
 (rw) (08)  [0;32mRESUMEWAIT[0m  - [31:24] -  Wait cycle (in AHB clock cycle) for idle state before suspended command sequenc
 e resumed.
</lang>
#### p.FLEXSPI.INTR
<lang=dft>
 (rw)  [1;33m0x402a8014[0m (0x402a8000 + 0x0014)
Interrupt Register
 (rw) (01)  [0;32mIPCMDDONE[0m  - [00:00] -  IP triggered Command Sequences Execution finished interrupt. This interrupt is 
 also generated when there is IPCMDGE or IPCMDERR interrupt generated.
 (rw) (01)  [0;32mIPCMDGE[0m  - [01:01] -  IP triggered Command Sequences Grant Timeout interrupt.
 (rw) (01)  [0;32mAHBCMDGE[0m  - [02:02] -  AHB triggered Command Sequences Grant Timeout interrupt.
 (rw) (01)  [0;32mIPCMDERR[0m  - [03:03] -  IP triggered Command Sequences Error Detected interrupt. When an error detected
  for IP command, this command will be ignored and not executed at all.
 (rw) (01)  [0;32mAHBCMDERR[0m  - [04:04] -  AHB triggered Command Sequences Error Detected interrupt. When an error detecte
 d for AHB command, this command will be ignored and not executed at all.
 (rw) (01)  [0;32mIPRXWA[0m  - [05:05] -  IP RX FIFO watermark available interrupt.
 (rw) (01)  [0;32mIPTXWE[0m  - [06:06] -  IP TX FIFO watermark empty interrupt.
 (rw) (01)  [0;32mSCKSTOPBYRD[0m  - [08:08] -  SCK is stopped during command sequence because Async RX FIFO full interrupt.
 (rw) (01)  [0;32mSCKSTOPBYWR[0m  - [09:09] -  SCK is stopped during command sequence because Async TX FIFO empty interrupt.
 (rw) (01)  [0;32mAHBBUSTIMEOUT[0m  - [10:10] -  AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
 (rw) (01)  [0;32mSEQTIMEOUT[0m  - [11:11] -  Sequence execution timeout interrupt.
</lang>
#### p.FLEXSPI.LUTCR
<lang=dft>
 (rw)  [1;33m0x402a801c[0m (0x402a8000 + 0x001c)
LUT Control Register
 (rw) (01)  [0;32mLOCK[0m  - [00:00] -  Lock LUT
 (rw) (01)  [0;32mUNLOCK[0m  - [01:01] -  Unlock LUT
</lang>
#### p.flexspi.ahbrxbuf0cr0
<link=p.FLEXSPI.AHBRXBUF0CR0>
#### p.FLEXSPI.FLSHA1CR0
<lang=dft>
 (rw)  [1;33m0x402a8060[0m (0x402a8000 + 0x0060)
Flash A1 Control Register 0
 (rw) (23)  [0;32mFLSHSZ[0m  - [22:00] -  Flash Size in KByte.
</lang>
#### flexspi.flshcr1b1
<link=p.FLEXSPI.FLSHCR1B1>
#### p.flexspi.ipcr1
<link=p.FLEXSPI.IPCR1>
#### flexspi.sts2
<link=p.FLEXSPI.STS2>
#### flexspi.rfdr[14]
<link=p.FLEXSPI.RFDR[14]>
#### FLEXSPI.RFDR[17]
<link=p.FLEXSPI.RFDR[17]>
#### p.flexspi.rfdr[22]
<link=p.FLEXSPI.RFDR[22]>
#### p.FLEXSPI.RFDR[26]
<lang=dft>
 (ro)  [1;33m0x402a8168[0m (0x402a8000 + 0x0168)
IP RX FIFO Data Register 0
 (ro) (32)  [0;32mRXDATA[0m  - [31:00] -  RX Data
</lang>
#### FLEXSPI.RFDR[26]
<link=p.FLEXSPI.RFDR[26]>
#### p.flexspi.rfdr[27]
<link=p.FLEXSPI.RFDR[27]>
#### p.flexspi.rfdr[28]
<link=p.FLEXSPI.RFDR[28]>
#### flexspi.rfdr[31]
<link=p.FLEXSPI.RFDR[31]>
#### p.FLEXSPI.TFDR[2]
<lang=dft>
 (wo)  [1;33m0x402a8188[0m (0x402a8000 + 0x0188)
IP TX FIFO Data Register 0
 (wo) (32)  [0;32mTXDATA[0m  - [31:00] -  TX Data
</lang>
#### FLEXSPI.TFDR[11]
<link=p.FLEXSPI.TFDR[11]>
#### flexspi.tfdr[12]
<link=p.FLEXSPI.TFDR[12]>
#### flexspi.tfdr[29]
<link=p.FLEXSPI.TFDR[29]>
#### p.flexspi.lut[0]
<link=p.FLEXSPI.LUT[0]>
#### flexspi.lut[2]
<link=p.FLEXSPI.LUT[2]>
#### p.FLEXSPI.LUT[4]
<lang=dft>
 (rw)  [1;33m0x402a8210[0m (0x402a8000 + 0x0210)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### p.flexspi.lut[5]
<link=p.FLEXSPI.LUT[5]>
#### FLEXSPI.LUT[10]
<link=p.FLEXSPI.LUT[10]>
#### p.FLEXSPI.LUT[26]
<lang=dft>
 (rw)  [1;33m0x402a8268[0m (0x402a8000 + 0x0268)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### flexspi.lut[26]
<link=p.FLEXSPI.LUT[26]>
#### FLEXSPI.LUT[36]
<link=p.FLEXSPI.LUT[36]>
#### p.FLEXSPI.LUT[47]
<lang=dft>
 (rw)  [1;33m0x402a82bc[0m (0x402a8000 + 0x02bc)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### p.flexspi.lut[48]
<link=p.FLEXSPI.LUT[48]>
#### FLEXSPI.LUT[49]
<link=p.FLEXSPI.LUT[49]>
#### flexspi.lut[56]
<link=p.FLEXSPI.LUT[56]>
#### FLEXSPI.LUT[59]
<link=p.FLEXSPI.LUT[59]>
#### p.FLEXSPI.LUT[61]
<lang=dft>
 (rw)  [1;33m0x402a82f4[0m (0x402a8000 + 0x02f4)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### p.flexspi2.mcr1
<link=p.FLEXSPI2.MCR1>
#### p.FLEXSPI2.MCR2
<lang=dft>
 (rw)  [1;33m0x402a4008[0m (0x402a4000 + 0x0008)
Module Control Register 2
 (rw) (01)  [0;32mCLRAHBBUFOPT[0m  - [11:11] -  This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned aut
 omaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if A
 HB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB r
 ead access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but t
 heir data entries are invalid.
      0 - CLRAHBBUFOPT_0 :
         AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return 
         Stop mode ACK.
      0x1 - CLRAHBBUFOPT_1 :
         AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop
          mode ACK.
 (rw) (01)  [0;32mCLRLEARNPHASE[0m  - [14:14] -  The sampling clock phase selection will be reset to phase 0 when this bit is wr
 itten with 0x1. This bit will be auto-cleared immediately.
 (rw) (01)  [0;32mSAMEDEVICEEN[0m  - [15:15] -  All external devices are same devices (both in types and size) for A1/A2/B1/B2.
      0 - SAMEDEVICEEN_0 :
         In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register se
         tting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel mode
         , FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2
         CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSH
         B2CRx register settings will be ignored.
      0x1 - SAMEDEVICEEN_1 :
         FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flas
         h A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
 (rw) (01)  [0;32mSCKBDIFFOPT[0m  - [19:19] -  SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA)
 . In this case, port B flash access is not available. After change the value of
  this feild, MCR0[SWRESET] should be set.
      0 - SCKBDIFFOPT_0 :
         SCKB pad is used as port B SCK clock output. Port B flash access is ava
         ilable.
      0x1 - SCKBDIFFOPT_1 :
         SCKB pad is used as port A SCK inverted clock output (Differential cloc
         k to SCKA). Port B flash access is not available.
 (rw) (08)  [0;32mRESUMEWAIT[0m  - [31:24] -  Wait cycle (in AHB clock cycle) for idle state before suspended command sequenc
 e resumed.
</lang>
#### flexspi2.ahbcr
<link=p.FLEXSPI2.AHBCR>
#### FLEXSPI2.AHBRXBUF0CR0
<link=p.FLEXSPI2.AHBRXBUF0CR0>
#### p.FLEXSPI2.FLSHCR1A1
<lang=dft>
 (rw)  [1;33m0x402a4070[0m (0x402a4000 + 0x0070)
Flash A1 Control Register 1
 (rw) (05)  [0;32mTCSS[0m  - [04:00] -  Serial Flash CS setup time.
 (rw) (05)  [0;32mTCSH[0m  - [09:05] -  Serial Flash CS Hold time.
 (rw) (01)  [0;32mWA[0m  - [10:10] -  Word Addressable.
 (rw) (04)  [0;32mCAS[0m  - [14:11] -  Column Address Size.
 (rw) (01)  [0;32mCSINTERVALUNIT[0m  - [15:15] -  CS interval unit
      0 - CSINTERVALUNIT_0 :
         The CS interval unit is 1 serial clock cycle
      0x1 - CSINTERVALUNIT_1 :
         The CS interval unit is 256 serial clock cycle
 (rw) (16)  [0;32mCSINTERVAL[0m  - [31:16] -  This field is used to set the minimum interval between flash device Chip select
 ion deassertion and flash device Chip selection assertion. If external flash ha
 s a limitation on the interval between command sequences, this field should be 
 set accordingly. If there is no limitation, set this field with value 0x0.
</lang>
#### flexspi2.flshcr2b1
<link=p.FLEXSPI2.FLSHCR2B1>
#### p.FLEXSPI2.IPCR0
<lang=dft>
 (rw)  [1;33m0x402a40a0[0m (0x402a4000 + 0x00a0)
IP Control Register 0
 (rw) (32)  [0;32mSFAR[0m  - [31:00] -  Serial Flash Address for IP command.
</lang>
#### flexspi2.ipcr1
<link=p.FLEXSPI2.IPCR1>
#### p.flexspi2.ipcmd
<link=p.FLEXSPI2.IPCMD>
#### flexspi2.sts0
<link=p.FLEXSPI2.STS0>
#### p.flexspi2.sts2
<link=p.FLEXSPI2.STS2>
#### FLEXSPI2.RFDR[0]
<link=p.FLEXSPI2.RFDR[0]>
#### p.flexspi2.rfdr[5]
<link=p.FLEXSPI2.RFDR[5]>
#### FLEXSPI2.RFDR[11]
<link=p.FLEXSPI2.RFDR[11]>
#### flexspi2.tfdr[12]
<link=p.FLEXSPI2.TFDR[12]>
#### flexspi2.tfdr[15]
<link=p.FLEXSPI2.TFDR[15]>
#### flexspi2.tfdr[20]
<link=p.FLEXSPI2.TFDR[20]>
#### p.FLEXSPI2.TFDR[28]
<lang=dft>
 (wo)  [1;33m0x402a41f0[0m (0x402a4000 + 0x01f0)
IP TX FIFO Data Register 0
 (wo) (32)  [0;32mTXDATA[0m  - [31:00] -  TX Data
</lang>
#### FLEXSPI2.TFDR[30]
<link=p.FLEXSPI2.TFDR[30]>
#### p.flexspi2.lut[2]
<link=p.FLEXSPI2.LUT[2]>
#### FLEXSPI2.LUT[4]
<link=p.FLEXSPI2.LUT[4]>
#### flexspi2.lut[6]
<link=p.FLEXSPI2.LUT[6]>
#### p.FLEXSPI2.LUT[7]
<lang=dft>
 (rw)  [1;33m0x402a421c[0m (0x402a4000 + 0x021c)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### flexspi2.lut[10]
<link=p.FLEXSPI2.LUT[10]>
#### p.FLEXSPI2.LUT[12]
<lang=dft>
 (rw)  [1;33m0x402a4230[0m (0x402a4000 + 0x0230)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### FLEXSPI2.LUT[12]
<link=p.FLEXSPI2.LUT[12]>
#### p.FLEXSPI2.LUT[18]
<lang=dft>
 (rw)  [1;33m0x402a4248[0m (0x402a4000 + 0x0248)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### FLEXSPI2.LUT[18]
<link=p.FLEXSPI2.LUT[18]>
#### p.FLEXSPI2.LUT[20]
<lang=dft>
 (rw)  [1;33m0x402a4250[0m (0x402a4000 + 0x0250)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### flexspi2.lut[43]
<link=p.FLEXSPI2.LUT[43]>
#### p.flexspi2.lut[48]
<link=p.FLEXSPI2.LUT[48]>
#### flexspi2.lut[49]
<link=p.FLEXSPI2.LUT[49]>
#### p.FLEXSPI2.LUT[51]
<lang=dft>
 (rw)  [1;33m0x402a42cc[0m (0x402a4000 + 0x02cc)
LUT 0
 (rw) (08)  [0;32mOPERAND0[0m  - [07:00] -  OPERAND0
 (rw) (02)  [0;32mNUM_PADS0[0m  - [09:08] -  NUM_PADS0
 (rw) (06)  [0;32mOPCODE0[0m  - [15:10] -  OPCODE
 (rw) (08)  [0;32mOPERAND1[0m  - [23:16] -  OPERAND1
 (rw) (02)  [0;32mNUM_PADS1[0m  - [25:24] -  NUM_PADS1
 (rw) (06)  [0;32mOPCODE1[0m  - [31:26] -  OPCODE1
</lang>
#### p.flexspi2.lut[61]
<link=p.FLEXSPI2.LUT[61]>
#### PXP.STAT_SET
<link=p.PXP.STAT_SET>
#### p.PXP.OUT_BUF2
<lang=dft>
 (rw)  [1;33m0x402b4040[0m (0x402b4000 + 0x0040)
Output Frame Buffer Pointer #2
 (rw) (32)  [0;32mADDR[0m  - [31:00] -  Current address pointer for the output frame buffer
</lang>
#### p.pxp.out_pitch
<link=p.PXP.OUT_PITCH>
#### p.pxp.out_lrc
<link=p.PXP.OUT_LRC>
#### PXP.OUT_PS_ULC
<link=p.PXP.OUT_PS_ULC>
#### p.PXP.PS_VBUF
<lang=dft>
 (rw)  [1;33m0x402b40e0[0m (0x402b4000 + 0x00e0)
PS V/Cr Input Buffer Address
 (rw) (32)  [0;32mADDR[0m  - [31:00] -  Address pointer for the PS V/Cr Chroma input buffer.
</lang>
#### PXP.PS_CLRKEYHIGH
<link=p.PXP.PS_CLRKEYHIGH>
#### p.pxp.as_clrkeyhigh
<link=p.PXP.AS_CLRKEYHIGH>
#### PXP.CSC1_COEF1
<link=p.PXP.CSC1_COEF1>
#### p.PXP.POWER
<lang=dft>
 (rw)  [1;33m0x402b4320[0m (0x402b4000 + 0x0320)
PXP Power Control Register
 (rw) (03)  [0;32mROT_MEM_LP_STATE[0m  - [11:09] -  Select the low power state of the ROT memory.
      0 - NONE :
         Memory is not in low power state.
      0x1 - LS :
         Light Sleep Mode. Low leakage mode, maintain memory contents.
      0x2 - DS :
         Deep Sleep Mode. Low leakage mode, maintain memory contents.
      0x4 - SD :
         Shut Down Mode. Shut Down periphery and core, no memory retention.
 (rw) (20)  [0;32mCTRL[0m  - [31:12] -  Power control for the PXP.
</lang>
#### lcdif.ctrl_clr
<link=p.LCDIF.CTRL_CLR>
#### p.LCDIF.CTRL_TOG
<lang=dft>
 (rw)  [1;33m0x402b800c[0m (0x402b8000 + 0x000c)
LCDIF General Control Register
 (rw) (01)  [0;32mRUN[0m  - [00:00] -  When this bit is set by software, the LCDIF will begin transferring data betwee
 n the SoC and the display
 (rw) (01)  [0;32mDATA_FORMAT_24_BIT[0m  - [01:01] -  Used only when WORD_LENGTH = 3, i
      0 - ALL_24_BITS_VALID :
         Data input to the block is in 24 bpp format, such that all RGB 888 data
          is contained in 24 bits.
      0x1 - DROP_UPPER_2_BITS_PER_BYTE :
         Data input to the block is actually RGB 18 bpp, but there is 1 color pe
         r byte, hence the upper 2 bits in each byte do not contain any useful d
         ata, and should be dropped.
 (rw) (01)  [0;32mDATA_FORMAT_18_BIT[0m  - [02:02] -  Used only when WORD_LENGTH = 2, i.e. 18-bit.
      0 - LOWER_18_BITS_VALID :
         Data input to the block is in 18 bpp format, such that lower 18 bits co
         ntain RGB 666 and upper 14 bits do not contain any useful data.
      0x1 - UPPER_18_BITS_VALID :
         Data input to the block is in 18 bpp format, such that upper 18 bits co
         ntain RGB 666 and lower 14 bits do not contain any useful data.
 (rw) (01)  [0;32mDATA_FORMAT_16_BIT[0m  - [03:03] -  When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in A
 RGB555 format
 (rw) (01)  [0;32mMASTER[0m  - [05:05] -  Set this bit to make the LCDIF act as a bus master
 (rw) (01)  [0;32mENABLE_PXP_HANDSHAKE[0m  - [06:06] -  If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus maste
 r and the handshake mechanism between LCDIF and PXP will be turned on
 (rw) (02)  [0;32mWORD_LENGTH[0m  - [09:08] -  Input data format.
      0 - 16_BIT :
         Input data is 16 bits per pixel.
      0x1 - 8_BIT :
         Input data is 8 bits wide.
      0x2 - 18_BIT :
         Input data is 18 bits per pixel.
      0x3 - 24_BIT :
         Input data is 24 bits per pixel.
 (rw) (02)  [0;32mLCD_DATABUS_WIDTH[0m  - [11:10] -  LCD Data bus transfer width.
      0 - 16_BIT :
         16-bit data bus mode.
      0x1 - 8_BIT :
         8-bit data bus mode.
      0x2 - 18_BIT :
         18-bit data bus mode.
      0x3 - 24_BIT :
         24-bit data bus mode.
 (rw) (02)  [0;32mCSC_DATA_SWIZZLE[0m  - [13:12] -  This field specifies how to swap the bytes after the data has been converted in
 to an internal representation of 24 bits per pixel and before it is transmitted
  over the LCD interface bus
      0 - NO_SWAP :
         No byte swapping.(Little endian)
      0x1 - BIG_ENDIAN_SWAP :
         Big Endian swap (swap bytes 0,3 and 1,2).
      0x2 - HWD_SWAP :
         Swap half-words.
      0x3 - HWD_BYTE_SWAP :
         Swap bytes within each half-word.
 (rw) (02)  [0;32mINPUT_DATA_SWIZZLE[0m  - [15:14] -  This field specifies how to swap the bytes fetched by the bus master interface
      0 - NO_SWAP :
         No byte swapping.(Little endian)
      0x1 - BIG_ENDIAN_SWAP :
         Big Endian swap (swap bytes 0,3 and 1,2).
      0x2 - HWD_SWAP :
         Swap half-words.
      0x3 - HWD_BYTE_SWAP :
         Swap bytes within each half-word.
 (rw) (01)  [0;32mDOTCLK_MODE[0m  - [17:17] -  Set this bit to 1 to make the hardware go into the DOTCLK mode, i
 (rw) (01)  [0;32mBYPASS_COUNT[0m  - [19:19] -  When this bit is 0, it means that LCDIF will stop the block operation and turn 
 off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT 
 register has been transferred out
 (rw) (05)  [0;32mSHIFT_NUM_BITS[0m  - [25:21] -  The data to be transmitted is shifted left or right by this number of bits.
 (rw) (01)  [0;32mDATA_SHIFT_DIR[0m  - [26:26] -  Use this bit to determine the direction of shift of transmit data.
      0 - TXDATA_SHIFT_LEFT :
         Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
      0x1 - TXDATA_SHIFT_RIGHT :
         Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
 (rw) (01)  [0;32mCLKGATE[0m  - [30:30] -  This bit must be set to zero for normal operation
 (rw) (01)  [0;32mSFTRST[0m  - [31:31] -  This bit must be set to zero to enable normal operation of the LCDIF
</lang>
#### p.LCDIF.TRANSFER_COUNT
<lang=dft>
 (rw)  [1;33m0x402b8030[0m (0x402b8000 + 0x0030)
LCDIF Horizontal and Vertical Valid Data Count Register
 (rw) (16)  [0;32mH_COUNT[0m  - [15:00] -  Total valid data (pixels) in each horizontal line
 (rw) (16)  [0;32mV_COUNT[0m  - [31:16] -  Number of horizontal lines per frame which contain valid data
</lang>
#### p.lcdif.cur_buf
<link=p.LCDIF.CUR_BUF>
#### p.LCDIF.VDCTRL0
<lang=dft>
 (rw)  [1;33m0x402b8070[0m (0x402b8000 + 0x0070)
LCDIF VSYNC Mode and Dotclk Mode Control Register0
 (rw) (18)  [0;32mVSYNC_PULSE_WIDTH[0m  - [17:00] -  Number of units for which VSYNC signal is active
 (rw) (01)  [0;32mHALF_LINE_MODE[0m  - [18:18] -  When this bit is 0, the first field (VSYNC period) will end in half a horizonta
 l line and the second field will begin with half a horizontal line
 (rw) (01)  [0;32mHALF_LINE[0m  - [19:19] -  Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIO
 D field plus half the HORIZONTAL_PERIOD field (i
 (rw) (01)  [0;32mVSYNC_PULSE_WIDTH_UNIT[0m  - [20:20] -  Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cy
 cles
 (rw) (01)  [0;32mVSYNC_PERIOD_UNIT[0m  - [21:21] -  Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
 (rw) (01)  [0;32mENABLE_POL[0m  - [24:24] -  Default 0 active low during valid data transfer on each horizontal line.
 (rw) (01)  [0;32mDOTCLK_POL[0m  - [25:25] -  Default is data launched at negative edge of DOTCLK and captured at positive ed
 ge
 (rw) (01)  [0;32mHSYNC_POL[0m  - [26:26] -  Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the 
 rest of the HSYNC period
 (rw) (01)  [0;32mVSYNC_POL[0m  - [27:27] -  Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the 
 rest of the VSYNC period
 (rw) (01)  [0;32mENABLE_PRESENT[0m  - [28:28] -  Setting this bit to 1 will make the hardware generate the ENABLE signal in the 
 DOTCLK mode, thereby making it the true RGB interface along with the remaining 
 three signals VSYNC, HSYNC and DOTCLK
</lang>
#### LCDIF.VDCTRL1
<link=p.LCDIF.VDCTRL1>
#### lcdif.vdctrl4
<link=p.LCDIF.VDCTRL4>
#### p.lcdif.bm_error_stat
<link=p.LCDIF.BM_ERROR_STAT>
#### lcdif.pigeonctrl1_clr
<link=p.LCDIF.PIGEONCTRL1_CLR>
#### LCDIF.PIGEONCTRL2
<link=p.LCDIF.PIGEONCTRL2>
#### p.lcdif.pigeonctrl2_set
<link=p.LCDIF.PIGEONCTRL2_SET>
#### LCDIF.PIGEONCTRL2_TOG
<link=p.LCDIF.PIGEONCTRL2_TOG>
#### p.LCDIF.PIGEON_0_0
<lang=dft>
 (rw)  [1;33m0x402b8800[0m (0x402b8000 + 0x0800)
Panel Interface Signal Generator Register
 (rw) (01)  [0;32mEN[0m  - [00:00] -  Enable pigeon Mode on this signal
 (rw) (01)  [0;32mPOL[0m  - [01:01] -  Polarity of signal output
      0 - ACTIVE_HIGH :
         Normal Signal (Active high)
      0x1 - ACTIVE_LOW :
         Inverted signal (Active low)
 (rw) (02)  [0;32mINC_SEL[0m  - [03:02] -  Event to incrment local counter
      0 - PCLK :
         pclk
      0x1 - LINE :
         Line start pulse
      0x2 - FRAME :
         Frame start pulse
      0x3 - SIG_ANOTHER :
         Use another signal as tick event
 (rw) (04)  [0;32mOFFSET[0m  - [07:04] -  offset on pclk unit
 (rw) (04)  [0;32mMASK_CNT_SEL[0m  - [11:08] -  select global counters as mask condition, use together with MASK_CNT
      0 - HSTATE_CNT :
         pclk counter within one hscan state
      0x1 - HSTATE_CYCLE :
         pclk cycle within one hscan state
      0x2 - VSTATE_CNT :
         line counter within one vscan state
      0x3 - VSTATE_CYCLE :
         line cycle within one vscan state
      0x4 - FRAME_CNT :
         frame counter
      0x5 - FRAME_CYCLE :
         frame cycle
      0x6 - HCNT :
         horizontal counter (pclk counter within one line )
      0x7 - VCNT :
         vertical counter (line counter within one frame)
 (rw) (12)  [0;32mMASK_CNT[0m  - [23:12] -  When the global counter selected through MASK_CNT_SEL matches value in this reg
 , pigeon local counter start ticking
 (rw) (08)  [0;32mSTATE_MASK[0m  - [31:24] -  state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan s
 tates as reference point for local counter to start ticking
      0x1 - FS :
         FRAME SYNC
      0x2 - FB :
         FRAME BEGIN
      0x4 - FD :
         FRAME DATA
      0x8 - FE :
         FRAME END
      0x10 - LS :
         LINE SYNC
      0x20 - LB :
         LINE BEGIN
      0x40 - LD :
         LINE DATA
      0x80 - LE :
         LINE END
</lang>
#### p.lcdif.pigeon_0_0
<link=p.LCDIF.PIGEON_0_0>
#### p.LCDIF.PIGEON_2_2
<lang=dft>
 (rw)  [1;33m0x402b88a0[0m (0x402b8000 + 0x08a0)
Panel Interface Signal Generator Register
 (rw) (04)  [0;32mSIG_LOGIC[0m  - [03:00] -  Logic operation with another signal: DIS/AND/OR/COND
      0 - DIS :
         No logic operation
      0x1 - AND :
         sigout = sig_another AND this_sig
      0x2 - OR :
         sigout = sig_another OR this_sig
      0x3 - MASK :
         mask = sig_another AND other_masks
 (rw) (05)  [0;32mSIG_ANOTHER[0m  - [08:04] -  Select another signal for logic operation or as mask or counter tick event
      0 - CLEAR_USING_MASK :
         Keep active until mask off
</lang>
#### p.lcdif.pigeon_2_2
<link=p.LCDIF.PIGEON_2_2>
#### lcdif.pigeon_2_2
<link=p.LCDIF.PIGEON_2_2>
#### LCDIF.PIGEON_3_1
<link=p.LCDIF.PIGEON_3_1>
#### p.LCDIF.PIGEON_5_0
<lang=dft>
 (rw)  [1;33m0x402b8940[0m (0x402b8000 + 0x0940)
Panel Interface Signal Generator Register
 (rw) (01)  [0;32mEN[0m  - [00:00] -  Enable pigeon Mode on this signal
 (rw) (01)  [0;32mPOL[0m  - [01:01] -  Polarity of signal output
      0 - ACTIVE_HIGH :
         Normal Signal (Active high)
      0x1 - ACTIVE_LOW :
         Inverted signal (Active low)
 (rw) (02)  [0;32mINC_SEL[0m  - [03:02] -  Event to incrment local counter
      0 - PCLK :
         pclk
      0x1 - LINE :
         Line start pulse
      0x2 - FRAME :
         Frame start pulse
      0x3 - SIG_ANOTHER :
         Use another signal as tick event
 (rw) (04)  [0;32mOFFSET[0m  - [07:04] -  offset on pclk unit
 (rw) (04)  [0;32mMASK_CNT_SEL[0m  - [11:08] -  select global counters as mask condition, use together with MASK_CNT
      0 - HSTATE_CNT :
         pclk counter within one hscan state
      0x1 - HSTATE_CYCLE :
         pclk cycle within one hscan state
      0x2 - VSTATE_CNT :
         line counter within one vscan state
      0x3 - VSTATE_CYCLE :
         line cycle within one vscan state
      0x4 - FRAME_CNT :
         frame counter
      0x5 - FRAME_CYCLE :
         frame cycle
      0x6 - HCNT :
         horizontal counter (pclk counter within one line )
      0x7 - VCNT :
         vertical counter (line counter within one frame)
 (rw) (12)  [0;32mMASK_CNT[0m  - [23:12] -  When the global counter selected through MASK_CNT_SEL matches value in this reg
 , pigeon local counter start ticking
 (rw) (08)  [0;32mSTATE_MASK[0m  - [31:24] -  state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan s
 tates as reference point for local counter to start ticking
      0x1 - FS :
         FRAME SYNC
      0x2 - FB :
         FRAME BEGIN
      0x4 - FD :
         FRAME DATA
      0x8 - FE :
         FRAME END
      0x10 - LS :
         LINE SYNC
      0x20 - LB :
         LINE BEGIN
      0x40 - LD :
         LINE DATA
      0x80 - LE :
         LINE END
</lang>
#### LCDIF.PIGEON_6_0
<link=p.LCDIF.PIGEON_6_0>
#### lcdif.pigeon_7_0
<link=p.LCDIF.PIGEON_7_0>
#### p.LCDIF.PIGEON_9_2
<lang=dft>
 (rw)  [1;33m0x402b8a60[0m (0x402b8000 + 0x0a60)
Panel Interface Signal Generator Register
 (rw) (04)  [0;32mSIG_LOGIC[0m  - [03:00] -  Logic operation with another signal: DIS/AND/OR/COND
      0 - DIS :
         No logic operation
      0x1 - AND :
         sigout = sig_another AND this_sig
      0x2 - OR :
         sigout = sig_another OR this_sig
      0x3 - MASK :
         mask = sig_another AND other_masks
 (rw) (05)  [0;32mSIG_ANOTHER[0m  - [08:04] -  Select another signal for logic operation or as mask or counter tick event
      0 - CLEAR_USING_MASK :
         Keep active until mask off
</lang>
#### p.LCDIF.PIGEON_10_0
<lang=dft>
 (rw)  [1;33m0x402b8a80[0m (0x402b8000 + 0x0a80)
Panel Interface Signal Generator Register
 (rw) (01)  [0;32mEN[0m  - [00:00] -  Enable pigeon Mode on this signal
 (rw) (01)  [0;32mPOL[0m  - [01:01] -  Polarity of signal output
      0 - ACTIVE_HIGH :
         Normal Signal (Active high)
      0x1 - ACTIVE_LOW :
         Inverted signal (Active low)
 (rw) (02)  [0;32mINC_SEL[0m  - [03:02] -  Event to incrment local counter
      0 - PCLK :
         pclk
      0x1 - LINE :
         Line start pulse
      0x2 - FRAME :
         Frame start pulse
      0x3 - SIG_ANOTHER :
         Use another signal as tick event
 (rw) (04)  [0;32mOFFSET[0m  - [07:04] -  offset on pclk unit
 (rw) (04)  [0;32mMASK_CNT_SEL[0m  - [11:08] -  select global counters as mask condition, use together with MASK_CNT
      0 - HSTATE_CNT :
         pclk counter within one hscan state
      0x1 - HSTATE_CYCLE :
         pclk cycle within one hscan state
      0x2 - VSTATE_CNT :
         line counter within one vscan state
      0x3 - VSTATE_CYCLE :
         line cycle within one vscan state
      0x4 - FRAME_CNT :
         frame counter
      0x5 - FRAME_CYCLE :
         frame cycle
      0x6 - HCNT :
         horizontal counter (pclk counter within one line )
      0x7 - VCNT :
         vertical counter (line counter within one frame)
 (rw) (12)  [0;32mMASK_CNT[0m  - [23:12] -  When the global counter selected through MASK_CNT_SEL matches value in this reg
 , pigeon local counter start ticking
 (rw) (08)  [0;32mSTATE_MASK[0m  - [31:24] -  state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan s
 tates as reference point for local counter to start ticking
      0x1 - FS :
         FRAME SYNC
      0x2 - FB :
         FRAME BEGIN
      0x4 - FD :
         FRAME DATA
      0x8 - FE :
         FRAME END
      0x10 - LS :
         LINE SYNC
      0x20 - LB :
         LINE BEGIN
      0x40 - LD :
         LINE DATA
      0x80 - LE :
         LINE END
</lang>
#### LCDIF.PIGEON_10_1
<link=p.LCDIF.PIGEON_10_1>
#### CSI.CSISTATFIFO
<link=p.CSI.CSISTATFIFO>
#### CSI.CSIDMASA_STATFIFO
<link=p.CSI.CSIDMASA_STATFIFO>
#### p.csi.csidmasa_fb2
<link=p.CSI.CSIDMASA_FB2>
#### CSI.CSICR19
<link=p.CSI.CSICR19>
#### USDHC1.BLK_ATT
<link=p.USDHC1.BLK_ATT>
#### usdhc1.cmd_rsp2
<link=p.USDHC1.CMD_RSP2>
#### p.usdhc1.host_ctrl_cap
<link=p.USDHC1.HOST_CTRL_CAP>
#### p.USDHC1.MIX_CTRL
<lang=dft>
 (rw)  [1;33m0x402c0048[0m (0x402c0000 + 0x0048)
Mixer Control
 (rw) (01)  [0;32mDMAEN[0m  - [00:00] -  DMA Enable
      0 - DMAEN_0 :
         Disable
      0x1 - DMAEN_1 :
         Enable
 (rw) (01)  [0;32mBCEN[0m  - [01:01] -  Block Count Enable
      0 - BCEN_0 :
         Disable
      0x1 - BCEN_1 :
         Enable
 (rw) (01)  [0;32mAC12EN[0m  - [02:02] -  Auto CMD12 Enable
      0 - AC12EN_0 :
         Disable
      0x1 - AC12EN_1 :
         Enable
 (rw) (01)  [0;32mDDR_EN[0m  - [03:03] -  Dual Data Rate mode selection
 (rw) (01)  [0;32mDTDSEL[0m  - [04:04] -  Data Transfer Direction Select
      0 - DTDSEL_0 :
         Write (Host to Card)
      0x1 - DTDSEL_1 :
         Read (Card to Host)
 (rw) (01)  [0;32mMSBSEL[0m  - [05:05] -  Multi / Single Block Select
      0 - MSBSEL_0 :
         Single Block
      0x1 - MSBSEL_1 :
         Multiple Blocks
 (rw) (01)  [0;32mNIBBLE_POS[0m  - [06:06] -  NIBBLE_POS
 (rw) (01)  [0;32mAC23EN[0m  - [07:07] -  Auto CMD23 Enable
 (rw) (01)  [0;32mEXE_TUNE[0m  - [22:22] -  Execute Tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
      0 - EXE_TUNE_0 :
         Not Tuned or Tuning Completed
      0x1 - EXE_TUNE_1 :
         Execute Tuning
 (rw) (01)  [0;32mSMP_CLK_SEL[0m  - [23:23] -  SMP_CLK_SEL
      0 - SMP_CLK_SEL_0 :
         Fixed clock is used to sample data / cmd
      0x1 - SMP_CLK_SEL_1 :
         Tuned clock is used to sample data / cmd
 (rw) (01)  [0;32mAUTO_TUNE_EN[0m  - [24:24] -  Auto Tuning Enable (Only used for SD3.0, SDR104 mode and and EMMC HS200 mode)
      0 - AUTO_TUNE_EN_0 :
         Disable auto tuning
      0x1 - AUTO_TUNE_EN_1 :
         Enable auto tuning
 (rw) (01)  [0;32mFBCLK_SEL[0m  - [25:25] -  Feedback Clock Source Selection (Only used for SD3.0, SDR104 mode and EMMC HS20
 0 mode)
      0 - FBCLK_SEL_0 :
         Feedback clock comes from the loopback CLK
      0x1 - FBCLK_SEL_1 :
         Feedback clock comes from the ipp_card_clk_out
</lang>
#### USDHC1.MIX_CTRL
<link=p.USDHC1.MIX_CTRL>
#### p.USDHC1.ADMA_ERR_STATUS
<lang=dft>
 (ro)  [1;33m0x402c0054[0m (0x402c0000 + 0x0054)
ADMA Error Status Register
 (ro) (02)  [0;32mADMAES[0m  - [01:00] -  ADMA Error State (when ADMA Error is occurred)
 (ro) (01)  [0;32mADMALME[0m  - [02:02] -  ADMA Length Mismatch Error
      0 - ADMALME_0 :
         No Error
      0x1 - ADMALME_1 :
         Error
 (ro) (01)  [0;32mADMADCE[0m  - [03:03] -  ADMA Descriptor Error
      0 - ADMADCE_0 :
         No Error
      0x1 - ADMADCE_1 :
         Error
</lang>
#### usdhc1.adma_err_status
<link=p.USDHC1.ADMA_ERR_STATUS>
#### USDHC1.ADMA_SYS_ADDR
<link=p.USDHC1.ADMA_SYS_ADDR>
#### usdhc1.tuning_ctrl
<link=p.USDHC1.TUNING_CTRL>
#### p.usdhc2.data_buff_acc_port
<link=p.USDHC2.DATA_BUFF_ACC_PORT>
#### p.USDHC2.PROT_CTRL
<lang=dft>
 (rw)  [1;33m0x402c4028[0m (0x402c4000 + 0x0028)
Protocol Control
 (rw) (01)  [0;32mLCTL[0m  - [00:00] -  LED Control
      0 - LCTL_0 :
         LED off
      0x1 - LCTL_1 :
         LED on
 (rw) (02)  [0;32mDTW[0m  - [02:01] -  Data Transfer Width
      0 - DTW_0 :
         1-bit mode
      0x1 - DTW_1 :
         4-bit mode
      0x2 - DTW_2 :
         8-bit mode
 (rw) (01)  [0;32mD3CD[0m  - [03:03] -  DATA3 as Card Detection Pin
      0 - D3CD_0 :
         DATA3 does not monitor Card Insertion
      0x1 - D3CD_1 :
         DATA3 as Card Detection Pin
 (rw) (02)  [0;32mEMODE[0m  - [05:04] -  Endian Mode
      0 - EMODE_0 :
         Big Endian Mode
      0x1 - EMODE_1 :
         Half Word Big Endian Mode
      0x2 - EMODE_2 :
         Little Endian Mode
 (rw) (01)  [0;32mCDTL[0m  - [06:06] -  Card Detect Test Level
      0 - CDTL_0 :
         Card Detect Test Level is 0, no card inserted
      0x1 - CDTL_1 :
         Card Detect Test Level is 1, card inserted
 (rw) (01)  [0;32mCDSS[0m  - [07:07] -  Card Detect Signal Selection
      0 - CDSS_0 :
         Card Detection Level is selected (for normal purpose).
      0x1 - CDSS_1 :
         Card Detection Test Level is selected (for test purpose).
 (rw) (02)  [0;32mDMASEL[0m  - [09:08] -  DMA Select
      0 - DMASEL_0 :
         No DMA or Simple DMA is selected
      0x1 - DMASEL_1 :
         ADMA1 is selected
      0x2 - DMASEL_2 :
         ADMA2 is selected
 (rw) (01)  [0;32mSABGREQ[0m  - [16:16] -  Stop At Block Gap Request
      0 - SABGREQ_0 :
         Transfer
      0x1 - SABGREQ_1 :
         Stop
 (rw) (01)  [0;32mCREQ[0m  - [17:17] -  Continue Request
      0 - CREQ_0 :
         No effect
      0x1 - CREQ_1 :
         Restart
 (rw) (01)  [0;32mRWCTL[0m  - [18:18] -  Read Wait Control
      0 - RWCTL_0 :
         Disable Read Wait Control, and stop SD Clock at block gap when SABGREQ 
         bit is set
      0x1 - RWCTL_1 :
         Enable Read Wait Control, and assert Read Wait without stopping SD Cloc
         k at block gap when SABGREQ bit is set
 (rw) (01)  [0;32mIABG[0m  - [19:19] -  Interrupt At Block Gap
      0 - IABG_0 :
         Disabled
      0x1 - IABG_1 :
         Enabled
 (rw) (01)  [0;32mRD_DONE_NO_8CLK[0m  - [20:20] -  RD_DONE_NO_8CLK
 (rw) (01)  [0;32mWECINT[0m  - [24:24] -  Wakeup Event Enable On Card Interrupt
      0 - WECINT_0 :
         Disable
      0x1 - WECINT_1 :
         Enable
 (rw) (01)  [0;32mWECINS[0m  - [25:25] -  Wakeup Event Enable On SD Card Insertion
      0 - WECINS_0 :
         Disable
      0x1 - WECINS_1 :
         Enable
 (rw) (01)  [0;32mWECRM[0m  - [26:26] -  Wakeup Event Enable On SD Card Removal
      0 - WECRM_0 :
         Disable
      0x1 - WECRM_1 :
         Enable
 (rw) (03)  [0;32mBURST_LEN_EN[0m  - [29:27] -  BURST length enable for INCR, INCR4 / INCR8 / INCR16, INCR4-WRAP / INCR8-WRAP /
  INCR16-WRAP
      #xx1 - BURST_LEN_EN_1 :
         Burst length is enabled for INCR
 (rw) (01)  [0;32mNON_EXACT_BLK_RD[0m  - [30:30] -  NON_EXACT_BLK_RD
      0 - NON_EXACT_BLK_RD_0 :
         The block read is exact block read. Host driver doesn't need to issue a
         bort command to terminate this multi-block read.
      0x1 - NON_EXACT_BLK_RD_1 :
         The block read is non-exact block read. Host driver needs to issue abor
         t command to terminate this multi-block read.
</lang>
#### usdhc2.int_signal_en
<link=p.USDHC2.INT_SIGNAL_EN>
#### USDHC2.INT_SIGNAL_EN
<link=p.USDHC2.INT_SIGNAL_EN>
#### p.usdhc2.host_ctrl_cap
<link=p.USDHC2.HOST_CTRL_CAP>
#### p.usdhc2.wtmk_lvl
<link=p.USDHC2.WTMK_LVL>
#### p.USDHC2.ADMA_ERR_STATUS
<lang=dft>
 (ro)  [1;33m0x402c4054[0m (0x402c4000 + 0x0054)
ADMA Error Status Register
 (ro) (02)  [0;32mADMAES[0m  - [01:00] -  ADMA Error State (when ADMA Error is occurred)
 (ro) (01)  [0;32mADMALME[0m  - [02:02] -  ADMA Length Mismatch Error
      0 - ADMALME_0 :
         No Error
      0x1 - ADMALME_1 :
         Error
 (ro) (01)  [0;32mADMADCE[0m  - [03:03] -  ADMA Descriptor Error
      0 - ADMADCE_0 :
         No Error
      0x1 - ADMADCE_1 :
         Error
</lang>
#### USDHC2.TUNING_CTRL
<link=p.USDHC2.TUNING_CTRL>
#### p.ENET.MMFR
<lang=dft>
 (rw)  [1;33m0x402d8040[0m (0x402d8000 + 0x0040)
MII Management Frame Register
 (rw) (16)  [0;32mDATA[0m  - [15:00] -  Management Frame Data
 (rw) (02)  [0;32mTA[0m  - [17:16] -  Turn Around
 (rw) (05)  [0;32mRA[0m  - [22:18] -  Register Address
 (rw) (05)  [0;32mPA[0m  - [27:23] -  PHY Address
 (rw) (02)  [0;32mOP[0m  - [29:28] -  Operation Code
 (rw) (02)  [0;32mST[0m  - [31:30] -  Start Of Frame Delimiter
</lang>
#### p.enet.mmfr
<link=p.ENET.MMFR>
#### ENET.PAUR
<link=p.ENET.PAUR>
#### ENET.TXIC
<link=p.ENET.TXIC>
#### p.ENET.MRBR
<lang=dft>
 (rw)  [1;33m0x402d8188[0m (0x402d8000 + 0x0188)
Maximum Receive Buffer Size Register
 (rw) (10)  [0;32mR_BUF_SIZE[0m  - [13:04] -  Receive buffer size in bytes
</lang>
#### p.enet.rafl
<link=p.ENET.RAFL>
#### p.ENET.TAFL
<lang=dft>
 (rw)  [1;33m0x402d81a8[0m (0x402d8000 + 0x01a8)
Transmit FIFO Almost Full Threshold
 (rw) (08)  [0;32mTX_ALMOST_FULL[0m  - [07:00] -  Value Of The Transmit FIFO Almost Full Threshold
</lang>
#### p.ENET.TIPG
<lang=dft>
 (rw)  [1;33m0x402d81ac[0m (0x402d8000 + 0x01ac)
Transmit Inter-Packet Gap
 (rw) (05)  [0;32mIPG[0m  - [04:00] -  Transmit Inter-Packet Gap
</lang>
#### p.enet.racc
<link=p.ENET.RACC>
#### ENET.RMON_T_BC_PKT
<link=p.ENET.RMON_T_BC_PKT>
#### ENET.RMON_T_MC_PKT
<link=p.ENET.RMON_T_MC_PKT>
#### enet.rmon_t_crc_align
<link=p.ENET.RMON_T_CRC_ALIGN>
#### p.ENET.RMON_T_UNDERSIZE
<lang=dft>
 (ro)  [1;33m0x402d8214[0m (0x402d8000 + 0x0214)
Tx Packets Less Than Bytes and Good CRC Statistic Register
 (ro) (16)  [0;32mTXPKTS[0m  - [15:00] -  Number of transmit packets less than 64 bytes with good CRC
</lang>
#### p.ENET.RMON_T_OVERSIZE
<lang=dft>
 (ro)  [1;33m0x402d8218[0m (0x402d8000 + 0x0218)
Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
 (ro) (16)  [0;32mTXPKTS[0m  - [15:00] -  Number of transmit packets greater than MAX_FL bytes with good CRC
</lang>
#### ENET.RMON_T_OVERSIZE
<link=p.ENET.RMON_T_OVERSIZE>
#### p.enet.rmon_t_col
<link=p.ENET.RMON_T_COL>
#### p.enet.rmon_t_p64
<link=p.ENET.RMON_T_P64>
#### p.ENET.RMON_T_P_GTE2048
<lang=dft>
 (ro)  [1;33m0x402d8240[0m (0x402d8000 + 0x0240)
Tx Packets Greater Than 2048 Bytes Statistic Register
 (ro) (16)  [0;32mTXPKTS[0m  - [15:00] -  Number of transmit packets greater than 2048 bytes
</lang>
#### enet.rmon_t_octets
<link=p.ENET.RMON_T_OCTETS>
#### ENET.IEEE_T_DEF
<link=p.ENET.IEEE_T_DEF>
#### p.enet.ieee_t_macerr
<link=p.ENET.IEEE_T_MACERR>
#### ENET.RMON_R_CRC_ALIGN
<link=p.ENET.RMON_R_CRC_ALIGN>
#### p.enet.rmon_r_oversize
<link=p.ENET.RMON_R_OVERSIZE>
#### p.ENET.RMON_R_P512TO1023
<lang=dft>
 (ro)  [1;33m0x402d82b8[0m (0x402d8000 + 0x02b8)
Rx 512- to 1023-Byte Packets Statistic Register
 (ro) (16)  [0;32mCOUNT[0m  - [15:00] -  Number of 512- to 1023-byte recieve packets
</lang>
#### enet.rmon_r_p1024to2047
<link=p.ENET.RMON_R_P1024TO2047>
#### p.enet.rmon_r_p_gte2048
<link=p.ENET.RMON_R_P_GTE2048>
#### p.enet.ieee_r_frame_ok
<link=p.ENET.IEEE_R_FRAME_OK>
#### p.enet2.eir
<link=p.ENET2.EIR>
#### p.ENET2.EIMR
<lang=dft>
 (rw)  [1;33m0x402d4008[0m (0x402d4000 + 0x0008)
Interrupt Mask Register
 (rw) (01)  [0;32mTS_TIMER[0m  - [15:15] -  TS_TIMER Interrupt Mask
 (rw) (01)  [0;32mTS_AVAIL[0m  - [16:16] -  TS_AVAIL Interrupt Mask
 (rw) (01)  [0;32mWAKEUP[0m  - [17:17] -  WAKEUP Interrupt Mask
 (rw) (01)  [0;32mPLR[0m  - [18:18] -  PLR Interrupt Mask
 (rw) (01)  [0;32mUN[0m  - [19:19] -  UN Interrupt Mask
 (rw) (01)  [0;32mRL[0m  - [20:20] -  RL Interrupt Mask
 (rw) (01)  [0;32mLC[0m  - [21:21] -  LC Interrupt Mask
 (rw) (01)  [0;32mEBERR[0m  - [22:22] -  EBERR Interrupt Mask
 (rw) (01)  [0;32mMII[0m  - [23:23] -  MII Interrupt Mask
 (rw) (01)  [0;32mRXB[0m  - [24:24] -  RXB Interrupt Mask
 (rw) (01)  [0;32mRXF[0m  - [25:25] -  RXF Interrupt Mask
 (rw) (01)  [0;32mTXB[0m  - [26:26] -  TXB Interrupt Mask
      0 - TXB_0 :
         The corresponding interrupt source is masked.
      0x1 - TXB_1 :
         The corresponding interrupt source is not masked.
 (rw) (01)  [0;32mTXF[0m  - [27:27] -  TXF Interrupt Mask
      0 - TXF_0 :
         The corresponding interrupt source is masked.
      0x1 - TXF_1 :
         The corresponding interrupt source is not masked.
 (rw) (01)  [0;32mGRA[0m  - [28:28] -  GRA Interrupt Mask
      0 - GRA_0 :
         The corresponding interrupt source is masked.
      0x1 - GRA_1 :
         The corresponding interrupt source is not masked.
 (rw) (01)  [0;32mBABT[0m  - [29:29] -  BABT Interrupt Mask
      0 - BABT_0 :
         The corresponding interrupt source is masked.
      0x1 - BABT_1 :
         The corresponding interrupt source is not masked.
 (rw) (01)  [0;32mBABR[0m  - [30:30] -  BABR Interrupt Mask
      0 - BABR_0 :
         The corresponding interrupt source is masked.
      0x1 - BABR_1 :
         The corresponding interrupt source is not masked.
</lang>
#### enet2.eimr
<link=p.ENET2.EIMR>
#### enet2.rcr
<link=p.ENET2.RCR>
#### enet2.paur
<link=p.ENET2.PAUR>
#### p.enet2.txic
<link=p.ENET2.TXIC>
#### p.ENET2.GALR
<lang=dft>
 (rw)  [1;33m0x402d4124[0m (0x402d4000 + 0x0124)
Descriptor Group Lower Address Register
 (rw) (32)  [0;32mGADDR2[0m  - [31:00] -  Contains the lower 32 bits of the 64-bit hash table used in the address recogni
 tion process for receive frames with a multicast address
</lang>
#### ENET2.RSEM
<link=p.ENET2.RSEM>
#### p.enet2.raem
<link=p.ENET2.RAEM>
#### p.enet2.tsem
<link=p.ENET2.TSEM>
#### p.ENET2.FTRL
<lang=dft>
 (rw)  [1;33m0x402d41b0[0m (0x402d4000 + 0x01b0)
Frame Truncation Length
 (rw) (14)  [0;32mTRUNC_FL[0m  - [13:00] -  Frame Truncation Length
</lang>
#### p.enet2.rmon_t_oversize
<link=p.ENET2.RMON_T_OVERSIZE>
#### enet2.rmon_t_oversize
<link=p.ENET2.RMON_T_OVERSIZE>
#### ENET2.RMON_T_P64
<link=p.ENET2.RMON_T_P64>
#### enet2.ieee_t_1col
<link=p.ENET2.IEEE_T_1COL>
#### enet2.rmon_r_bc_pkt
<link=p.ENET2.RMON_R_BC_PKT>
#### enet2.rmon_r_jab
<link=p.ENET2.RMON_R_JAB>
#### p.ENET2.RMON_R_P128TO255
<lang=dft>
 (ro)  [1;33m0x402d42b0[0m (0x402d4000 + 0x02b0)
Rx 128- to 255-Byte Packets Statistic Register
 (ro) (16)  [0;32mCOUNT[0m  - [15:00] -  Number of 128- to 255-byte recieve packets
</lang>
#### enet2.ieee_r_frame_ok
<link=p.ENET2.IEEE_R_FRAME_OK>
#### enet2.atoff
<link=p.ENET2.ATOFF>
#### ENET2.TCSR1
<link=p.ENET2.TCSR1>
#### p.ENET2.TCCR3
<lang=dft>
 (rw)  [1;33m0x402d4624[0m (0x402d4000 + 0x0624)
Timer Compare Capture Register
 (rw) (32)  [0;32mTCC[0m  - [31:00] -  Timer Capture Compare
</lang>
#### p.USB1.GPTIMER0LD
<lang=dft>
 (rw)  [1;33m0x402e0080[0m (0x402e0000 + 0x0080)
General Purpose Timer #0 Load
 (rw) (24)  [0;32mGPTLD[0m  - [23:00] -  General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits whe
 n GPTRST bit is set '1b'
</lang>
#### p.USB1.SBUSCFG
<lang=dft>
 (rw)  [1;33m0x402e0090[0m (0x402e0000 + 0x0090)
System Bus Config
 (rw) (03)  [0;32mAHBBRST[0m  - [02:00] -  AHB master interface Burst configuration These bits control AHB master transfer
  type sequence (or priority)
      0 - AHBBRST_0 :
         Incremental burst of unspecified length only
      0x1 - AHBBRST_1 :
         INCR4 burst, then single transfer
      0x2 - AHBBRST_2 :
         INCR8 burst, INCR4 burst, then single transfer
      0x3 - AHBBRST_3 :
         INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
      0x5 - AHBBRST_5 :
         INCR4 burst, then incremental burst of unspecified length
      0x6 - AHBBRST_6 :
         INCR8 burst, INCR4 burst, then incremental burst of unspecified length
      0x7 - AHBBRST_7 :
         INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspe
         cified length
</lang>
#### p.USB1.HCSPARAMS
<lang=dft>
 (ro)  [1;33m0x402e0104[0m (0x402e0000 + 0x0104)
Host Controller Structural Parameters
 (ro) (04)  [0;32mN_PORTS[0m  - [03:00] -  Number of downstream ports
 (ro) (01)  [0;32mPPC[0m  - [04:04] -  Port Power Control This field indicates whether the host controller implementat
 ion includes port power control
 (ro) (04)  [0;32mN_PCC[0m  - [11:08] -  Number of Ports per Companion Controller This field indicates the number of por
 ts supported per internal Companion Controller
 (ro) (04)  [0;32mN_CC[0m  - [15:12] -  Number of Companion Controller (N_CC)
      0 - N_CC_0 :
         There is no internal Companion Controller and port-ownership hand-off i
         s not supported.
      0x1 - N_CC_1 :
         There are internal companion controller(s) and port-ownership hand-offs
          is supported.
 (ro) (01)  [0;32mPI[0m  - [16:16] -  Port Indicators (P INDICATOR) This bit indicates whether the ports support port
  indicator control
 (ro) (04)  [0;32mN_PTT[0m  - [23:20] -  Number of Ports per Transaction Translator (N_PTT)
 (ro) (04)  [0;32mN_TT[0m  - [27:24] -  Number of Transaction Translators (N_TT)
</lang>
#### p.USB1.DCIVERSION
<lang=dft>
 (ro)  [1;33m0x402e0120[0m (0x402e0000 + 0x0120)
Device Controller Interface Version
 (ro) (16)  [0;32mDCIVERSION[0m  - [15:00] -  Device Controller Interface Version Number Default value is '01h', which means 
 rev0.1.
</lang>
#### usb1.dciversion
<link=p.USB1.DCIVERSION>
#### USB1.BURSTSIZE
<link=p.USB1.BURSTSIZE>
#### p.usb1.endptnak
<link=p.USB1.ENDPTNAK>
#### p.usb1.portsc1
<link=p.USB1.PORTSC1>
#### usb1.endptcomplete
<link=p.USB1.ENDPTCOMPLETE>
#### usb1.endptctrl2
<link=p.USB1.ENDPTCTRL2>
#### p.usb1.endptctrl5
<link=p.USB1.ENDPTCTRL5>
#### p.USB1.ENDPTCTRL6
<lang=dft>
 (rw)  [1;33m0x402e01d8[0m (0x402e0000 + 0x01d8)
Endpoint Control 6
 (rw) (01)  [0;32mRXS[0m  - [00:00] -  RX Endpoint Stall - Read/Write 0 End Point OK
 (rw) (01)  [0;32mRXD[0m  - [01:01] -  RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Defaul
 t] Should always be written as zero
 (rw) (02)  [0;32mRXT[0m  - [03:02] -  RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
 (rw) (01)  [0;32mRXI[0m  - [05:05] -  RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for
  test and should always be written as zero
 (rw) (01)  [0;32mRXR[0m  - [06:06] -  RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration
  event is received for this Endpoint, software must write a one to this bit in 
 order to synchronize the data PID's between the host and device
 (rw) (01)  [0;32mRXE[0m  - [07:07] -  RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled
  only after it has been configured
 (rw) (01)  [0;32mTXS[0m  - [16:16] -  TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will
  be cleared automatically upon receipt of a SETUP request if this Endpoint is c
 onfigured as a Control Endpoint and this bit will continue to be cleared by har
 dware until the associated ENDPTSETUPSTAT bit is cleared
 (rw) (01)  [0;32mTXD[0m  - [17:17] -  TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFA
 ULT] Should always be written as 0
 (rw) (02)  [0;32mTXT[0m  - [19:18] -  TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
 (rw) (01)  [0;32mTXI[0m  - [21:21] -  TX Data Toggle Inhibit 0 PID Sequencing Enabled
 (rw) (01)  [0;32mTXR[0m  - [22:22] -  TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration
  event is received for this Endpoint, software must write a one to this bit in 
 order to synchronize the data PID's between the Host and device
 (rw) (01)  [0;32mTXE[0m  - [23:23] -  TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled
  only after it has been configured
</lang>
#### USB1.ENDPTCTRL7
<link=p.USB1.ENDPTCTRL7>
#### p.usb2
<link=p.USB2>
#### usb2.hwtxbuf
<link=p.USB2.HWTXBUF>
#### usb2.gptimer0ctrl
<link=p.USB2.GPTIMER0CTRL>
#### p.USB2.GPTIMER1CTRL
<lang=dft>
 (rw)  [1;33m0x402e028c[0m (0x402e0200 + 0x008c)
General Purpose Timer #1 Controller
 (rw) (24)  [0;32mGPTCNT[0m  - [23:00] -  General Purpose Timer Counter. This field is the count value of the countdown t
 imer.
 (rw) (01)  [0;32mGPTMODE[0m  - [24:24] -  General Purpose Timer Mode In one shot mode, the timer will count down to zero,
  generate an interrupt, and stop until the counter is reset by software
      0 - GPTMODE_0 :
         One Shot Mode
      0x1 - GPTMODE_1 :
         Repeat Mode
 (rw) (01)  [0;32mGPTRST[0m  - [30:30] -  General Purpose Timer Reset
      0 - GPTRST_0 :
         No action
      0x1 - GPTRST_1 :
         Load counter value from GPTLD bits in USB_n_GPTIMER0LD
 (rw) (01)  [0;32mGPTRUN[0m  - [31:31] -  General Purpose Timer Run GPTCNT bits are not effected when setting or clearing
  this bit.
      0 - GPTRUN_0 :
         Stop counting
      0x1 - GPTRUN_1 :
         Run
</lang>
#### p.usb2.periodiclistbase
<link=p.USB2.PERIODICLISTBASE>
#### p.usb2.asynclistaddr
<link=p.USB2.ASYNCLISTADDR>
#### USB2.ENDPTLISTADDR
<link=p.USB2.ENDPTLISTADDR>
#### p.USB2.ENDPTFLUSH
<lang=dft>
 (rw)  [1;33m0x402e03b4[0m (0x402e0200 + 0x01b4)
Endpoint Flush
 (rw) (08)  [0;32mFERB[0m  - [07:00] -  Flush Endpoint Receive Buffer - R/WS
 (rw) (08)  [0;32mFETB[0m  - [23:16] -  Flush Endpoint Transmit Buffer - R/WS
</lang>
#### p.usb2.endptctrl3
<link=p.USB2.ENDPTCTRL3>
#### usbnc2.usb_otg1_phy_ctrl_0
<link=p.USBNC2.USB_OTG1_PHY_CTRL_0>
#### p.SEMC.BR7
<lang=dft>
 (rw)  [1;33m0x402f002c[0m (0x402f0000 + 0x002c)
Base Register 7 (For DBI-B (MIPI Display Bus Interface Type B) device)
 (rw) (01)  [0;32mVLD[0m  - [00:00] -  Valid
 (rw) (05)  [0;32mMS[0m  - [05:01] -  Memory size
      0 - MS_0 :
         4KB
      0x1 - MS_1 :
         8KB
      0x2 - MS_2 :
         16KB
      0x3 - MS_3 :
         32KB
      0x4 - MS_4 :
         64KB
      0x5 - MS_5 :
         128KB
      0x6 - MS_6 :
         256KB
      0x7 - MS_7 :
         512KB
      0x8 - MS_8 :
         1MB
      0x9 - MS_9 :
         2MB
      0xA - MS_10 :
         4MB
      0xB - MS_11 :
         8MB
      0xC - MS_12 :
         16MB
      0xD - MS_13 :
         32MB
      0xE - MS_14 :
         64MB
      0xF - MS_15 :
         128MB
      0x10 - MS_16 :
         256MB
      0x11 - MS_17 :
         512MB
      0x12 - MS_18 :
         1GB
      0x13 - MS_19 :
         2GB
      0x14 - MS_20 :
         4GB
      0x15 - MS_21 :
         4GB
      0x16 - MS_22 :
         4GB
      0x17 - MS_23 :
         4GB
      0x18 - MS_24 :
         4GB
      0x19 - MS_25 :
         4GB
      0x1A - MS_26 :
         4GB
      0x1B - MS_27 :
         4GB
      0x1C - MS_28 :
         4GB
      0x1D - MS_29 :
         4GB
      0x1E - MS_30 :
         4GB
      0x1F - MS_31 :
         4GB
 (rw) (20)  [0;32mBA[0m  - [31:12] -  Base Address
</lang>
#### semc.sdramcr3
<link=p.SEMC.SDRAMCR3>
#### semc.nandcr2
<link=p.SEMC.NANDCR2>
#### semc.sramcr0
<link=p.SEMC.SRAMCR0>
#### p.SEMC.IPCR1
<lang=dft>
 (rw)  [1;33m0x402f0094[0m (0x402f0000 + 0x0094)
IP Command control register 1
 (rw) (03)  [0;32mDATSZ[0m  - [02:00] -  Data Size in Byte
      0 - DATSZ_0 :
         4
      0x1 - DATSZ_1 :
         1
      0x2 - DATSZ_2 :
         2
      0x3 - DATSZ_3 :
         3
      0x4 - DATSZ_4 :
         4
      0x5 - DATSZ_5 :
         4
      0x6 - DATSZ_6 :
         4
      0x7 - DATSZ_7 :
         4
 (rw) (08)  [0;32mNAND_EXT_ADDR[0m  - [15:08] -  NAND Extended Address
</lang>
#### semc.sts5
<link=p.SEMC.STS5>
#### p.SEMC.STS6
<lang=dft>
 (ro)  [1;33m0x402f00d8[0m (0x402f0000 + 0x00d8)
Status register 6
</lang>
#### SEMC.STS7
<link=p.SEMC.STS7>
#### p.semc.sts9
<link=p.SEMC.STS9>
#### DCP.CTRL
<link=p.DCP.CTRL>
#### DCP.CHANNELCTRL
<link=p.DCP.CHANNELCTRL>
#### dcp.capability1
<link=p.DCP.CAPABILITY1>
#### p.dcp.packet5
<link=p.DCP.PACKET5>
#### dcp.packet5
<link=p.DCP.PACKET5>
#### DCP.PACKET6
<link=p.DCP.PACKET6>
#### p.DCP.CH0CMDPTR
<lang=dft>
 (rw)  [1;33m0x402fc100[0m (0x402fc000 + 0x0100)
DCP channel 0 command pointer address register
 (rw) (32)  [0;32mADDR[0m  - [31:00] -  Pointer to the descriptor structure to be processed for channel 0.
</lang>
#### DCP.CH0CMDPTR
<link=p.DCP.CH0CMDPTR>
#### dcp.ch0sema
<link=p.DCP.CH0SEMA>
#### dcp.ch1opts_tog
<link=p.DCP.CH1OPTS_TOG>
#### dcp.ch2stat
<link=p.DCP.CH2STAT>
#### dcp.ch2stat_tog
<link=p.DCP.CH2STAT_TOG>
#### dcp.ch3stat
<link=p.DCP.CH3STAT>
#### p.DCP.CH3OPTS
<lang=dft>
 (rw)  [1;33m0x402fc1f0[0m (0x402fc000 + 0x01f0)
DCP channel 3 options register
 (rw) (16)  [0;32mRECOVERY_TIMER[0m  - [15:00] -  This field indicates the recovery time for the channel
</lang>
#### p.spdif.stcsch
<link=p.SPDIF.STCSCH>
#### spdif.stcsch
<link=p.SPDIF.STCSCH>
#### p.spdif.srfm
<link=p.SPDIF.SRFM>
#### p.SAI1.PARAM
<lang=dft>
 (ro)  [1;33m0x40384004[0m (0x40384000 + 0x0004)
Parameter Register
 (ro) (04)  [0;32mDATALINE[0m  - [03:00] -  Number of Datalines
 (ro) (04)  [0;32mFIFO[0m  - [11:08] -  FIFO Size
 (ro) (04)  [0;32mFRAME[0m  - [19:16] -  Frame Size
</lang>
#### sai1.tcsr
<link=p.SAI1.TCSR>
#### sai1.tcr1
<link=p.SAI1.TCR1>
#### p.sai1.tdr[2]
<link=p.SAI1.TDR[2]>
#### SAI1.TFR[0]
<link=p.SAI1.TFR[0]>
#### sai1.tfr[3]
<link=p.SAI1.TFR[3]>
#### p.SAI1.RCSR
<lang=dft>
 (rw)  [1;33m0x40384088[0m (0x40384000 + 0x0088)
SAI Receive Control Register
 (rw) (01)  [0;32mFRDE[0m  - [00:00] -  FIFO Request DMA Enable
      0 - FRDE_0 :
         Disables the DMA request.
      0x1 - FRDE_1 :
         Enables the DMA request.
 (rw) (01)  [0;32mFWDE[0m  - [01:01] -  FIFO Warning DMA Enable
      0 - FWDE_0 :
         Disables the DMA request.
      0x1 - FWDE_1 :
         Enables the DMA request.
 (rw) (01)  [0;32mFRIE[0m  - [08:08] -  FIFO Request Interrupt Enable
      0 - FRIE_0 :
         Disables the interrupt.
      0x1 - FRIE_1 :
         Enables the interrupt.
 (rw) (01)  [0;32mFWIE[0m  - [09:09] -  FIFO Warning Interrupt Enable
      0 - FWIE_0 :
         Disables the interrupt.
      0x1 - FWIE_1 :
         Enables the interrupt.
 (rw) (01)  [0;32mFEIE[0m  - [10:10] -  FIFO Error Interrupt Enable
      0 - FEIE_0 :
         Disables the interrupt.
      0x1 - FEIE_1 :
         Enables the interrupt.
 (rw) (01)  [0;32mSEIE[0m  - [11:11] -  Sync Error Interrupt Enable
      0 - SEIE_0 :
         Disables interrupt.
      0x1 - SEIE_1 :
         Enables interrupt.
 (rw) (01)  [0;32mWSIE[0m  - [12:12] -  Word Start Interrupt Enable
      0 - WSIE_0 :
         Disables interrupt.
      0x1 - WSIE_1 :
         Enables interrupt.
 (ro) (01)  [0;32mFRF[0m  - [16:16] -  FIFO Request Flag
      0 - FRF_0 :
         Receive FIFO watermark not reached.
      0x1 - FRF_1 :
         Receive FIFO watermark has been reached.
 (ro) (01)  [0;32mFWF[0m  - [17:17] -  FIFO Warning Flag
      0 - FWF_0 :
         No enabled receive FIFO is full.
      0x1 - FWF_1 :
         Enabled receive FIFO is full.
 (rw) (01)  [0;32mFEF[0m  - [18:18] -  FIFO Error Flag
      0 - FEF_0 :
         Receive overflow not detected.
      0x1 - FEF_1 :
         Receive overflow detected.
 (rw) (01)  [0;32mSEF[0m  - [19:19] -  Sync Error Flag
      0 - SEF_0 :
         Sync error not detected.
      0x1 - SEF_1 :
         Frame sync error detected.
 (rw) (01)  [0;32mWSF[0m  - [20:20] -  Word Start Flag
      0 - WSF_0 :
         Start of word not detected.
      0x1 - WSF_1 :
         Start of word detected.
 (rw) (01)  [0;32mSR[0m  - [24:24] -  Software Reset
      0 - SR_0 :
         No effect.
      0x1 - SR_1 :
         Software reset.
 (rw) (01)  [0;32mFR[0m  - [25:25] -  FIFO Reset
      0 - FR_0 :
         No effect.
      0x1 - FR_1 :
         FIFO reset.
 (rw) (01)  [0;32mBCE[0m  - [28:28] -  Bit Clock Enable
      0 - BCE_0 :
         Receive bit clock is disabled.
      0x1 - BCE_1 :
         Receive bit clock is enabled.
 (rw) (01)  [0;32mDBGE[0m  - [29:29] -  Debug Enable
      0 - DBGE_0 :
         Receiver is disabled in Debug mode, after completing the current frame.
      0x1 - DBGE_1 :
         Receiver is enabled in Debug mode.
 (rw) (01)  [0;32mSTOPE[0m  - [30:30] -  Stop Enable
      0 - STOPE_0 :
         Receiver disabled in Stop mode.
      0x1 - STOPE_1 :
         Receiver enabled in Stop mode.
 (rw) (01)  [0;32mRE[0m  - [31:31] -  Receiver Enable
      0 - RE_0 :
         Receiver is disabled.
      0x1 - RE_1 :
         Receiver is enabled, or receiver has been disabled and has not yet reac
         hed end of frame.
</lang>
#### sai1.rcr2
<link=p.SAI1.RCR2>
#### p.SAI1.RDR[3]
<lang=dft>
 (ro)  [1;33m0x403840ac[0m (0x40384000 + 0x00ac)
SAI Receive Data Register
 (ro) (32)  [0;32mRDR[0m  - [31:00] -  Receive Data Register
</lang>
#### sai2.tcr5
<link=p.SAI2.TCR5>
#### SAI2.TCR5
<link=p.SAI2.TCR5>
#### p.sai2.tdr[2]
<link=p.SAI2.TDR[2]>
#### SAI2.TFR[0]
<link=p.SAI2.TFR[0]>
#### p.SAI2.TFR[2]
<lang=dft>
 (ro)  [1;33m0x40388048[0m (0x40388000 + 0x0048)
SAI Transmit FIFO Register
 (ro) (06)  [0;32mRFP[0m  - [05:00] -  Read FIFO Pointer
 (ro) (06)  [0;32mWFP[0m  - [21:16] -  Write FIFO Pointer
 (ro) (01)  [0;32mWCP[0m  - [31:31] -  Write Channel Pointer
      0 - WCP_0 :
         No effect.
      0x1 - WCP_1 :
         FIFO combine is enabled for FIFO writes and this FIFO will be written o
         n the next FIFO write.
</lang>
#### SAI2.RDR[3]
<link=p.SAI2.RDR[3]>
#### p.SAI2.RFR[1]
<lang=dft>
 (ro)  [1;33m0x403880c4[0m (0x40388000 + 0x00c4)
SAI Receive FIFO Register
 (ro) (06)  [0;32mRFP[0m  - [05:00] -  Read FIFO Pointer
 (ro) (01)  [0;32mRCP[0m  - [15:15] -  Receive Channel Pointer
      0 - RCP_0 :
         No effect.
      0x1 - RCP_1 :
         FIFO combine is enabled for FIFO reads and this FIFO will be read on th
         e next FIFO read.
 (ro) (06)  [0;32mWFP[0m  - [21:16] -  Write FIFO Pointer
</lang>
#### sai2.rfr[1]
<link=p.SAI2.RFR[1]>
#### p.SAI3.VERID
<lang=dft>
 (ro)  [1;33m0x4038c000[0m (0x4038c000 + 0x0000)
Version ID Register
 (ro) (16)  [0;32mFEATURE[0m  - [15:00] -  Feature Specification Number
      0 - FEATURE_0 :
         Standard feature set.
 (ro) (08)  [0;32mMINOR[0m  - [23:16] -  Minor Version Number
 (ro) (08)  [0;32mMAJOR[0m  - [31:24] -  Major Version Number
</lang>
#### SAI3.TCR2
<link=p.SAI3.TCR2>
#### SAI3.TFR[1]
<link=p.SAI3.TFR[1]>
#### p.sai3.rcr1
<link=p.SAI3.RCR1>
#### SAI3.RDR[2]
<link=p.SAI3.RDR[2]>
#### p.SAI3.RMR
<lang=dft>
 (rw)  [1;33m0x4038c0e0[0m (0x4038c000 + 0x00e0)
SAI Receive Mask Register
 (rw) (32)  [0;32mRWM[0m  - [31:00] -  Receive Word Mask
      0 - RWM_0 :
         Word N is enabled.
      0x1 - RWM_1 :
         Word N is masked.
</lang>
#### p.lpspi1.verid
<link=p.LPSPI1.VERID>
#### LPSPI1.DER
<link=p.LPSPI1.DER>
#### p.lpspi1.cfgr1
<link=p.LPSPI1.CFGR1>
#### lpspi2.param
<link=p.LPSPI2.PARAM>
#### p.lpspi2.ier
<link=p.LPSPI2.IER>
#### p.LPSPI2.CFGR0
<lang=dft>
 (rw)  [1;33m0x40398020[0m (0x40398000 + 0x0020)
Configuration Register 0
 (rw) (01)  [0;32mHREN[0m  - [00:00] -  Host Request Enable
      0 - HREN_0 :
         Host request is disabled
      0x1 - HREN_1 :
         Host request is enabled
 (rw) (01)  [0;32mHRPOL[0m  - [01:01] -  Host Request Polarity
      0 - HRPOL_0 :
         Active low
      0x1 - HRPOL_1 :
         Active high
 (rw) (01)  [0;32mHRSEL[0m  - [02:02] -  Host Request Select
      0 - HRSEL_0 :
         Host request input is the LPSPI_HREQ pin
      0x1 - HRSEL_1 :
         Host request input is the input trigger
 (rw) (01)  [0;32mCIRFIFO[0m  - [08:08] -  Circular FIFO Enable
      0 - CIRFIFO_0 :
         Circular FIFO is disabled
      0x1 - CIRFIFO_1 :
         Circular FIFO is enabled
 (rw) (01)  [0;32mRDMO[0m  - [09:09] -  Receive Data Match Only
      0 - RDMO_0 :
         Received data is stored in the receive FIFO as in normal operations
      0x1 - RDMO_1 :
         Received data is discarded unless the Data Match Flag (DMF) is set
</lang>
#### p.lpspi2.cfgr1
<link=p.LPSPI2.CFGR1>
#### p.LPSPI2.DMR0
<lang=dft>
 (rw)  [1;33m0x40398030[0m (0x40398000 + 0x0030)
Data Match Register 0
 (rw) (32)  [0;32mMATCH0[0m  - [31:00] -  Match 0 Value
</lang>
#### p.lpspi2.ccr
<link=p.LPSPI2.CCR>
#### p.LPSPI2.FSR
<lang=dft>
 (ro)  [1;33m0x4039805c[0m (0x40398000 + 0x005c)
FIFO Status Register
 (ro) (05)  [0;32mTXCOUNT[0m  - [04:00] -  Transmit FIFO Count
 (ro) (05)  [0;32mRXCOUNT[0m  - [20:16] -  Receive FIFO Count
</lang>
#### lpspi2.fsr
<link=p.LPSPI2.FSR>
#### lpspi2.tcr
<link=p.LPSPI2.TCR>
#### p.lpspi3.param
<link=p.LPSPI3.PARAM>
#### lpspi3.cfgr1
<link=p.LPSPI3.CFGR1>
#### p.LPSPI4.PARAM
<lang=dft>
 (ro)  [1;33m0x403a0004[0m (0x403a0000 + 0x0004)
Parameter Register
 (ro) (08)  [0;32mTXFIFO[0m  - [07:00] -  Transmit FIFO Size
 (ro) (08)  [0;32mRXFIFO[0m  - [15:08] -  Receive FIFO Size
 (ro) (08)  [0;32mPCSNUM[0m  - [23:16] -  PCS Number
</lang>
#### p.lpspi4.param
<link=p.LPSPI4.PARAM>
#### p.lpspi4.cfgr0
<link=p.LPSPI4.CFGR0>
#### p.adc_etc.dma_ctrl
<link=p.ADC_ETC.DMA_CTRL>
#### p.ADC_ETC.TRIG2_RESULT_3_2
<lang=dft>
 (ro)  [1;33m0x403b007c[0m (0x403b0000 + 0x007c)
ETC_TRIG Result Data 3/2 Register
 (ro) (12)  [0;32mDATA2[0m  - [11:00] -  Result DATA2
 (ro) (12)  [0;32mDATA3[0m  - [27:16] -  Result DATA3
</lang>
#### p.adc_etc.trig2_result_5_4
<link=p.ADC_ETC.TRIG2_RESULT_5_4>
#### p.adc_etc.trig2_result_7_6
<link=p.ADC_ETC.TRIG2_RESULT_7_6>
#### p.adc_etc.trig3_counter
<link=p.ADC_ETC.TRIG3_COUNTER>
#### ADC_ETC.TRIG3_RESULT_1_0
<link=p.ADC_ETC.TRIG3_RESULT_1_0>
#### ADC_ETC.TRIG3_RESULT_3_2
<link=p.ADC_ETC.TRIG3_RESULT_3_2>
#### ADC_ETC.TRIG4_COUNTER
<link=p.ADC_ETC.TRIG4_COUNTER>
#### p.ADC_ETC.TRIG4_CHAIN_3_2
<lang=dft>
 (rw)  [1;33m0x403b00bc[0m (0x403b0000 + 0x00bc)
ETC_TRIG Chain 2/3 Register
 (rw) (04)  [0;32mCSEL2[0m  - [03:00] -  CHAIN2 CSEL
 (rw) (08)  [0;32mHWTS2[0m  - [11:04] -  CHAIN2 HWTS
 (rw) (01)  [0;32mB2B2[0m  - [12:12] -  CHAIN2 B2B
 (rw) (02)  [0;32mIE2[0m  - [14:13] -  CHAIN2 IE
 (rw) (04)  [0;32mCSEL3[0m  - [19:16] -  CHAIN3 CSEL
 (rw) (08)  [0;32mHWTS3[0m  - [27:20] -  CHAIN3 HWTS
 (rw) (01)  [0;32mB2B3[0m  - [28:28] -  CHAIN3 B2B
 (rw) (02)  [0;32mIE3[0m  - [30:29] -  CHAIN3 IE
</lang>
#### ADC_ETC.TRIG4_CHAIN_3_2
<link=p.ADC_ETC.TRIG4_CHAIN_3_2>
#### p.ADC_ETC.TRIG4_CHAIN_5_4
<lang=dft>
 (rw)  [1;33m0x403b00c0[0m (0x403b0000 + 0x00c0)
ETC_TRIG Chain 4/5 Register
 (rw) (04)  [0;32mCSEL4[0m  - [03:00] -  CHAIN4 CSEL
 (rw) (08)  [0;32mHWTS4[0m  - [11:04] -  CHAIN4 HWTS
 (rw) (01)  [0;32mB2B4[0m  - [12:12] -  CHAIN4 B2B
 (rw) (02)  [0;32mIE4[0m  - [14:13] -  CHAIN4 IE
 (rw) (04)  [0;32mCSEL5[0m  - [19:16] -  CHAIN5 CSEL
 (rw) (08)  [0;32mHWTS5[0m  - [27:20] -  CHAIN5 HWTS
 (rw) (01)  [0;32mB2B5[0m  - [28:28] -  CHAIN5 B2B
 (rw) (02)  [0;32mIE5[0m  - [30:29] -  CHAIN5 IE
</lang>
#### ADC_ETC.TRIG4_CHAIN_5_4
<link=p.ADC_ETC.TRIG4_CHAIN_5_4>
#### adc_etc.trig5_chain_1_0
<link=p.ADC_ETC.TRIG5_CHAIN_1_0>
#### p.adc_etc.trig5_result_5_4
<link=p.ADC_ETC.TRIG5_RESULT_5_4>
#### p.adc_etc.trig5_result_7_6
<link=p.ADC_ETC.TRIG5_RESULT_7_6>
#### ADC_ETC.TRIG6_CTRL
<link=p.ADC_ETC.TRIG6_CTRL>
#### p.ADC_ETC.TRIG6_CHAIN_3_2
<lang=dft>
 (rw)  [1;33m0x403b010c[0m (0x403b0000 + 0x010c)
ETC_TRIG Chain 2/3 Register
 (rw) (04)  [0;32mCSEL2[0m  - [03:00] -  CHAIN2 CSEL
 (rw) (08)  [0;32mHWTS2[0m  - [11:04] -  CHAIN2 HWTS
 (rw) (01)  [0;32mB2B2[0m  - [12:12] -  CHAIN2 B2B
 (rw) (02)  [0;32mIE2[0m  - [14:13] -  CHAIN2 IE
 (rw) (04)  [0;32mCSEL3[0m  - [19:16] -  CHAIN3 CSEL
 (rw) (08)  [0;32mHWTS3[0m  - [27:20] -  CHAIN3 HWTS
 (rw) (01)  [0;32mB2B3[0m  - [28:28] -  CHAIN3 B2B
 (rw) (02)  [0;32mIE3[0m  - [30:29] -  CHAIN3 IE
</lang>
#### ADC_ETC.TRIG6_CHAIN_3_2
<link=p.ADC_ETC.TRIG6_CHAIN_3_2>
#### adc_etc.trig6_result_3_2
<link=p.ADC_ETC.TRIG6_RESULT_3_2>
#### adc_etc.trig6_result_5_4
<link=p.ADC_ETC.TRIG6_RESULT_5_4>
#### p.AOI1.BFCRT012
<lang=dft>
 (rw)  [1;33m0x403b4008[0m (0x403b4000 + 0x0008)
Boolean Function Term 0 and 1 Configuration Register for EVENTn
 (rw) (02)  [0;32mPT1_DC[0m  - [01:00] -  Product term 1, D input configuration
      0 - PT1_DC_0 :
         Force the D input in this product term to a logical zero
      0x1 - PT1_DC_1 :
         Pass the D input in this product term
      0x2 - PT1_DC_2 :
         Complement the D input in this product term
      0x3 - PT1_DC_3 :
         Force the D input in this product term to a logical one
 (rw) (02)  [0;32mPT1_CC[0m  - [03:02] -  Product term 1, C input configuration
      0 - PT1_CC_0 :
         Force the C input in this product term to a logical zero
      0x1 - PT1_CC_1 :
         Pass the C input in this product term
      0x2 - PT1_CC_2 :
         Complement the C input in this product term
      0x3 - PT1_CC_3 :
         Force the C input in this product term to a logical one
 (rw) (02)  [0;32mPT1_BC[0m  - [05:04] -  Product term 1, B input configuration
      0 - PT1_BC_0 :
         Force the B input in this product term to a logical zero
      0x1 - PT1_BC_1 :
         Pass the B input in this product term
      0x2 - PT1_BC_2 :
         Complement the B input in this product term
      0x3 - PT1_BC_3 :
         Force the B input in this product term to a logical one
 (rw) (02)  [0;32mPT1_AC[0m  - [07:06] -  Product term 1, A input configuration
      0 - PT1_AC_0 :
         Force the A input in this product term to a logical zero
      0x1 - PT1_AC_1 :
         Pass the A input in this product term
      0x2 - PT1_AC_2 :
         Complement the A input in this product term
      0x3 - PT1_AC_3 :
         Force the A input in this product term to a logical one
 (rw) (02)  [0;32mPT0_DC[0m  - [09:08] -  Product term 0, D input configuration
      0 - PT0_DC_0 :
         Force the D input in this product term to a logical zero
      0x1 - PT0_DC_1 :
         Pass the D input in this product term
      0x2 - PT0_DC_2 :
         Complement the D input in this product term
      0x3 - PT0_DC_3 :
         Force the D input in this product term to a logical one
 (rw) (02)  [0;32mPT0_CC[0m  - [11:10] -  Product term 0, C input configuration
      0 - PT0_CC_0 :
         Force the C input in this product term to a logical zero
      0x1 - PT0_CC_1 :
         Pass the C input in this product term
      0x2 - PT0_CC_2 :
         Complement the C input in this product term
      0x3 - PT0_CC_3 :
         Force the C input in this product term to a logical one
 (rw) (02)  [0;32mPT0_BC[0m  - [13:12] -  Product term 0, B input configuration
      0 - PT0_BC_0 :
         Force the B input in this product term to a logical zero
      0x1 - PT0_BC_1 :
         Pass the B input in this product term
      0x2 - PT0_BC_2 :
         Complement the B input in this product term
      0x3 - PT0_BC_3 :
         Force the B input in this product term to a logical one
 (rw) (02)  [0;32mPT0_AC[0m  - [15:14] -  Product term 0, A input configuration
      0 - PT0_AC_0 :
         Force the A input in this product term to a logical zero
      0x1 - PT0_AC_1 :
         Pass the A input in this product term
      0x2 - PT0_AC_2 :
         Complement the A input in this product term
      0x3 - PT0_AC_3 :
         Force the A input in this product term to a logical one
</lang>
#### p.aoi1.bfcrt233
<link=p.AOI1.BFCRT233>
#### p.aoi2.bfcrt011
<link=p.AOI2.BFCRT011>
#### xbara1.sel1
<link=p.XBARA1.SEL1>
#### XBARA1.SEL2
<link=p.XBARA1.SEL2>
#### p.XBARA1.SEL10
<lang=dft>
 (rw)  [1;33m0x403bc014[0m (0x403bc000 + 0x0014)
Crossbar A Select Register 10
 (rw) (07)  [0;32mSEL20[0m  - [06:00] -  Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description s
 ection for input/output assignment)
 (rw) (07)  [0;32mSEL21[0m  - [14:08] -  Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description s
 ection for input/output assignment)
</lang>
#### p.xbara1.sel11
<link=p.XBARA1.SEL11>
#### xbara1.sel12
<link=p.XBARA1.SEL12>
#### XBARA1.SEL13
<link=p.XBARA1.SEL13>
#### p.xbara1.sel20
<link=p.XBARA1.SEL20>
#### p.XBARA1.SEL21
<lang=dft>
 (rw)  [1;33m0x403bc02a[0m (0x403bc000 + 0x002a)
Crossbar A Select Register 21
 (rw) (07)  [0;32mSEL42[0m  - [06:00] -  Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description s
 ection for input/output assignment)
 (rw) (07)  [0;32mSEL43[0m  - [14:08] -  Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description s
 ection for input/output assignment)
</lang>
#### xbara1.sel34
<link=p.XBARA1.SEL34>
#### XBARA1.SEL35
<link=p.XBARA1.SEL35>
#### p.XBARA1.SEL36
<lang=dft>
 (rw)  [1;33m0x403bc048[0m (0x403bc000 + 0x0048)
Crossbar A Select Register 36
 (rw) (07)  [0;32mSEL72[0m  - [06:00] -  Input (XBARA_INn) to be muxed to XBARA_OUT72 (refer to Functional Description s
 ection for input/output assignment)
 (rw) (07)  [0;32mSEL73[0m  - [14:08] -  Input (XBARA_INn) to be muxed to XBARA_OUT73 (refer to Functional Description s
 ection for input/output assignment)
</lang>
#### p.xbara1.sel37
<link=p.XBARA1.SEL37>
#### p.xbara1.sel42
<link=p.XBARA1.SEL42>
#### p.XBARA1.SEL43
<lang=dft>
 (rw)  [1;33m0x403bc056[0m (0x403bc000 + 0x0056)
Crossbar A Select Register 43
 (rw) (07)  [0;32mSEL86[0m  - [06:00] -  Input (XBARA_INn) to be muxed to XBARA_OUT86 (refer to Functional Description s
 ection for input/output assignment)
 (rw) (07)  [0;32mSEL87[0m  - [14:08] -  Input (XBARA_INn) to be muxed to XBARA_OUT87 (refer to Functional Description s
 ection for input/output assignment)
</lang>
#### xbara1.sel48
<link=p.XBARA1.SEL48>
#### xbarb2.sel7
<link=p.XBARB2.SEL7>
#### xbarb3.sel1
<link=p.XBARB3.SEL1>
#### p.xbarb3.sel3
<link=p.XBARB3.SEL3>
#### p.ENC1
<lang=dft>
base: 0x403c8000
CTRL            CTRL2           FILT            IMR             
LCOMP           LINIT           LMOD            LPOS            
LPOSH           POSD            POSDH           REV             
REVH            TST             UCOMP           UINIT           
UMOD            UPOS            UPOSH           WTR             
输入 p.ENC1.{reg_name} 以查看寄存器的详细信息
type p.ENC1.{reg_name} to check details of registers
</lang>
#### ENC1.WTR
<link=p.ENC1.WTR>
#### enc1.uinit
<link=p.ENC1.UINIT>
#### ENC1.TST
<link=p.ENC1.TST>
#### p.enc1.umod
<link=p.ENC1.UMOD>
#### enc2.wtr
<link=p.ENC2.WTR>
#### enc2.posd
<link=p.ENC2.POSD>
#### p.ENC2.REVH
<lang=dft>
 (ro)  [1;33m0x403cc00c[0m (0x403cc000 + 0x000c)
Revolution Hold Register
 (ro) (16)  [0;32mREVH[0m  - [15:00] -  This read-only register contains a snapshot of the value of the REV register.
</lang>
#### p.ENC2.UINIT
<lang=dft>
 (rw)  [1;33m0x403cc016[0m (0x403cc000 + 0x0016)
Upper Initialization Register
 (rw) (16)  [0;32mINIT[0m  - [15:00] -  This read/write register contains the value to be used to initialize the upper 
 half of the position counter (UPOS)
</lang>
#### p.enc2.uinit
<link=p.ENC2.UINIT>
#### p.ENC2.TST
<lang=dft>
 (rw)  [1;33m0x403cc01c[0m (0x403cc000 + 0x001c)
Test Register
 (rw) (08)  [0;32mTEST_COUNT[0m  - [07:00] -  These bits hold the number of quadrature advances to generate.
 (rw) (05)  [0;32mTEST_PERIOD[0m  - [12:08] -  These bits hold the period of quadrature phase in IPBus clock cycles.
 (rw) (01)  [0;32mQDN[0m  - [13:13] -  Quadrature Decoder Negative Signal
      0 - QDN_0 :
         Leaves quadrature decoder signal in a positive direction
      0x1 - QDN_1 :
         Generates a negative quadrature decoder signal
 (rw) (01)  [0;32mTCE[0m  - [14:14] -  Test Counter Enable
      0 - TCE_0 :
         Test count is not enabled
      0x1 - TCE_1 :
         Test count is enabled
 (rw) (01)  [0;32mTEN[0m  - [15:15] -  Test Mode Enable
      0 - TEN_0 :
         Test module is not enabled
      0x1 - TEN_1 :
         Test module is enabled
</lang>
#### p.enc2.tst
<link=p.ENC2.TST>
#### ENC2.UMOD
<link=p.ENC2.UMOD>
#### p.enc3.lpos
<link=p.ENC3.LPOS>
#### ENC4.REVH
<link=p.ENC4.REVH>
#### enc4.uposh
<link=p.ENC4.UPOSH>
#### p.enc4.lposh
<link=p.ENC4.LPOSH>
#### p.pwm1.sm0fracval1
<link=p.PWM1.SM0FRACVAL1>
#### PWM1.SM0FRACVAL1
<link=p.PWM1.SM0FRACVAL1>
#### pwm1.sm0val1
<link=p.PWM1.SM0VAL1>
#### p.PWM1.SM0VAL4
<lang=dft>
 (rw)  [1;33m0x403dc01a[0m (0x403dc000 + 0x001a)
Value Register 4
 (rw) (16)  [0;32mVAL4[0m  - [15:00] -  Value Register 4
</lang>
#### pwm1.sm0dmaen
<link=p.PWM1.SM0DMAEN>
#### PWM1.SM0DMAEN
<link=p.PWM1.SM0DMAEN>
#### PWM1.SM0CAPTCOMPA
<link=p.PWM1.SM0CAPTCOMPA>
#### p.PWM1.SM0CVAL3
<lang=dft>
 (ro)  [1;33m0x403dc04c[0m (0x403dc000 + 0x004c)
Capture Value 3 Register
 (ro) (16)  [0;32mCAPTVAL3[0m  - [15:00] -  CAPTVAL3
</lang>
#### PWM1.SM0CVAL3CYC
<link=p.PWM1.SM0CVAL3CYC>
#### PWM1.SM1CNT
<link=p.PWM1.SM1CNT>
#### p.PWM1.SM1INIT
<lang=dft>
 (rw)  [1;33m0x403dc062[0m (0x403dc000 + 0x0062)
Initial Count Register
 (rw) (16)  [0;32mINIT[0m  - [15:00] -  Initial Count Register Bits
</lang>
#### pwm1.sm1val0
<link=p.PWM1.SM1VAL0>
#### p.PWM1.SM1VAL5
<lang=dft>
 (rw)  [1;33m0x403dc07e[0m (0x403dc000 + 0x007e)
Value Register 5
 (rw) (16)  [0;32mVAL5[0m  - [15:00] -  Value Register 5
</lang>
#### p.pwm1.sm1inten
<link=p.PWM1.SM1INTEN>
#### pwm1.sm1dmaen
<link=p.PWM1.SM1DMAEN>
#### pwm1.sm1captctrlx
<link=p.PWM1.SM1CAPTCTRLX>
#### p.PWM1.SM1CVAL1
<lang=dft>
 (ro)  [1;33m0x403dc0a4[0m (0x403dc000 + 0x00a4)
Capture Value 1 Register
 (ro) (16)  [0;32mCAPTVAL1[0m  - [15:00] -  CAPTVAL1
</lang>
#### PWM1.SM1CVAL1
<link=p.PWM1.SM1CVAL1>
#### p.PWM1.SM1CVAL4CYC
<lang=dft>
 (ro)  [1;33m0x403dc0b2[0m (0x403dc000 + 0x00b2)
Capture Value 4 Cycle Register
 (ro) (04)  [0;32mCVAL4CYC[0m  - [03:00] -  CVAL4CYC
</lang>
#### pwm1.sm1cval4cyc
<link=p.PWM1.SM1CVAL4CYC>
#### p.pwm1.sm2fracval3
<link=p.PWM1.SM2FRACVAL3>
#### PWM1.SM2VAL3
<link=p.PWM1.SM2VAL3>
#### p.pwm1.sm2inten
<link=p.PWM1.SM2INTEN>
#### PWM1.SM2DISMAP1
<link=p.PWM1.SM2DISMAP1>
#### p.PWM1.SM2CVAL2CYC
<lang=dft>
 (ro)  [1;33m0x403dc10a[0m (0x403dc000 + 0x010a)
Capture Value 2 Cycle Register
 (ro) (04)  [0;32mCVAL2CYC[0m  - [03:00] -  CVAL2CYC
</lang>
#### PWM1.SM3VAL2
<link=p.PWM1.SM3VAL2>
#### pwm1.sm3octrl
<link=p.PWM1.SM3OCTRL>
#### p.PWM1.SM3STS
<lang=dft>
 (rw)  [1;33m0x403dc144[0m (0x403dc000 + 0x0144)
Status Register
 (rw) (06)  [0;32mCMPF[0m  - [05:00] -  Compare Flags
      0 - CMPF_0 :
         No compare event has occurred for a particular VALx value.
      0x1 - CMPF_1 :
         A compare event has occurred for a particular VALx value.
 (rw) (01)  [0;32mCFX0[0m  - [06:06] -  Capture Flag X0
 (rw) (01)  [0;32mCFX1[0m  - [07:07] -  Capture Flag X1
 (rw) (01)  [0;32mCFB0[0m  - [08:08] -  Capture Flag B0
 (rw) (01)  [0;32mCFB1[0m  - [09:09] -  Capture Flag B1
 (rw) (01)  [0;32mCFA0[0m  - [10:10] -  Capture Flag A0
 (rw) (01)  [0;32mCFA1[0m  - [11:11] -  Capture Flag A1
 (rw) (01)  [0;32mRF[0m  - [12:12] -  Reload Flag
      0 - RF_0 :
         No new reload cycle since last STS[RF] clearing
      0x1 - RF_1 :
         New reload cycle since last STS[RF] clearing
 (rw) (01)  [0;32mREF[0m  - [13:13] -  Reload Error Flag
      0 - REF_0 :
         No reload error occurred.
      0x1 - REF_1 :
         Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
 (ro) (01)  [0;32mRUF[0m  - [14:14] -  Registers Updated Flag
      0 - RUF_0 :
         No register update has occurred since last reload.
      0x1 - RUF_1 :
         At least one of the double buffered registers has been updated since th
         e last reload.
</lang>
#### p.pwm1.sm3sts
<link=p.PWM1.SM3STS>
#### pwm1.sm3tctrl
<link=p.PWM1.SM3TCTRL>
#### pwm1.sm3dismap0
<link=p.PWM1.SM3DISMAP0>
#### p.pwm1.sm3cval1
<link=p.PWM1.SM3CVAL1>
#### PWM1.SM3CVAL1CYC
<link=p.PWM1.SM3CVAL1CYC>
#### p.pwm1.sm3cval2cyc
<link=p.PWM1.SM3CVAL2CYC>
#### p.PWM1.SM3CVAL5CYC
<lang=dft>
 (ro)  [1;33m0x403dc176[0m (0x403dc000 + 0x0176)
Capture Value 5 Cycle Register
 (ro) (04)  [0;32mCVAL5CYC[0m  - [03:00] -  CVAL5CYC
</lang>
#### p.pwm1.mask
<link=p.PWM1.MASK>
#### PWM1.SWCOUT
<link=p.PWM1.SWCOUT>
#### p.PWM1.FSTS0
<lang=dft>
 (rw)  [1;33m0x403dc18e[0m (0x403dc000 + 0x018e)
Fault Status Register
 (rw) (04)  [0;32mFFLAG[0m  - [03:00] -  Fault Flags
      0 - FFLAG_0 :
         No fault on the FAULTx pin.
      0x1 - FFLAG_1 :
         Fault on the FAULTx pin.
 (rw) (04)  [0;32mFFULL[0m  - [07:04] -  Full Cycle
      0 - FFULL_0 :
         PWM outputs are not re-enabled at the start of a full cycle
      0x1 - FFULL_1 :
         PWM outputs are re-enabled at the start of a full cycle
 (ro) (04)  [0;32mFFPIN[0m  - [11:08] -  Filtered Fault Pins
 (rw) (04)  [0;32mFHALF[0m  - [15:12] -  Half Cycle Fault Recovery
      0 - FHALF_0 :
         PWM outputs are not re-enabled at the start of a half cycle.
      0x1 - FHALF_1 :
         PWM outputs are re-enabled at the start of a half cycle (as defined by 
         VAL0).
</lang>
#### p.pwm1.ffilt0
<link=p.PWM1.FFILT0>
#### p.pwm2.sm0ctrl2
<link=p.PWM2.SM0CTRL2>
#### pwm2.sm0ctrl2
<link=p.PWM2.SM0CTRL2>
#### pwm2.sm0ctrl
<link=p.PWM2.SM0CTRL>
#### pwm2.sm0fracval1
<link=p.PWM2.SM0FRACVAL1>
#### PWM2.SM0VAL5
<link=p.PWM2.SM0VAL5>
#### p.PWM2.SM0STS
<lang=dft>
 (rw)  [1;33m0x403e0024[0m (0x403e0000 + 0x0024)
Status Register
 (rw) (06)  [0;32mCMPF[0m  - [05:00] -  Compare Flags
      0 - CMPF_0 :
         No compare event has occurred for a particular VALx value.
      0x1 - CMPF_1 :
         A compare event has occurred for a particular VALx value.
 (rw) (01)  [0;32mCFX0[0m  - [06:06] -  Capture Flag X0
 (rw) (01)  [0;32mCFX1[0m  - [07:07] -  Capture Flag X1
 (rw) (01)  [0;32mCFB0[0m  - [08:08] -  Capture Flag B0
 (rw) (01)  [0;32mCFB1[0m  - [09:09] -  Capture Flag B1
 (rw) (01)  [0;32mCFA0[0m  - [10:10] -  Capture Flag A0
 (rw) (01)  [0;32mCFA1[0m  - [11:11] -  Capture Flag A1
 (rw) (01)  [0;32mRF[0m  - [12:12] -  Reload Flag
      0 - RF_0 :
         No new reload cycle since last STS[RF] clearing
      0x1 - RF_1 :
         New reload cycle since last STS[RF] clearing
 (rw) (01)  [0;32mREF[0m  - [13:13] -  Reload Error Flag
      0 - REF_0 :
         No reload error occurred.
      0x1 - REF_1 :
         Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
 (ro) (01)  [0;32mRUF[0m  - [14:14] -  Registers Updated Flag
      0 - RUF_0 :
         No register update has occurred since last reload.
      0x1 - RUF_1 :
         At least one of the double buffered registers has been updated since th
         e last reload.
</lang>
#### p.pwm2.sm0dmaen
<link=p.PWM2.SM0DMAEN>
#### p.pwm2.sm0captctrla
<link=p.PWM2.SM0CAPTCTRLA>
#### PWM2.SM0CVAL2CYC
<link=p.PWM2.SM0CVAL2CYC>
#### pwm2.sm0cval3
<link=p.PWM2.SM0CVAL3>
#### p.pwm2.sm0cval4
<link=p.PWM2.SM0CVAL4>
#### p.PWM2.SM0CVAL5CYC
<lang=dft>
 (ro)  [1;33m0x403e0056[0m (0x403e0000 + 0x0056)
Capture Value 5 Cycle Register
 (ro) (04)  [0;32mCVAL5CYC[0m  - [03:00] -  CVAL5CYC
</lang>
#### pwm2.sm1init
<link=p.PWM2.SM1INIT>
#### PWM2.SM1FRACVAL1
<link=p.PWM2.SM1FRACVAL1>
#### PWM2.SM1VAL4
<link=p.PWM2.SM1VAL4>
#### PWM2.SM1FRCTRL
<link=p.PWM2.SM1FRCTRL>
#### p.pwm2.sm1dmaen
<link=p.PWM2.SM1DMAEN>
#### pwm2.sm1dmaen
<link=p.PWM2.SM1DMAEN>
#### p.pwm2.sm1dtcnt1
<link=p.PWM2.SM1DTCNT1>
#### p.PWM2.SM1CVAL2CYC
<lang=dft>
 (ro)  [1;33m0x403e00aa[0m (0x403e0000 + 0x00aa)
Capture Value 2 Cycle Register
 (ro) (04)  [0;32mCVAL2CYC[0m  - [03:00] -  CVAL2CYC
</lang>
#### PWM2.SM1CVAL5CYC
<link=p.PWM2.SM1CVAL5CYC>
#### p.PWM2.SM2INIT
<lang=dft>
 (rw)  [1;33m0x403e00c2[0m (0x403e0000 + 0x00c2)
Initial Count Register
 (rw) (16)  [0;32mINIT[0m  - [15:00] -  Initial Count Register Bits
</lang>
#### pwm2.sm2init
<link=p.PWM2.SM2INIT>
#### p.pwm2.sm2val0
<link=p.PWM2.SM2VAL0>
#### pwm2.sm2fracval3
<link=p.PWM2.SM2FRACVAL3>
#### p.PWM2.SM2VAL5
<lang=dft>
 (rw)  [1;33m0x403e00de[0m (0x403e0000 + 0x00de)
Value Register 5
 (rw) (16)  [0;32mVAL5[0m  - [15:00] -  Value Register 5
</lang>
#### PWM2.SM2TCTRL
<link=p.PWM2.SM2TCTRL>
#### p.pwm2.sm2dtcnt1
<link=p.PWM2.SM2DTCNT1>
#### PWM2.SM2CVAL0
<link=p.PWM2.SM2CVAL0>
#### p.PWM2.SM2CVAL1
<lang=dft>
 (ro)  [1;33m0x403e0104[0m (0x403e0000 + 0x0104)
Capture Value 1 Register
 (ro) (16)  [0;32mCAPTVAL1[0m  - [15:00] -  CAPTVAL1
</lang>
#### p.PWM2.SM2CVAL4CYC
<lang=dft>
 (ro)  [1;33m0x403e0112[0m (0x403e0000 + 0x0112)
Capture Value 4 Cycle Register
 (ro) (04)  [0;32mCVAL4CYC[0m  - [03:00] -  CVAL4CYC
</lang>
#### p.pwm2.sm3val1
<link=p.PWM2.SM3VAL1>
#### PWM2.SM3FRACVAL2
<link=p.PWM2.SM3FRACVAL2>
#### p.PWM2.SM3VAL4
<lang=dft>
 (rw)  [1;33m0x403e013a[0m (0x403e0000 + 0x013a)
Value Register 4
 (rw) (16)  [0;32mVAL4[0m  - [15:00] -  Value Register 4
</lang>
#### PWM2.SM3CAPTCTRLA
<link=p.PWM2.SM3CAPTCTRLA>
#### p.PWM2.SM3CVAL3
<lang=dft>
 (ro)  [1;33m0x403e016c[0m (0x403e0000 + 0x016c)
Capture Value 3 Register
 (ro) (16)  [0;32mCAPTVAL3[0m  - [15:00] -  CAPTVAL3
</lang>
#### pwm2.sm3cval5
<link=p.PWM2.SM3CVAL5>
#### p.PWM2.MASK
<lang=dft>
 (rw)  [1;33m0x403e0182[0m (0x403e0000 + 0x0182)
Mask Register
 (rw) (04)  [0;32mMASKX[0m  - [03:00] -  PWM_X Masks
      0 - MASKX_0 :
         PWM_X output normal.
      0x1 - MASKX_1 :
         PWM_X output masked.
 (rw) (04)  [0;32mMASKB[0m  - [07:04] -  PWM_B Masks
      0 - MASKB_0 :
         PWM_B output normal.
      0x1 - MASKB_1 :
         PWM_B output masked.
 (rw) (04)  [0;32mMASKA[0m  - [11:08] -  PWM_A Masks
      0 - MASKA_0 :
         PWM_A output normal.
      0x1 - MASKA_1 :
         PWM_A output masked.
 (wo) (04)  [0;32mUPDATE_MASK[0m  - [15:12] -  Update Mask Bits Immediately
      0 - UPDATE_MASK_0 :
         Normal operation. MASK* bits within the corresponding submodule are not
          updated until a FORCE_OUT event occurs within the submodule.
      0x1 - UPDATE_MASK_1 :
         Immediate operation. MASK* bits within the corresponding submodule are 
         updated on the following clock edge after setting this bit.
</lang>
#### p.PWM2.DTSRCSEL
<lang=dft>
 (rw)  [1;33m0x403e0186[0m (0x403e0000 + 0x0186)
PWM Source Select Register
 (rw) (02)  [0;32mSM0SEL45[0m  - [01:00] -  Submodule 0 PWM45 Control Select
      0 - SM0SEL45_0 :
         Generated SM0PWM45 signal is used by the deadtime logic.
      0x1 - SM0SEL45_1 :
         Inverted generated SM0PWM45 signal is used by the deadtime logic.
      0x2 - SM0SEL45_2 :
         SWCOUT[SM0OUT45] is used by the deadtime logic.
      0x3 - SM0SEL45_3 :
         PWM0_EXTB signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM0SEL23[0m  - [03:02] -  Submodule 0 PWM23 Control Select
      0 - SM0SEL23_0 :
         Generated SM0PWM23 signal is used by the deadtime logic.
      0x1 - SM0SEL23_1 :
         Inverted generated SM0PWM23 signal is used by the deadtime logic.
      0x2 - SM0SEL23_2 :
         SWCOUT[SM0OUT23] is used by the deadtime logic.
      0x3 - SM0SEL23_3 :
         PWM0_EXTA signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM1SEL45[0m  - [05:04] -  Submodule 1 PWM45 Control Select
      0 - SM1SEL45_0 :
         Generated SM1PWM45 signal is used by the deadtime logic.
      0x1 - SM1SEL45_1 :
         Inverted generated SM1PWM45 signal is used by the deadtime logic.
      0x2 - SM1SEL45_2 :
         SWCOUT[SM1OUT45] is used by the deadtime logic.
      0x3 - SM1SEL45_3 :
         PWM1_EXTB signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM1SEL23[0m  - [07:06] -  Submodule 1 PWM23 Control Select
      0 - SM1SEL23_0 :
         Generated SM1PWM23 signal is used by the deadtime logic.
      0x1 - SM1SEL23_1 :
         Inverted generated SM1PWM23 signal is used by the deadtime logic.
      0x2 - SM1SEL23_2 :
         SWCOUT[SM1OUT23] is used by the deadtime logic.
      0x3 - SM1SEL23_3 :
         PWM1_EXTA signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM2SEL45[0m  - [09:08] -  Submodule 2 PWM45 Control Select
      0 - SM2SEL45_0 :
         Generated SM2PWM45 signal is used by the deadtime logic.
      0x1 - SM2SEL45_1 :
         Inverted generated SM2PWM45 signal is used by the deadtime logic.
      0x2 - SM2SEL45_2 :
         SWCOUT[SM2OUT45] is used by the deadtime logic.
      0x3 - SM2SEL45_3 :
         PWM2_EXTB signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM2SEL23[0m  - [11:10] -  Submodule 2 PWM23 Control Select
      0 - SM2SEL23_0 :
         Generated SM2PWM23 signal is used by the deadtime logic.
      0x1 - SM2SEL23_1 :
         Inverted generated SM2PWM23 signal is used by the deadtime logic.
      0x2 - SM2SEL23_2 :
         SWCOUT[SM2OUT23] is used by the deadtime logic.
      0x3 - SM2SEL23_3 :
         PWM2_EXTA signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM3SEL45[0m  - [13:12] -  Submodule 3 PWM45 Control Select
      0 - SM3SEL45_0 :
         Generated SM3PWM45 signal is used by the deadtime logic.
      0x1 - SM3SEL45_1 :
         Inverted generated SM3PWM45 signal is used by the deadtime logic.
      0x2 - SM3SEL45_2 :
         SWCOUT[SM3OUT45] is used by the deadtime logic.
      0x3 - SM3SEL45_3 :
         PWM3_EXTB signal is used by the deadtime logic.
 (rw) (02)  [0;32mSM3SEL23[0m  - [15:14] -  Submodule 3 PWM23 Control Select
      0 - SM3SEL23_0 :
         Generated SM3PWM23 signal is used by the deadtime logic.
      0x1 - SM3SEL23_1 :
         Inverted generated SM3PWM23 signal is used by the deadtime logic.
      0x2 - SM3SEL23_2 :
         SWCOUT[SM3OUT23] is used by the deadtime logic.
      0x3 - SM3SEL23_3 :
         PWM3_EXTA signal is used by the deadtime logic.
</lang>
#### PWM2.DTSRCSEL
<link=p.PWM2.DTSRCSEL>
#### p.pwm3
<link=p.PWM3>
#### pwm3.sm0ctrl
<link=p.PWM3.SM0CTRL>
#### PWM3.SM0FRACVAL1
<link=p.PWM3.SM0FRACVAL1>
#### p.pwm3.sm0fracval3
<link=p.PWM3.SM0FRACVAL3>
#### PWM3.SM0VAL4
<link=p.PWM3.SM0VAL4>
#### PWM3.SM0FRCTRL
<link=p.PWM3.SM0FRCTRL>
#### p.pwm3.sm0inten
<link=p.PWM3.SM0INTEN>
#### pwm3.sm0captcompb
<link=p.PWM3.SM0CAPTCOMPB>
#### pwm3.sm0cval0
<link=p.PWM3.SM0CVAL0>
#### p.PWM3.SM0CVAL2CYC
<lang=dft>
 (ro)  [1;33m0x403e404a[0m (0x403e4000 + 0x004a)
Capture Value 2 Cycle Register
 (ro) (04)  [0;32mCVAL2CYC[0m  - [03:00] -  CVAL2CYC
</lang>
#### PWM3.SM0CVAL5CYC
<link=p.PWM3.SM0CVAL5CYC>
#### PWM3.SM1VAL5
<link=p.PWM3.SM1VAL5>
#### p.PWM3.SM1STS
<lang=dft>
 (rw)  [1;33m0x403e4084[0m (0x403e4000 + 0x0084)
Status Register
 (rw) (06)  [0;32mCMPF[0m  - [05:00] -  Compare Flags
      0 - CMPF_0 :
         No compare event has occurred for a particular VALx value.
      0x1 - CMPF_1 :
         A compare event has occurred for a particular VALx value.
 (rw) (01)  [0;32mCFX0[0m  - [06:06] -  Capture Flag X0
 (rw) (01)  [0;32mCFX1[0m  - [07:07] -  Capture Flag X1
 (rw) (01)  [0;32mCFB0[0m  - [08:08] -  Capture Flag B0
 (rw) (01)  [0;32mCFB1[0m  - [09:09] -  Capture Flag B1
 (rw) (01)  [0;32mCFA0[0m  - [10:10] -  Capture Flag A0
 (rw) (01)  [0;32mCFA1[0m  - [11:11] -  Capture Flag A1
 (rw) (01)  [0;32mRF[0m  - [12:12] -  Reload Flag
      0 - RF_0 :
         No new reload cycle since last STS[RF] clearing
      0x1 - RF_1 :
         New reload cycle since last STS[RF] clearing
 (rw) (01)  [0;32mREF[0m  - [13:13] -  Reload Error Flag
      0 - REF_0 :
         No reload error occurred.
      0x1 - REF_1 :
         Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
 (ro) (01)  [0;32mRUF[0m  - [14:14] -  Registers Updated Flag
      0 - RUF_0 :
         No register update has occurred since last reload.
      0x1 - RUF_1 :
         At least one of the double buffered registers has been updated since th
         e last reload.
</lang>
#### p.pwm3.sm1sts
<link=p.PWM3.SM1STS>
#### pwm3.sm1captcompb
<link=p.PWM3.SM1CAPTCOMPB>
#### p.pwm3.sm1cval1
<link=p.PWM3.SM1CVAL1>
#### p.pwm3.sm1cval2cyc
<link=p.PWM3.SM1CVAL2CYC>
#### PWM3.SM1CVAL2CYC
<link=p.PWM3.SM1CVAL2CYC>
#### pwm3.sm1cval4cyc
<link=p.PWM3.SM1CVAL4CYC>
#### p.PWM3.SM1CVAL5CYC
<lang=dft>
 (ro)  [1;33m0x403e40b6[0m (0x403e4000 + 0x00b6)
Capture Value 5 Cycle Register
 (ro) (04)  [0;32mCVAL5CYC[0m  - [03:00] -  CVAL5CYC
</lang>
#### p.pwm3.sm2fracval1
<link=p.PWM3.SM2FRACVAL1>
#### PWM3.SM2FRACVAL2
<link=p.PWM3.SM2FRACVAL2>
#### p.PWM3.SM2VAL4
<lang=dft>
 (rw)  [1;33m0x403e40da[0m (0x403e4000 + 0x00da)
Value Register 4
 (rw) (16)  [0;32mVAL4[0m  - [15:00] -  Value Register 4
</lang>
#### PWM3.SM2CAPTCTRLA
<link=p.PWM3.SM2CAPTCTRLA>
#### p.PWM3.SM2CVAL3
<lang=dft>
 (ro)  [1;33m0x403e410c[0m (0x403e4000 + 0x010c)
Capture Value 3 Register
 (ro) (16)  [0;32mCAPTVAL3[0m  - [15:00] -  CAPTVAL3
</lang>
#### p.PWM3.SM3INIT
<lang=dft>
 (rw)  [1;33m0x403e4122[0m (0x403e4000 + 0x0122)
Initial Count Register
 (rw) (16)  [0;32mINIT[0m  - [15:00] -  Initial Count Register Bits
</lang>
#### p.PWM3.SM3VAL5
<lang=dft>
 (rw)  [1;33m0x403e413e[0m (0x403e4000 + 0x013e)
Value Register 5
 (rw) (16)  [0;32mVAL5[0m  - [15:00] -  Value Register 5
</lang>
#### p.pwm3.sm3inten
<link=p.PWM3.SM3INTEN>
#### PWM3.SM3TCTRL
<link=p.PWM3.SM3TCTRL>
#### pwm3.sm3dismap1
<link=p.PWM3.SM3DISMAP1>
#### PWM3.SM3CVAL0
<link=p.PWM3.SM3CVAL0>
#### p.PWM3.SM3CVAL1
<lang=dft>
 (ro)  [1;33m0x403e4164[0m (0x403e4000 + 0x0164)
Capture Value 1 Register
 (ro) (16)  [0;32mCAPTVAL1[0m  - [15:00] -  CAPTVAL1
</lang>
#### p.PWM3.SM3CVAL4CYC
<lang=dft>
 (ro)  [1;33m0x403e4172[0m (0x403e4000 + 0x0172)
Capture Value 4 Cycle Register
 (ro) (04)  [0;32mCVAL4CYC[0m  - [03:00] -  CVAL4CYC
</lang>
#### pwm3.sm3cval5cyc
<link=p.PWM3.SM3CVAL5CYC>
#### p.pwm3.mctrl2
<link=p.PWM3.MCTRL2>
#### p.PWM3.FFILT0
<lang=dft>
 (rw)  [1;33m0x403e4190[0m (0x403e4000 + 0x0190)
Fault Filter Register
 (rw) (08)  [0;32mFILT_PER[0m  - [07:00] -  Fault Filter Period
 (rw) (03)  [0;32mFILT_CNT[0m  - [10:08] -  Fault Filter Count
 (rw) (01)  [0;32mGSTR[0m  - [15:15] -  Fault Glitch Stretch Enable
      0 - GSTR_0 :
         Fault input glitch stretching is disabled.
      0x1 - GSTR_1 :
         Input fault signals will be stretched to at least 2 IPBus clock cycles.
</lang>
#### p.pwm3.ftst0
<link=p.PWM3.FTST0>
#### PWM3.FTST0
<link=p.PWM3.FTST0>
#### PWM3.FCTRL20
<link=p.PWM3.FCTRL20>
#### p.PWM4.SM0VAL0
<lang=dft>
 (rw)  [1;33m0x403e800a[0m (0x403e8000 + 0x000a)
Value Register 0
 (rw) (16)  [0;32mVAL0[0m  - [15:00] -  Value Register 0
</lang>
#### p.pwm4.sm0frctrl
<link=p.PWM4.SM0FRCTRL>
#### pwm4.sm0inten
<link=p.PWM4.SM0INTEN>
#### PWM4.SM0CAPTCTRLB
<link=p.PWM4.SM0CAPTCTRLB>
#### p.PWM4.SM0CAPTCOMPB
<lang=dft>
 (rw)  [1;33m0x403e803a[0m (0x403e8000 + 0x003a)
Capture Compare B Register
 (rw) (08)  [0;32mEDGCMPB[0m  - [07:00] -  Edge Compare B
 (ro) (08)  [0;32mEDGCNTB[0m  - [15:08] -  Edge Counter B
</lang>
#### p.pwm4.sm0cval1
<link=p.PWM4.SM0CVAL1>
#### p.pwm4.sm0cval5cyc
<link=p.PWM4.SM0CVAL5CYC>
#### PWM4.SM1CTRL
<link=p.PWM4.SM1CTRL>
#### p.PWM4.SM1VAL1
<lang=dft>
 (rw)  [1;33m0x403e806e[0m (0x403e8000 + 0x006e)
Value Register 1
 (rw) (16)  [0;32mVAL1[0m  - [15:00] -  Value Register 1
</lang>
#### p.PWM4.SM1INTEN
<lang=dft>
 (rw)  [1;33m0x403e8086[0m (0x403e8000 + 0x0086)
Interrupt Enable Register
 (rw) (06)  [0;32mCMPIE[0m  - [05:00] -  Compare Interrupt Enables
      0 - CMPIE_0 :
         The corresponding STS[CMPF] bit will not cause an interrupt request.
      0x1 - CMPIE_1 :
         The corresponding STS[CMPF] bit will cause an interrupt request.
 (rw) (01)  [0;32mCX0IE[0m  - [06:06] -  Capture X 0 Interrupt Enable
      0 - CX0IE_0 :
         Interrupt request disabled for STS[CFX0].
      0x1 - CX0IE_1 :
         Interrupt request enabled for STS[CFX0].
 (rw) (01)  [0;32mCX1IE[0m  - [07:07] -  Capture X 1 Interrupt Enable
      0 - CX1IE_0 :
         Interrupt request disabled for STS[CFX1].
      0x1 - CX1IE_1 :
         Interrupt request enabled for STS[CFX1].
 (rw) (01)  [0;32mCB0IE[0m  - [08:08] -  Capture B 0 Interrupt Enable
      0 - CB0IE_0 :
         Interrupt request disabled for STS[CFB0].
      0x1 - CB0IE_1 :
         Interrupt request enabled for STS[CFB0].
 (rw) (01)  [0;32mCB1IE[0m  - [09:09] -  Capture B 1 Interrupt Enable
      0 - CB1IE_0 :
         Interrupt request disabled for STS[CFB1].
      0x1 - CB1IE_1 :
         Interrupt request enabled for STS[CFB1].
 (rw) (01)  [0;32mCA0IE[0m  - [10:10] -  Capture A 0 Interrupt Enable
      0 - CA0IE_0 :
         Interrupt request disabled for STS[CFA0].
      0x1 - CA0IE_1 :
         Interrupt request enabled for STS[CFA0].
 (rw) (01)  [0;32mCA1IE[0m  - [11:11] -  Capture A 1 Interrupt Enable
      0 - CA1IE_0 :
         Interrupt request disabled for STS[CFA1].
      0x1 - CA1IE_1 :
         Interrupt request enabled for STS[CFA1].
 (rw) (01)  [0;32mRIE[0m  - [12:12] -  Reload Interrupt Enable
      0 - RIE_0 :
         STS[RF] CPU interrupt requests disabled
      0x1 - RIE_1 :
         STS[RF] CPU interrupt requests enabled
 (rw) (01)  [0;32mREIE[0m  - [13:13] -  Reload Error Interrupt Enable
      0 - REIE_0 :
         STS[REF] CPU interrupt requests disabled
      0x1 - REIE_1 :
         STS[REF] CPU interrupt requests enabled
</lang>
#### p.pwm4.sm1captctrla
<link=p.PWM4.SM1CAPTCTRLA>
#### pwm4.sm1captctrlx
<link=p.PWM4.SM1CAPTCTRLX>
#### PWM4.SM1CVAL0
<link=p.PWM4.SM1CVAL0>
#### p.pwm4.sm1cval1
<link=p.PWM4.SM1CVAL1>
#### PWM4.SM2INIT
<link=p.PWM4.SM2INIT>
#### PWM4.SM2VAL1
<link=p.PWM4.SM2VAL1>
#### pwm4.sm2fracval4
<link=p.PWM4.SM2FRACVAL4>
#### PWM4.SM2STS
<link=p.PWM4.SM2STS>
#### p.pwm4.sm2tctrl
<link=p.PWM4.SM2TCTRL>
#### p.PWM4.SM2DTCNT0
<lang=dft>
 (rw)  [1;33m0x403e80f0[0m (0x403e8000 + 0x00f0)
Deadtime Count Register 0
 (rw) (16)  [0;32mDTCNT0[0m  - [15:00] -  DTCNT0
</lang>
#### p.PWM4.SM2CVAL3
<lang=dft>
 (ro)  [1;33m0x403e810c[0m (0x403e8000 + 0x010c)
Capture Value 3 Register
 (ro) (16)  [0;32mCAPTVAL3[0m  - [15:00] -  CAPTVAL3
</lang>
#### p.pwm4.sm2cval3cyc
<link=p.PWM4.SM2CVAL3CYC>
#### pwm4.sm2cval3cyc
<link=p.PWM4.SM2CVAL3CYC>
#### PWM4.SM2CVAL5
<link=p.PWM4.SM2CVAL5>
#### p.PWM4.SM3CNT
<lang=dft>
 (ro)  [1;33m0x403e8120[0m (0x403e8000 + 0x0120)
Counter Register
 (ro) (16)  [0;32mCNT[0m  - [15:00] -  Counter Register Bits
</lang>
#### PWM4.SM3VAL0
<link=p.PWM4.SM3VAL0>
#### PWM4.SM3DMAEN
<link=p.PWM4.SM3DMAEN>
#### p.PWM4.SM3TCTRL
<lang=dft>
 (rw)  [1;33m0x403e814a[0m (0x403e8000 + 0x014a)
Output Trigger Control Register
 (rw) (06)  [0;32mOUT_TRIG_EN[0m  - [05:00] -  Output Trigger Enables
      0 - OUT_TRIG_EN_0 :
         PWM_OUT_TRIGx will not set when the counter value matches the VALx valu
         e.
      0x1 - OUT_TRIG_EN_1 :
         PWM_OUT_TRIGx will set when the counter value matches the VALx value.
 (rw) (01)  [0;32mTRGFRQ[0m  - [12:12] -  Trigger frequency
      0 - TRGFRQ_0 :
         Trigger outputs are generated during every PWM period even if the PWM i
         s not reloaded every period due to CTRL[LDFQ] being non-zero.
      0x1 - TRGFRQ_1 :
         Trigger outputs are generated only during the final PWM period prior to
          a reload opportunity when the PWM is not reloaded every period due to 
         CTRL[LDFQ] being non-zero.
 (rw) (01)  [0;32mPWBOT1[0m  - [14:14] -  Output Trigger 1 Source Select
      0 - PWBOT1_0 :
         Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
      0x1 - PWBOT1_1 :
         Route the PWMB output to the PWM_OUT_TRIG1 port.
 (rw) (01)  [0;32mPWAOT0[0m  - [15:15] -  Output Trigger 0 Source Select
      0 - PWAOT0_0 :
         Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
      0x1 - PWAOT0_1 :
         Route the PWMA output to the PWM_OUT_TRIG0 port.
</lang>
#### pwm4.sm3tctrl
<link=p.PWM4.SM3TCTRL>
#### p.pwm4.sm3dismap1
<link=p.PWM4.SM3DISMAP1>
#### PWM4.SM3CAPTCOMPA
<link=p.PWM4.SM3CAPTCOMPA>
#### p.PWM4.SM3CAPTCTRLX
<lang=dft>
 (rw)  [1;33m0x403e815c[0m (0x403e8000 + 0x015c)
Capture Control X Register
 (rw) (01)  [0;32mARMX[0m  - [00:00] -  Arm X
      0 - ARMX_0 :
         Input capture operation is disabled.
      0x1 - ARMX_1 :
         Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
 (rw) (01)  [0;32mONESHOTX[0m  - [01:01] -  One Shot Mode Aux
      0 - ONESHOTX_0 :
         Free running mode is selected. If both capture circuits are enabled, th
         en capture circuit 0 is armed first after the ARMX bit is set. Once a c
         apture occurs, capture circuit 0 is disarmed and capture circuit 1 is a
         rmed. After capture circuit 1 performs a capture, it is disarmed and ca
         pture circuit 0 is re-armed. The process continues indefinitely.If only
          one of the capture circuits is enabled, then captures continue indefin
         itely on the enabled capture circuit.
      0x1 - ONESHOTX_1 :
         One shot mode is selected. If both capture circuits are enabled, then c
         apture circuit 0 is armed first after the ARMX bit is set. Once a captu
         re occurs, capture circuit 0 is disarmed and capture circuit 1 is armed
         . After capture circuit 1 performs a capture, it is disarmed and the AR
         MX bit is cleared. No further captures will be performed until the ARMX
          bit is set again.If only one of the capture circuits is enabled, then 
         a single capture will occur on the enabled capture circuit and the ARMX
          bit is then cleared.
 (rw) (02)  [0;32mEDGX0[0m  - [03:02] -  Edge X 0
      0 - EDGX0_0 :
         Disabled
      0x1 - EDGX0_1 :
         Capture falling edges
      0x2 - EDGX0_2 :
         Capture rising edges
      0x3 - EDGX0_3 :
         Capture any edge
 (rw) (02)  [0;32mEDGX1[0m  - [05:04] -  Edge X 1
      0 - EDGX1_0 :
         Disabled
      0x1 - EDGX1_1 :
         Capture falling edges
      0x2 - EDGX1_2 :
         Capture rising edges
      0x3 - EDGX1_3 :
         Capture any edge
 (rw) (01)  [0;32mINP_SELX[0m  - [06:06] -  Input Select X
      0 - INP_SELX_0 :
         Raw PWM_X input signal selected as source.
      0x1 - INP_SELX_1 :
         Output of edge counter/compare selected as source. Note that when this 
         bitfield is set to 1, the internal edge counter is enabled and the risi
         ng and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX
         [EDGX1] fields are ignored. The software must still place a value other
          than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDG
         X1] fields in order to enable one or both of the capture registers.
 (rw) (01)  [0;32mEDGCNTX_EN[0m  - [07:07] -  Edge Counter X Enable
      0 - EDGCNTX_EN_0 :
         Edge counter disabled and held in reset
      0x1 - EDGCNTX_EN_1 :
         Edge counter enabled
 (rw) (02)  [0;32mCFXWM[0m  - [09:08] -  Capture X FIFOs Water Mark
 (ro) (03)  [0;32mCX0CNT[0m  - [12:10] -  Capture X0 FIFO Word Count
 (ro) (03)  [0;32mCX1CNT[0m  - [15:13] -  Capture X1 FIFO Word Count
</lang>
#### p.PWM4.SM3CVAL0
<lang=dft>
 (ro)  [1;33m0x403e8160[0m (0x403e8000 + 0x0160)
Capture Value 0 Register
 (ro) (16)  [0;32mCAPTVAL0[0m  - [15:00] -  CAPTVAL0
</lang>
#### pwm4.sm3cval0
<link=p.PWM4.SM3CVAL0>
#### pwm4.sm3cval0cyc
<link=p.PWM4.SM3CVAL0CYC>
#### pwm4.sm3cval3cyc
<link=p.PWM4.SM3CVAL3CYC>
#### pwm4.outen
<link=p.PWM4.OUTEN>
#### pwm4.mask
<link=p.PWM4.MASK>
#### p.PWM4.FSTS0
<lang=dft>
 (rw)  [1;33m0x403e818e[0m (0x403e8000 + 0x018e)
Fault Status Register
 (rw) (04)  [0;32mFFLAG[0m  - [03:00] -  Fault Flags
      0 - FFLAG_0 :
         No fault on the FAULTx pin.
      0x1 - FFLAG_1 :
         Fault on the FAULTx pin.
 (rw) (04)  [0;32mFFULL[0m  - [07:04] -  Full Cycle
      0 - FFULL_0 :
         PWM outputs are not re-enabled at the start of a full cycle
      0x1 - FFULL_1 :
         PWM outputs are re-enabled at the start of a full cycle
 (ro) (04)  [0;32mFFPIN[0m  - [11:08] -  Filtered Fault Pins
 (rw) (04)  [0;32mFHALF[0m  - [15:12] -  Half Cycle Fault Recovery
      0 - FHALF_0 :
         PWM outputs are not re-enabled at the start of a half cycle.
      0x1 - FHALF_1 :
         PWM outputs are re-enabled at the start of a half cycle (as defined by 
         VAL0).
</lang>
#### p.pwm4.ftst0
<link=p.PWM4.FTST0>
#### p.BEE.AES_KEY0_W1
<lang=dft>
 (rw)  [1;33m0x403ec010[0m (0x403ec000 + 0x0010)
no description available
 (rw) (32)  [0;32mKEY1[0m  - [31:00] -  AES 128 key from software
</lang>
#### BEE.AES_KEY0_W1
<link=p.BEE.AES_KEY0_W1>
#### p.bee.ctr_nonce0_w3
<link=p.BEE.CTR_NONCE0_W3>
#### BEE.CTR_NONCE1_W3
<link=p.BEE.CTR_NONCE1_W3>
#### p.LPI2C1.MCFGR2
<lang=dft>
 (rw)  [1;33m0x403f0028[0m (0x403f0000 + 0x0028)
Master Configuration Register 2
 (rw) (12)  [0;32mBUSIDLE[0m  - [11:00] -  Bus Idle Timeout
 (rw) (04)  [0;32mFILTSCL[0m  - [19:16] -  Glitch Filter SCL
 (rw) (04)  [0;32mFILTSDA[0m  - [27:24] -  Glitch Filter SDA
</lang>
#### p.LPI2C1.SCR
<lang=dft>
 (rw)  [1;33m0x403f0110[0m (0x403f0000 + 0x0110)
Slave Control Register
 (rw) (01)  [0;32mSEN[0m  - [00:00] -  Slave Enable
      0 - SEN_0 :
         I2C Slave mode is disabled
      0x1 - SEN_1 :
         I2C Slave mode is enabled
 (rw) (01)  [0;32mRST[0m  - [01:01] -  Software Reset
      0 - RST_0 :
         Slave mode logic is not reset
      0x1 - RST_1 :
         Slave mode logic is reset
 (rw) (01)  [0;32mFILTEN[0m  - [04:04] -  Filter Enable
      0 - FILTEN_0 :
         Disable digital filter and output delay counter for slave mode
      0x1 - FILTEN_1 :
         Enable digital filter and output delay counter for slave mode
 (rw) (01)  [0;32mFILTDZ[0m  - [05:05] -  Filter Doze Enable
      0 - FILTDZ_0 :
         Filter remains enabled in Doze mode
      0x1 - FILTDZ_1 :
         Filter is disabled in Doze mode
 (rw) (01)  [0;32mRTF[0m  - [08:08] -  Reset Transmit FIFO
      0 - RTF_0 :
         No effect
      0x1 - RTF_1 :
         Transmit Data Register is now empty
 (rw) (01)  [0;32mRRF[0m  - [09:09] -  Reset Receive FIFO
      0 - RRF_0 :
         No effect
      0x1 - RRF_1 :
         Receive Data Register is now empty
</lang>
#### p.lpi2c1.samr
<link=p.LPI2C1.SAMR>
#### p.LPI2C1.STAR
<lang=dft>
 (rw)  [1;33m0x403f0154[0m (0x403f0000 + 0x0154)
Slave Transmit ACK Register
 (rw) (01)  [0;32mTXNACK[0m  - [00:00] -  Transmit NACK
      0 - TXNACK_0 :
         Write a Transmit ACK for each received word
      0x1 - TXNACK_1 :
         Write a Transmit NACK for each received word
</lang>
#### LPI2C2.VERID
<link=p.LPI2C2.VERID>
#### p.lpi2c2.msr
<link=p.LPI2C2.MSR>
#### LPI2C2.MSR
<link=p.LPI2C2.MSR>
#### lpi2c2.mccr0
<link=p.LPI2C2.MCCR0>
#### LPI2C2.MCCR1
<link=p.LPI2C2.MCCR1>
#### p.LPI2C2.SCFGR1
<lang=dft>
 (rw)  [1;33m0x403f4124[0m (0x403f4000 + 0x0124)
Slave Configuration Register 1
 (rw) (01)  [0;32mADRSTALL[0m  - [00:00] -  Address SCL Stall
      0 - ADRSTALL_0 :
         Clock stretching is disabled
      0x1 - ADRSTALL_1 :
         Clock stretching is enabled
 (rw) (01)  [0;32mRXSTALL[0m  - [01:01] -  RX SCL Stall
      0 - RXSTALL_0 :
         Clock stretching is disabled
      0x1 - RXSTALL_1 :
         Clock stretching is enabled
 (rw) (01)  [0;32mTXDSTALL[0m  - [02:02] -  TX Data SCL Stall
      0 - TXDSTALL_0 :
         Clock stretching is disabled
      0x1 - TXDSTALL_1 :
         Clock stretching is enabled
 (rw) (01)  [0;32mACKSTALL[0m  - [03:03] -  ACK SCL Stall
      0 - ACKSTALL_0 :
         Clock stretching is disabled
      0x1 - ACKSTALL_1 :
         Clock stretching is enabled
 (rw) (01)  [0;32mGCEN[0m  - [08:08] -  General Call Enable
      0 - GCEN_0 :
         General Call address is disabled
      0x1 - GCEN_1 :
         General Call address is enabled
 (rw) (01)  [0;32mSAEN[0m  - [09:09] -  SMBus Alert Enable
      0 - SAEN_0 :
         Disables match on SMBus Alert
      0x1 - SAEN_1 :
         Enables match on SMBus Alert
 (rw) (01)  [0;32mTXCFG[0m  - [10:10] -  Transmit Flag Configuration
      0 - TXCFG_0 :
         Transmit Data Flag will only assert during a slave-transmit transfer wh
         en the Transmit Data register is empty
      0x1 - TXCFG_1 :
         Transmit Data Flag will assert whenever the Transmit Data register is e
         mpty
 (rw) (01)  [0;32mRXCFG[0m  - [11:11] -  Receive Data Configuration
      0 - RXCFG_0 :
         Reading the Receive Data register will return received data and clear t
         he Receive Data flag (MSR[RDF]).
      0x1 - RXCFG_1 :
         Reading the Receive Data register when the Address Valid flag (SSR[AVF]
         )is set, will return the Address Status register and clear the Address 
         Valid flag. Reading the Receive Data register when the Address Valid fl
         ag is clear, will return received data and clear the Receive Data flag 
         (MSR[RDF]).
 (rw) (01)  [0;32mIGNACK[0m  - [12:12] -  Ignore NACK
      0 - IGNACK_0 :
         Slave will end transfer when NACK is detected
      0x1 - IGNACK_1 :
         Slave will not end transfer when NACK detected
 (rw) (01)  [0;32mHSMEN[0m  - [13:13] -  High Speed Mode Enable
      0 - HSMEN_0 :
         Disables detection of HS-mode master code
      0x1 - HSMEN_1 :
         Enables detection of HS-mode master code
 (rw) (03)  [0;32mADDRCFG[0m  - [18:16] -  Address Configuration
      0 - ADDRCFG_0 :
         Address match 0 (7-bit)
      0x1 - ADDRCFG_1 :
         Address match 0 (10-bit)
      0x2 - ADDRCFG_2 :
         Address match 0 (7-bit) or Address match 1 (7-bit)
      0x3 - ADDRCFG_3 :
         Address match 0 (10-bit) or Address match 1 (10-bit)
      0x4 - ADDRCFG_4 :
         Address match 0 (7-bit) or Address match 1 (10-bit)
      0x5 - ADDRCFG_5 :
         Address match 0 (10-bit) or Address match 1 (7-bit)
      0x6 - ADDRCFG_6 :
         From Address match 0 (7-bit) to Address match 1 (7-bit)
      0x7 - ADDRCFG_7 :
         From Address match 0 (10-bit) to Address match 1 (10-bit)
</lang>
#### p.lpi2c2.scfgr1
<link=p.LPI2C2.SCFGR1>
#### p.LPI2C2.STAR
<lang=dft>
 (rw)  [1;33m0x403f4154[0m (0x403f4000 + 0x0154)
Slave Transmit ACK Register
 (rw) (01)  [0;32mTXNACK[0m  - [00:00] -  Transmit NACK
      0 - TXNACK_0 :
         Write a Transmit ACK for each received word
      0x1 - TXNACK_1 :
         Write a Transmit NACK for each received word
</lang>
#### p.LPI2C3.MIER
<lang=dft>
 (rw)  [1;33m0x403f8018[0m (0x403f8000 + 0x0018)
Master Interrupt Enable Register
 (rw) (01)  [0;32mTDIE[0m  - [00:00] -  Transmit Data Interrupt Enable
      0 - TDIE_0 :
         Disabled
      0x1 - TDIE_1 :
         Enabled
 (rw) (01)  [0;32mRDIE[0m  - [01:01] -  Receive Data Interrupt Enable
      0 - RDIE_0 :
         Disabled
      0x1 - RDIE_1 :
         Enabled
 (rw) (01)  [0;32mEPIE[0m  - [08:08] -  End Packet Interrupt Enable
      0 - EPIE_0 :
         Disabled
      0x1 - EPIE_1 :
         Enabled
 (rw) (01)  [0;32mSDIE[0m  - [09:09] -  STOP Detect Interrupt Enable
      0 - SDIE_0 :
         Disabled
      0x1 - SDIE_1 :
         Enabled
 (rw) (01)  [0;32mNDIE[0m  - [10:10] -  NACK Detect Interrupt Enable
      0 - NDIE_0 :
         Disabled
      0x1 - NDIE_1 :
         Enabled
 (rw) (01)  [0;32mALIE[0m  - [11:11] -  Arbitration Lost Interrupt Enable
      0 - ALIE_0 :
         Disabled
      0x1 - ALIE_1 :
         Enabled
 (rw) (01)  [0;32mFEIE[0m  - [12:12] -  FIFO Error Interrupt Enable
      0 - FEIE_0 :
         Enabled
      0x1 - FEIE_1 :
         Disabled
 (rw) (01)  [0;32mPLTIE[0m  - [13:13] -  Pin Low Timeout Interrupt Enable
      0 - PLTIE_0 :
         Disabled
      0x1 - PLTIE_1 :
         Enabled
 (rw) (01)  [0;32mDMIE[0m  - [14:14] -  Data Match Interrupt Enable
      0 - DMIE_0 :
         Disabled
      0x1 - DMIE_1 :
         Enabled
</lang>
#### p.lpi2c3.mcfgr3
<link=p.LPI2C3.MCFGR3>
#### lpi2c3.mccr0
<link=p.LPI2C3.MCCR0>
#### LPI2C3.MCCR0
<link=p.LPI2C3.MCCR0>
#### lpi2c3.mrdr
<link=p.LPI2C3.MRDR>
#### LPI2C3.MRDR
<link=p.LPI2C3.MRDR>
#### LPI2C3.SSR
<link=p.LPI2C3.SSR>
#### p.lpi2c4.mcr
<link=p.LPI2C4.MCR>
#### LPI2C4.MCR
<link=p.LPI2C4.MCR>
#### lpi2c4.mier
<link=p.LPI2C4.MIER>
#### p.lpi2c4.mccr0
<link=p.LPI2C4.MCCR0>
#### p.lpi2c4.mrdr
<link=p.LPI2C4.MRDR>
#### LPI2C4.SDER
<link=p.LPI2C4.SDER>
#### p.LPI2C4.SCFGR2
<lang=dft>
 (rw)  [1;33m0x403fc128[0m (0x403fc000 + 0x0128)
Slave Configuration Register 2
 (rw) (04)  [0;32mCLKHOLD[0m  - [03:00] -  Clock Hold Time
 (rw) (06)  [0;32mDATAVD[0m  - [13:08] -  Data Valid Delay
 (rw) (04)  [0;32mFILTSCL[0m  - [19:16] -  Glitch Filter SCL
 (rw) (04)  [0;32mFILTSDA[0m  - [27:24] -  Glitch Filter SDA
</lang>
#### p.systemcontrol
<link=p.SystemControl>
#### p.systemcontrol.ccr
<link=p.SYSTEMCONTROL.CCR>
#### systemcontrol.shpr2
<link=p.SYSTEMCONTROL.SHPR2>
#### SystemControl.SHCSR
<link=p.SYSTEMCONTROL.SHCSR>
#### SystemControl.CFSR
<link=p.SYSTEMCONTROL.CFSR>
#### p.SYSTEMCONTROL.HFSR
<lang=dft>
 (rw)  [1;33m0xe000ed2c[0m (0xe000e000 + 0x0d2c)
HardFault Status register
 (rw) (01)  [0;32mVECTTBL[0m  - [01:01] -  Indicates a BusFault on a vector table read during exception processing.
      0 - VECTTBL_0 :
         no BusFault on vector table read
      0x1 - VECTTBL_1 :
         BusFault on vector table read
 (rw) (01)  [0;32mFORCED[0m  - [30:30] -  Indicates a forced hard fault, generated by escalation of a fault with configur
 able priority that cannot be handles, either because of priority or because it 
 is disabled.
      0 - FORCED_0 :
         no forced HardFault
      0x1 - FORCED_1 :
         forced HardFault
 (rw) (01)  [0;32mDEBUGEVT[0m  - [31:31] -  Reserved for Debug use. When writing to the register you must write 0 to this b
 it, otherwise behavior is Unpredictable.
      0 - DEBUGEVT_0 :
         No Debug event has occurred.
      0x1 - DEBUGEVT_1 :
         Debug event has occurred. The Debug Fault Status Register has been upda
         ted.
</lang>
#### systemcontrol.dfsr
<link=p.SYSTEMCONTROL.DFSR>
#### p.systemcontrol.id_dfr0
<link=p.SYSTEMCONTROL.ID_DFR0>
#### SystemControl.ID_MMFR2
<link=p.SYSTEMCONTROL.ID_MMFR2>
#### systemcontrol.id_isar2
<link=p.SYSTEMCONTROL.ID_ISAR2>
#### SystemControl.ID_ISAR4
<link=p.SYSTEMCONTROL.ID_ISAR4>
#### p.SYSTEMCONTROL.CLIDR
<lang=dft>
 (ro)  [1;33m0xe000ed78[0m (0xe000e000 + 0x0d78)
Cache Level ID register
 (ro) (03)  [0;32mCL1[0m  - [02:00] -  Indicate the type of cache implemented at level 1.
      0 - CL1_0 :
         No cache
      0x1 - CL1_1 :
         Instruction cache only
      0x2 - CL1_2 :
         Data cache only
      0x3 - CL1_3 :
         Separate instruction and data caches
      0x4 - CL1_4 :
         Unified cache
 (ro) (03)  [0;32mCL2[0m  - [05:03] -  Indicate the type of cache implemented at level 2.
      0 - CL2_0 :
         No cache
      0x1 - CL2_1 :
         Instruction cache only
      0x2 - CL2_2 :
         Data cache only
      0x3 - CL2_3 :
         Separate instruction and data caches
      0x4 - CL2_4 :
         Unified cache
 (ro) (03)  [0;32mCL3[0m  - [08:06] -  Indicate the type of cache implemented at level 3.
      0 - CL3_0 :
         No cache
      0x1 - CL3_1 :
         Instruction cache only
      0x2 - CL3_2 :
         Data cache only
      0x3 - CL3_3 :
         Separate instruction and data caches
      0x4 - CL3_4 :
         Unified cache
 (ro) (03)  [0;32mCL4[0m  - [11:09] -  Indicate the type of cache implemented at level 4.
      0 - CL4_0 :
         No cache
      0x1 - CL4_1 :
         Instruction cache only
      0x2 - CL4_2 :
         Data cache only
      0x3 - CL4_3 :
         Separate instruction and data caches
      0x4 - CL4_4 :
         Unified cache
 (ro) (03)  [0;32mCL5[0m  - [14:12] -  Indicate the type of cache implemented at level 5.
      0 - CL5_0 :
         No cache
      0x1 - CL5_1 :
         Instruction cache only
      0x2 - CL5_2 :
         Data cache only
      0x3 - CL5_3 :
         Separate instruction and data caches
      0x4 - CL5_4 :
         Unified cache
 (ro) (03)  [0;32mCL6[0m  - [17:15] -  Indicate the type of cache implemented at level 6.
      0 - CL6_0 :
         No cache
      0x1 - CL6_1 :
         Instruction cache only
      0x2 - CL6_2 :
         Data cache only
      0x3 - CL6_3 :
         Separate instruction and data caches
      0x4 - CL6_4 :
         Unified cache
 (ro) (03)  [0;32mCL7[0m  - [20:18] -  Indicate the type of cache implemented at level 7.
      0 - CL7_0 :
         No cache
      0x1 - CL7_1 :
         Instruction cache only
      0x2 - CL7_2 :
         Data cache only
      0x3 - CL7_3 :
         Separate instruction and data caches
      0x4 - CL7_4 :
         Unified cache
 (ro) (03)  [0;32mLOUIS[0m  - [23:21] -  Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ
 .
      0 - LOUIS_0 :
         0
      0x1 - LOUIS_1 :
         1
      0x2 - LOUIS_2 :
         2
      0x3 - LOUIS_3 :
         3
      0x4 - LOUIS_4 :
         4
      0x5 - LOUIS_5 :
         5
      0x6 - LOUIS_6 :
         6
      0x7 - LOUIS_7 :
         7
 (ro) (03)  [0;32mLOC[0m  - [26:24] -  Level of Coherency for the cache hierarchy
      0 - LOC_0 :
         0
      0x1 - LOC_1 :
         1
      0x2 - LOC_2 :
         2
      0x3 - LOC_3 :
         3
      0x4 - LOC_4 :
         4
      0x5 - LOC_5 :
         5
      0x6 - LOC_6 :
         6
      0x7 - LOC_7 :
         7
 (ro) (03)  [0;32mLOU[0m  - [29:27] -  Level of Unification for the cache hierarchy
      0 - LOU_0 :
         0
      0x1 - LOU_1 :
         1
      0x2 - LOU_2 :
         2
      0x3 - LOU_3 :
         3
      0x4 - LOU_4 :
         4
      0x5 - LOU_5 :
         5
      0x6 - LOU_6 :
         6
      0x7 - LOU_7 :
         7
</lang>
#### p.systemcontrol.cpacr
<link=p.SYSTEMCONTROL.CPACR>
#### p.SYSTEMCONTROL.CM7_DTCMCR
<lang=dft>
 (rw)  [1;33m0xe000ef94[0m (0xe000e000 + 0x0f94)
Data Tightly-Coupled Memory Control Register
 (rw) (01)  [0;32mEN[0m  - [00:00] -  TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
      0 - EN_0 :
         TCM disabled.
      0x1 - EN_1 :
         TCM enabled.
 (rw) (01)  [0;32mRMW[0m  - [01:01] -  Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not 
 the full width of the TCM RAM, use a RMW sequence.
      0 - RMW_0 :
         RMW disabled.
      0x1 - RMW_1 :
         RMW enabled.
 (rw) (01)  [0;32mRETEN[0m  - [02:02] -  Retry phase enable. When enabled the processor guarantees to honor the retry ou
 tput on the corresponding TCM interface, re-executing the instruction which car
 ried out the TCM access.
      0 - RETEN_0 :
         Retry phase disabled.
      0x1 - RETEN_1 :
         Retry phase enabled.
 (ro) (04)  [0;32mSZ[0m  - [06:03] -  TCM size. Indicates the size of the relevant TCM.
      0 - SZ_0 :
         No TCM implemented.
      0x3 - SZ_3 :
         4KB.
      0x4 - SZ_4 :
         8KB.
      0x5 - SZ_5 :
         16KB.
      0x6 - SZ_6 :
         32KB.
      0x7 - SZ_7 :
         64KB.
      0x8 - SZ_8 :
         128KB.
      0x9 - SZ_9 :
         256KB.
      0xA - SZ_10 :
         512KB.
      0xB - SZ_11 :
         1MB.
      0xC - SZ_12 :
         2MB.
      0xD - SZ_13 :
         4MB.
      0xE - SZ_14 :
         8MB.
      0xF - SZ_15 :
         16MB.
</lang>
#### SystemControl.CM7_AHBPCR
<link=p.SYSTEMCONTROL.CM7_AHBPCR>
#### p.systemcontrol.cm7_ahbscr
<link=p.SYSTEMCONTROL.CM7_AHBSCR>
#### p.NVIC.NVICISER1
<lang=dft>
 (rw)  [1;33m0xe000e104[0m (0xe000e100 + 0x0004)
Interrupt Set Enable Register n
 (rw) (32)  [0;32mSETENA[0m  - [31:00] -  Interrupt set enable bits
</lang>
#### NVIC.NVICISER3
<link=p.NVIC.NVICISER3>
#### p.NVIC.NVICICER4
<lang=dft>
 (rw)  [1;33m0xe000e190[0m (0xe000e100 + 0x0090)
Interrupt Clear Enable Register n
 (rw) (32)  [0;32mCLRENA[0m  - [31:00] -  Interrupt clear-enable bits
</lang>
#### NVIC.NVICICER4
<link=p.NVIC.NVICICER4>
#### p.NVIC.NVICISPR3
<lang=dft>
 (rw)  [1;33m0xe000e20c[0m (0xe000e100 + 0x010c)
Interrupt Set Pending Register n
 (rw) (32)  [0;32mSETPEND[0m  - [31:00] -  Interrupt set-pending bits
</lang>
#### NVIC.NVICISPR3
<link=p.NVIC.NVICISPR3>
#### nvic.nvicicpr2
<link=p.NVIC.NVICICPR2>
#### NVIC.NVICICPR4
<link=p.NVIC.NVICICPR4>
#### nvic.nviciabr3
<link=p.NVIC.NVICIABR3>
#### NVIC.NVICIABR4
<link=p.NVIC.NVICIABR4>
#### nvic.nvicip5
<link=p.NVIC.NVICIP5>
#### p.nvic.nvicip7
<link=p.NVIC.NVICIP7>
#### NVIC.NVICIP7
<link=p.NVIC.NVICIP7>
#### nvic.nvicip10
<link=p.NVIC.NVICIP10>
#### NVIC.NVICIP16
<link=p.NVIC.NVICIP16>
#### p.NVIC.NVICIP18
<lang=dft>
 (rw)  [1;33m0xe000e412[0m (0xe000e100 + 0x0312)
Interrupt Priority Register 18
 (rw) (04)  [0;32mPRI18[0m  - [07:04] -  Priority of the INT_CTI1_ERROR interrupt 18
</lang>
#### nvic.nvicip21
<link=p.NVIC.NVICIP21>
#### NVIC.NVICIP23
<link=p.NVIC.NVICIP23>
#### p.NVIC.NVICIP25
<lang=dft>
 (rw)  [1;33m0xe000e419[0m (0xe000e100 + 0x0319)
Interrupt Priority Register 25
 (rw) (04)  [0;32mPRI25[0m  - [07:04] -  Priority of the INT_LPUART6 interrupt 25
</lang>
#### p.nvic.nvicip28
<link=p.NVIC.NVICIP28>
#### NVIC.NVICIP30
<link=p.NVIC.NVICIP30>
#### p.NVIC.NVICIP36
<lang=dft>
 (rw)  [1;33m0xe000e424[0m (0xe000e100 + 0x0324)
Interrupt Priority Register 36
 (rw) (04)  [0;32mPRI36[0m  - [07:04] -  Priority of the INT_CAN1 interrupt 36
</lang>
#### p.nvic.nvicip43
<link=p.NVIC.NVICIP43>
#### NVIC.NVICIP49
<link=p.NVIC.NVICIP49>
#### p.nvic.nvicip50
<link=p.NVIC.NVICIP50>
#### p.NVIC.NVICIP57
<lang=dft>
 (rw)  [1;33m0xe000e439[0m (0xe000e100 + 0x0339)
Interrupt Priority Register 57
 (rw) (04)  [0;32mPRI57[0m  - [07:04] -  Priority of the INT_SAI2 interrupt 57
</lang>
#### p.nvic.nvicip65
<link=p.NVIC.NVICIP65>
#### p.NVIC.NVICIP69
<lang=dft>
 (rw)  [1;33m0xe000e445[0m (0xe000e100 + 0x0345)
Interrupt Priority Register 69
 (rw) (04)  [0;32mPRI69[0m  - [07:04] -  Priority of the INT_DCDC interrupt 69
</lang>
#### nvic.nvicip72
<link=p.NVIC.NVICIP72>
#### p.nvic.nvicip76
<link=p.NVIC.NVICIP76>
#### p.nvic.nvicip87
<link=p.NVIC.NVICIP87>
#### p.NVIC.NVICIP93
<lang=dft>
 (rw)  [1;33m0xe000e45d[0m (0xe000e100 + 0x035d)
Interrupt Priority Register 93
 (rw) (04)  [0;32mPRI93[0m  - [07:04] -  Priority of the INT_RTWDOG interrupt 93
</lang>
#### p.nvic.nvicip94
<link=p.NVIC.NVICIP94>
#### nvic.nvicip99
<link=p.NVIC.NVICIP99>
#### p.nvic.nvicip100
<link=p.NVIC.NVICIP100>
#### NVIC.NVICIP100
<link=p.NVIC.NVICIP100>
#### p.NVIC.NVICIP105
<lang=dft>
 (rw)  [1;33m0xe000e469[0m (0xe000e100 + 0x0369)
Interrupt Priority Register 105
 (rw) (04)  [0;32mPRI105[0m  - [07:04] -  Priority of the INT_PWM1_3 interrupt 105
</lang>
#### nvic.nvicip106
<link=p.NVIC.NVICIP106>
#### p.nvic.nvicip113
<link=p.NVIC.NVICIP113>
#### nvic.nvicip115
<link=p.NVIC.NVICIP115>
#### p.NVIC.NVICIP116
<lang=dft>
 (rw)  [1;33m0xe000e474[0m (0xe000e100 + 0x0374)
Interrupt Priority Register 116
 (rw) (04)  [0;32mPRI116[0m  - [07:04] -  Priority of the INT_XBAR1_IRQ_0_1 interrupt 116
</lang>
#### NVIC.NVICIP117
<link=p.NVIC.NVICIP117>
#### nvic.nvicip120
<link=p.NVIC.NVICIP120>
#### p.NVIC.NVICIP123
<lang=dft>
 (rw)  [1;33m0xe000e47b[0m (0xe000e100 + 0x037b)
Interrupt Priority Register 123
 (rw) (04)  [0;32mPRI123[0m  - [07:04] -  Priority of the INT_ACMP1 interrupt 123
</lang>
#### p.NVIC.NVICIP130
<lang=dft>
 (rw)  [1;33m0xe000e482[0m (0xe000e100 + 0x0382)
Interrupt Priority Register 130
 (rw) (04)  [0;32mPRI130[0m  - [07:04] -  Priority of the INT_ENC2 interrupt 130
</lang>
#### NVIC.NVICIP131
<link=p.NVIC.NVICIP131>
#### nvic.nvicip133
<link=p.NVIC.NVICIP133>
#### p.NVIC.NVICIP149
<lang=dft>
 (rw)  [1;33m0xe000e495[0m (0xe000e100 + 0x0395)
Interrupt Priority Register 149
 (rw) (04)  [0;32mPRI149[0m  - [07:04] -  Priority of the INT_PWM4_2 interrupt 149
</lang>
#### LDVAL1
<link=p.PIT.LDVAL1>
#### TFLG3
<link=p.PIT.TFLG3>
#### tflg3
<link=TFLG3>
#### daccr
<link=DACCR>
#### gpr4
<link=GPR4>
#### gpr15
<link=GPR15>
#### gpr20
<link=GPR20>
#### INT_STATUS
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXRAM.INT_STATUS
   p.TRNG.INT_STATUS
   p.TSC.INT_STATUS
   p.USDHC1.INT_STATUS
   p.USDHC2.INT_STATUS
#### cmph
<link=CMPH>
#### HC3
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ADC1.HC3
   p.ADC2.HC3
#### R0
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ADC1.R0
   p.ADC2.R0
#### r2
<link=R2>
#### GC
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ADC1.GC
   p.ADC2.GC
#### SCR1C
<link=p.TRNG.SCR1C>
#### scr1c
<link=SCR1C>
#### SCR5L
<link=p.TRNG.SCR5L>
#### scr5l
<link=SCR5L>
#### ENT[3]
<link=p.TRNG.ENT[3]>
#### ent[6]
<link=ENT[6]>
#### ent[13]
<link=ENT[13]>
#### hpcomr
<link=HPCOMR>
#### LPLR
<link=p.SNVS.LPLR>
#### lpgpr_alias[1]
<link=LPGPR_alias[1]>
#### lpgpr[1]
<link=LPGPR[1]>
#### PLL_USB2_TOG
<link=p.CCM_ANALOG.PLL_USB2_TOG>
#### PLL_ENET_SET
<link=p.CCM_ANALOG.PLL_ENET_SET>
#### pfd_528_clr
<link=PFD_528_CLR>
#### pfd_528_tog
<link=PFD_528_TOG>
#### MISC1_TOG
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.CCM_ANALOG.MISC1_TOG
   p.PMU.MISC1_TOG
#### REG_3P0
<link=p.PMU.REG_3P0>
#### reg_2p5_tog
<link=REG_2P5_TOG>
#### usb2_chrg_detect_set
<link=USB2_CHRG_DETECT_SET>
#### USB2_CHRG_DETECT_STAT
<link=p.USB_ANALOG.USB2_CHRG_DETECT_STAT>
#### osc_config2
<link=OSC_CONFIG2>
#### ctrl_set
<link=CTRL_SET>
#### CTRL_TOG
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USBPHY1.CTRL_TOG
   p.USBPHY2.CTRL_TOG
   p.OCOTP.CTRL_TOG
   p.PXP.CTRL_TOG
   p.LCDIF.CTRL_TOG
   p.DCP.CTRL_TOG
#### debug
<link=DEBUG>
#### DEBUG1_TOG
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USBPHY1.DEBUG1_TOG
   p.USBPHY2.DEBUG1_TOG
#### CSL2
<link=p.CSU.CSL2>
#### csl9
<link=CSL9>
#### CSL15
<link=p.CSU.CSL15>
#### CSL24
<link=p.CSU.CSL24>
#### csl26
<link=CSL26>
#### CEEI
<link=p.DMA0.CEEI>
#### ceei
<link=CEEI>
#### hrs
<link=HRS>
#### DCHPRI0
<link=p.DMA0.DCHPRI0>
#### dchpri0
<link=DCHPRI0>
#### DCHPRI15
<link=p.DMA0.DCHPRI15>
#### dchpri15
<link=DCHPRI15>
#### DCHPRI24
<link=p.DMA0.DCHPRI24>
#### dchpri24
<link=DCHPRI24>
#### tcd0_slast
<link=TCD0_SLAST>
#### TCD0_DADDR
<link=p.DMA0.TCD0_DADDR>
#### TCD0_CITER_ELINKYES
<link=p.DMA0.TCD0_CITER_ELINKYES>
#### TCD1_NBYTES_MLOFFNO
<link=p.DMA0.TCD1_NBYTES_MLOFFNO>
#### tcd1_nbytes_mloffno
<link=TCD1_NBYTES_MLOFFNO>
#### TCD1_NBYTES_MLOFFYES
<link=p.DMA0.TCD1_NBYTES_MLOFFYES>
#### tcd2_attr
<link=TCD2_ATTR>
#### TCD4_CSR
<link=p.DMA0.TCD4_CSR>
#### tcd5_soff
<link=TCD5_SOFF>
#### tcd5_biter_elinkyes
<link=TCD5_BITER_ELINKYES>
#### tcd6_citer_elinkyes
<link=TCD6_CITER_ELINKYES>
#### TCD7_SLAST
<link=p.DMA0.TCD7_SLAST>
#### TCD8_DLASTSGA
<link=p.DMA0.TCD8_DLASTSGA>
#### tcd8_dlastsga
<link=TCD8_DLASTSGA>
#### TCD8_BITER_ELINKNO
<link=p.DMA0.TCD8_BITER_ELINKNO>
#### tcd9_slast
<link=TCD9_SLAST>
#### TCD9_DADDR
<link=p.DMA0.TCD9_DADDR>
#### tcd9_citer_elinkyes
<link=TCD9_CITER_ELINKYES>
#### TCD9_DLASTSGA
<link=p.DMA0.TCD9_DLASTSGA>
#### TCD9_CSR
<link=p.DMA0.TCD9_CSR>
#### TCD10_SOFF
<link=p.DMA0.TCD10_SOFF>
#### TCD10_CITER_ELINKNO
<link=p.DMA0.TCD10_CITER_ELINKNO>
#### tcd11_attr
<link=TCD11_ATTR>
#### tcd11_nbytes_mloffyes
<link=TCD11_NBYTES_MLOFFYES>
#### tcd11_daddr
<link=TCD11_DADDR>
#### tcd12_saddr
<link=TCD12_SADDR>
#### tcd13_saddr
<link=TCD13_SADDR>
#### TCD13_NBYTES_MLOFFNO
<link=p.DMA0.TCD13_NBYTES_MLOFFNO>
#### TCD13_DOFF
<link=p.DMA0.TCD13_DOFF>
#### TCD13_CITER_ELINKNO
<link=p.DMA0.TCD13_CITER_ELINKNO>
#### TCD16_ATTR
<link=p.DMA0.TCD16_ATTR>
#### TCD16_CSR
<link=p.DMA0.TCD16_CSR>
#### TCD16_BITER_ELINKNO
<link=p.DMA0.TCD16_BITER_ELINKNO>
#### TCD17_NBYTES_MLOFFYES
<link=p.DMA0.TCD17_NBYTES_MLOFFYES>
#### TCD17_CITER_ELINKYES
<link=p.DMA0.TCD17_CITER_ELINKYES>
#### tcd17_citer_elinkyes
<link=TCD17_CITER_ELINKYES>
#### TCD18_NBYTES_MLOFFNO
<link=p.DMA0.TCD18_NBYTES_MLOFFNO>
#### tcd18_biter_elinkyes
<link=TCD18_BITER_ELINKYES>
#### tcd19_biter_elinkyes
<link=TCD19_BITER_ELINKYES>
#### tcd20_attr
<link=TCD20_ATTR>
#### tcd21_nbytes_mlno
<link=TCD21_NBYTES_MLNO>
#### tcd23_doff
<link=TCD23_DOFF>
#### tcd24_csr
<link=TCD24_CSR>
#### tcd25_daddr
<link=TCD25_DADDR>
#### tcd25_dlastsga
<link=TCD25_DLASTSGA>
#### TCD26_SLAST
<link=p.DMA0.TCD26_SLAST>
#### tcd26_citer_elinkno
<link=TCD26_CITER_ELINKNO>
#### tcd26_dlastsga
<link=TCD26_DLASTSGA>
#### tcd26_csr
<link=TCD26_CSR>
#### tcd27_saddr
<link=TCD27_SADDR>
#### tcd27_soff
<link=TCD27_SOFF>
#### tcd27_nbytes_mloffyes
<link=TCD27_NBYTES_MLOFFYES>
#### TCD28_SADDR
<link=p.DMA0.TCD28_SADDR>
#### TCD28_NBYTES_MLNO
<link=p.DMA0.TCD28_NBYTES_MLNO>
#### TCD28_NBYTES_MLOFFYES
<link=p.DMA0.TCD28_NBYTES_MLOFFYES>
#### tcd28_citer_elinkno
<link=TCD28_CITER_ELINKNO>
#### tcd28_dlastsga
<link=TCD28_DLASTSGA>
#### TCD28_BITER_ELINKNO
<link=p.DMA0.TCD28_BITER_ELINKNO>
#### tcd31_slast
<link=TCD31_SLAST>
#### tcd31_citer_elinkyes
<link=TCD31_CITER_ELINKYES>
#### tcd31_csr
<link=TCD31_CSR>
#### chcfg[6]
<link=CHCFG[6]>
#### CHCFG[28]
<link=p.DMAMUX.CHCFG[28]>
#### chcfg[29]
<link=CHCFG[29]>
#### cntr
<link=CNTR>
#### IMR3
<link=p.GPC.IMR3>
#### isr1
<link=ISR1>
#### imr5
<link=IMR5>
#### SBMR2
<link=p.SRC.SBMR2>
#### CSCMR1
<link=p.CCM.CSCMR1>
#### cscdr2
<link=CSCDR2>
#### CCGR2
<link=p.CCM.CCGR2>
#### ccgr2
<link=CCGR2>
#### rompatch5d
<link=ROMPATCH5D>
#### ROMPATCH4D
<link=p.ROMC.ROMPATCH4D>
#### ROMPATCHENL
<link=p.ROMC.ROMPATCHENL>
#### ROMPATCH2A
<link=p.ROMC.ROMPATCH2A>
#### rompatch6a
<link=ROMPATCH6A>
#### rompatch9a
<link=ROMPATCH9A>
#### rompatch14a
<link=ROMPATCH14A>
#### PIN
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXIO1.PIN
   p.FLEXIO2.PIN
   p.FLEXIO3.PIN
#### SHIFTCFG[1]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXIO1.SHIFTCFG[1]
   p.FLEXIO2.SHIFTCFG[1]
   p.FLEXIO3.SHIFTCFG[1]
#### SHIFTBUF[3]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXIO1.SHIFTBUF[3]
   p.FLEXIO2.SHIFTBUF[3]
   p.FLEXIO3.SHIFTBUF[3]
#### shiftbufnbs[3]
<link=SHIFTBUFNBS[3]>
#### shiftbufhws[2]
<link=SHIFTBUFHWS[2]>
#### SHIFTBUFNIS[1]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXIO1.SHIFTBUFNIS[1]
   p.FLEXIO2.SHIFTBUFNIS[1]
   p.FLEXIO3.SHIFTBUFNIS[1]
#### edge_sel
<link=EDGE_SEL>
#### dr_clear
<link=DR_CLEAR>
#### rximr3
<link=RXIMR3>
#### rximr12
<link=RXIMR12>
#### rximr28
<link=RXIMR28>
#### rximr34
<link=RXIMR34>
#### RXIMR45
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.CAN1.RXIMR45
   p.CAN2.RXIMR45
#### RXIMR56
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.CAN1.RXIMR56
   p.CAN2.RXIMR56
#### RXIMR63
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.CAN1.RXIMR63
   p.CAN2.RXIMR63
#### gfwr
<link=GFWR>
#### MB0_8B_WORD1
<link=p.CAN3.MB0_8B_WORD1>
#### word10
<link=WORD10>
#### mb0_32b_word3
<link=MB0_32B_WORD3>
#### MB1_16B_CS
<link=p.CAN3.MB1_16B_CS>
#### mb0_64b_word6
<link=MB0_64B_WORD6>
#### mb1_16b_word1
<link=MB1_16B_WORD1>
#### CS3
<link=p.CAN3.CS3>
#### mb2_16b_cs
<link=MB2_16B_CS>
#### MB0_64B_WORD13
<link=p.CAN3.MB0_64B_WORD13>
#### MB2_16B_WORD3
<link=p.CAN3.MB2_16B_WORD3>
#### MB4_8B_ID
<link=p.CAN3.MB4_8B_ID>
#### MB1_32B_WORD7
<link=p.CAN3.MB1_32B_WORD7>
#### mb1_64b_id
<link=MB1_64B_ID>
#### WORD14
<link=p.CAN3.WORD14>
#### mb3_16b_word0
<link=MB3_16B_WORD0>
#### MB5_8B_WORD1
<link=p.CAN3.MB5_8B_WORD1>
#### MB2_32B_WORD3
<link=p.CAN3.MB2_32B_WORD3>
#### mb2_32b_word4
<link=MB2_32B_WORD4>
#### mb1_64b_word7
<link=MB1_64B_WORD7>
#### cs7
<link=CS7>
#### MB1_64B_WORD13
<link=p.CAN3.MB1_64B_WORD13>
#### WORD08
<link=p.CAN3.WORD08>
#### MB9_8B_WORD1
<link=p.CAN3.MB9_8B_WORD1>
#### MB4_32B_ID
<link=p.CAN3.MB4_32B_ID>
#### MB2_64B_WORD6
<link=p.CAN3.MB2_64B_WORD6>
#### mb11_8b_word0
<link=MB11_8B_WORD0>
#### CS12
<link=p.CAN3.CS12>
#### mb4_32b_word7
<link=MB4_32B_WORD7>
#### word012
<link=WORD012>
#### mb8_16b_word1
<link=MB8_16B_WORD1>
#### MB5_32B_WORD3
<link=p.CAN3.MB5_32B_WORD3>
#### ID14
<link=p.CAN3.ID14>
#### MB10_16B_WORD0
<link=p.CAN3.MB10_16B_WORD0>
#### MB15_8B_WORD0
<link=p.CAN3.MB15_8B_WORD0>
#### mb6_32b_word0
<link=MB6_32B_WORD0>
#### mb10_16b_word2
<link=MB10_16B_WORD2>
#### mb16_8b_word0
<link=MB16_8B_WORD0>
#### mb3_64b_word10
<link=MB3_64B_WORD10>
#### MB3_64B_WORD12
<link=p.CAN3.MB3_64B_WORD12>
#### MB17_8B_ID
<link=p.CAN3.MB17_8B_ID>
#### MB6_32B_WORD7
<link=p.CAN3.MB6_32B_WORD7>
#### MB7_32B_ID
<link=p.CAN3.MB7_32B_ID>
#### WORD117
<link=p.CAN3.WORD117>
#### MB12_16B_WORD0
<link=p.CAN3.MB12_16B_WORD0>
#### mb12_16b_word1
<link=MB12_16B_WORD1>
#### id19
<link=ID19>
#### mb4_64b_word3
<link=MB4_64B_WORD3>
#### MB19_8B_WORD0
<link=p.CAN3.MB19_8B_WORD0>
#### MB4_64B_WORD9
<link=p.CAN3.MB4_64B_WORD9>
#### mb22_8b_cs
<link=MB22_8B_CS>
#### MB8_32B_WORD7
<link=p.CAN3.MB8_32B_WORD7>
#### WORD122
<link=p.CAN3.WORD122>
#### mb5_64b_word2
<link=MB5_64B_WORD2>
#### word023
<link=WORD023>
#### cs24
<link=CS24>
#### mb9_32b_word4
<link=MB9_32B_WORD4>
#### mb16_16b_word2
<link=MB16_16B_WORD2>
#### mb5_64b_word11
<link=MB5_64B_WORD11>
#### word126
<link=WORD126>
#### mb11_32b_id
<link=MB11_32B_ID>
#### ID28
<link=p.CAN3.ID28>
#### MB6_64B_WORD3
<link=p.CAN3.MB6_64B_WORD3>
#### mb11_32b_word4
<link=MB11_32B_WORD4>
#### mb19_16b_word1
<link=MB19_16B_WORD1>
#### MB11_32B_WORD6
<link=p.CAN3.MB11_32B_WORD6>
#### mb6_64b_word9
<link=MB6_64B_WORD9>
#### mb6_64b_word10
<link=MB6_64B_WORD10>
#### MB20_16B_WORD1
<link=p.CAN3.MB20_16B_WORD1>
#### MB31_8B_CS
<link=p.CAN3.MB31_8B_CS>
#### MB21_16B_ID
<link=p.CAN3.MB21_16B_ID>
#### WORD131
<link=p.CAN3.WORD131>
#### MB21_16B_WORD1
<link=p.CAN3.MB21_16B_WORD1>
#### MB13_32B_ID
<link=p.CAN3.MB13_32B_ID>
#### MB7_64B_WORD3
<link=p.CAN3.MB7_64B_WORD3>
#### MB22_16B_WORD0
<link=p.CAN3.MB22_16B_WORD0>
#### MB13_32B_WORD4
<link=p.CAN3.MB13_32B_WORD4>
#### mb7_64b_word8
<link=MB7_64B_WORD8>
#### mb13_32b_word7
<link=MB13_32B_WORD7>
#### MB23_16B_WORD2
<link=p.CAN3.MB23_16B_WORD2>
#### word135
<link=WORD135>
#### MB36_8B_ID
<link=p.CAN3.MB36_8B_ID>
#### MB36_8B_WORD0
<link=p.CAN3.MB36_8B_WORD0>
#### cs38
<link=CS38>
#### mb15_32b_word0
<link=MB15_32B_WORD0>
#### MB15_32B_WORD2
<link=p.CAN3.MB15_32B_WORD2>
#### MB25_16B_WORD2
<link=p.CAN3.MB25_16B_WORD2>
#### WORD038
<link=p.CAN3.WORD038>
#### mb26_16b_id
<link=MB26_16B_ID>
#### MB41_8B_ID
<link=p.CAN3.MB41_8B_ID>
#### mb42_8b_cs
<link=MB42_8B_CS>
#### MB17_32B_WORD0
<link=p.CAN3.MB17_32B_WORD0>
#### mb43_8b_id
<link=MB43_8B_ID>
#### MB43_8B_WORD0
<link=p.CAN3.MB43_8B_WORD0>
#### mb17_32b_word3
<link=MB17_32B_WORD3>
#### MB9_64B_WORD14
<link=p.CAN3.MB9_64B_WORD14>
#### mb29_16b_word3
<link=MB29_16B_WORD3>
#### CS45
<link=p.CAN3.CS45>
#### mb30_16b_id
<link=MB30_16B_ID>
#### id46
<link=ID46>
#### mb18_32b_word4
<link=MB18_32B_WORD4>
#### mb10_64b_word7
<link=MB10_64B_WORD7>
#### MB18_32B_WORD7
<link=p.CAN3.MB18_32B_WORD7>
#### word147
<link=WORD147>
#### cs49
<link=CS49>
#### MB33_16B_ID
<link=p.CAN3.MB33_16B_ID>
#### MB11_64B_WORD4
<link=p.CAN3.MB11_64B_WORD4>
#### mb11_64b_word5
<link=MB11_64B_WORD5>
#### MB34_16B_WORD0
<link=p.CAN3.MB34_16B_WORD0>
#### cs52
<link=CS52>
#### MB52_8B_CS
<link=p.CAN3.MB52_8B_CS>
#### MB21_32B_CS
<link=p.CAN3.MB21_32B_CS>
#### WORD052
<link=p.CAN3.WORD052>
#### MB53_8B_CS
<link=p.CAN3.MB53_8B_CS>
#### mb53_8b_word0
<link=MB53_8B_WORD0>
#### mb21_32b_word5
<link=MB21_32B_WORD5>
#### MB36_16B_ID
<link=p.CAN3.MB36_16B_ID>
#### MB36_16B_WORD2
<link=p.CAN3.MB36_16B_WORD2>
#### id55
<link=ID55>
#### MB22_32B_ID
<link=p.CAN3.MB22_32B_ID>
#### mb36_16b_word3
<link=MB36_16B_WORD3>
#### mb56_8b_cs
<link=MB56_8B_CS>
#### MB56_8B_WORD1
<link=p.CAN3.MB56_8B_WORD1>
#### mb22_32b_word6
<link=MB22_32B_WORD6>
#### mb57_8b_id
<link=MB57_8B_ID>
#### mb12_64b_word14
<link=MB12_64B_WORD14>
#### word158
<link=WORD158>
#### ID59
<link=p.CAN3.ID59>
#### mb23_32b_word5
<link=MB23_32B_WORD5>
#### id60
<link=ID60>
#### MB60_8B_WORD0
<link=p.CAN3.MB60_8B_WORD0>
#### MB40_16B_WORD3
<link=p.CAN3.MB40_16B_WORD3>
#### MB13_64B_WORD10
<link=p.CAN3.MB13_64B_WORD10>
#### MB41_16B_WORD3
<link=p.CAN3.MB41_16B_WORD3>
#### MB63_8B_WORD0
<link=p.CAN3.MB63_8B_WORD0>
#### WORD063
<link=p.CAN3.WORD063>
#### RXIMR[15]
<link=p.CAN3.RXIMR[15]>
#### RXIMR[24]
<link=p.CAN3.RXIMR[24]>
#### rximr[26]
<link=RXIMR[26]>
#### RXIMR[33]
<link=p.CAN3.RXIMR[33]>
#### RXIMR[38]
<link=p.CAN3.RXIMR[38]>
#### rximr[41]
<link=RXIMR[41]>
#### rximr[52]
<link=RXIMR[52]>
#### RXIMR[54]
<link=p.CAN3.RXIMR[54]>
#### ENCBT
<link=p.CAN3.ENCBT>
#### fdcbt
<link=FDCBT>
#### HR_TIME_STAMP[7]
<link=p.CAN3.HR_TIME_STAMP[7]>
#### HR_TIME_STAMP[11]
<link=p.CAN3.HR_TIME_STAMP[11]>
#### hr_time_stamp[19]
<link=HR_TIME_STAMP[19]>
#### HR_TIME_STAMP[20]
<link=p.CAN3.HR_TIME_STAMP[20]>
#### hr_time_stamp[22]
<link=HR_TIME_STAMP[22]>
#### HR_TIME_STAMP[27]
<link=p.CAN3.HR_TIME_STAMP[27]>
#### HR_TIME_STAMP[34]
<link=p.CAN3.HR_TIME_STAMP[34]>
#### hr_time_stamp[53]
<link=HR_TIME_STAMP[53]>
#### hr_time_stamp[56]
<link=HR_TIME_STAMP[56]>
#### HR_TIME_STAMP[58]
<link=p.CAN3.HR_TIME_STAMP[58]>
#### erffel[8]
<link=ERFFEL[8]>
#### erffel[33]
<link=ERFFEL[33]>
#### ERFFEL[49]
<link=p.CAN3.ERFFEL[49]>
#### ERFFEL[51]
<link=p.CAN3.ERFFEL[51]>
#### erffel[51]
<link=ERFFEL[51]>
#### erffel[92]
<link=ERFFEL[92]>
#### ERFFEL[98]
<link=p.CAN3.ERFFEL[98]>
#### erffel[98]
<link=ERFFEL[98]>
#### ERFFEL[108]
<link=p.CAN3.ERFFEL[108]>
#### ERFFEL[111]
<link=p.CAN3.ERFFEL[111]>
#### erffel[111]
<link=ERFFEL[111]>
#### ERFFEL[114]
<link=p.CAN3.ERFFEL[114]>
#### ERFFEL[125]
<link=p.CAN3.ERFFEL[125]>
#### hold0
<link=HOLD0>
#### CTRL0
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.TMR1.CTRL0
   p.TMR2.CTRL0
   p.TMR3.CTRL0
   p.TMR4.CTRL0
   p.XBARA1.CTRL0
#### CMPLD10
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.TMR1.CMPLD10
   p.TMR2.CMPLD10
   p.TMR3.CMPLD10
   p.TMR4.CMPLD10
#### CSCTRL3
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.TMR1.CSCTRL3
   p.TMR2.CSCTRL3
   p.TMR3.CSCTRL3
   p.TMR4.CSCTRL3
#### filt3
<link=FILT3>
#### IR
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.GPT1.IR
   p.GPT2.IR
#### scs_tog
<link=SCS_TOG>
#### mem1
<link=MEM1>
#### MEM3
<link=p.OCOTP.MEM3>
#### sjc_resp1
<link=SJC_RESP1>
#### gp2
<link=GP2>
#### sw_gp22
<link=SW_GP22>
#### misc_conf0
<link=MISC_CONF0>
#### GP33
<link=p.OCOTP.GP33>
#### SW_MUX_CTL_PAD_GPIO_EMC_19
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_19>
#### sw_mux_ctl_pad_gpio_emc_19
<link=SW_MUX_CTL_PAD_GPIO_EMC_19>
#### SW_MUX_CTL_PAD_GPIO_EMC_28
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_28>
#### sw_mux_ctl_pad_gpio_emc_28
<link=SW_MUX_CTL_PAD_GPIO_EMC_28>
#### SW_MUX_CTL_PAD_GPIO_EMC_36
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_EMC_36>
#### sw_mux_ctl_pad_gpio_emc_36
<link=SW_MUX_CTL_PAD_GPIO_EMC_36>
#### sw_mux_ctl_pad_gpio_ad_b0_02
<link=SW_MUX_CTL_PAD_GPIO_AD_B0_02>
#### SW_MUX_CTL_PAD_GPIO_AD_B0_06
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_B0_06>
#### sw_mux_ctl_pad_gpio_ad_b0_15
<link=SW_MUX_CTL_PAD_GPIO_AD_B0_15>
#### sw_mux_ctl_pad_gpio_ad_b1_08
<link=SW_MUX_CTL_PAD_GPIO_AD_B1_08>
#### sw_mux_ctl_pad_gpio_b0_09
<link=SW_MUX_CTL_PAD_GPIO_B0_09>
#### SW_MUX_CTL_PAD_GPIO_B0_11
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_B0_11>
#### sw_mux_ctl_pad_gpio_sd_b1_08
<link=SW_MUX_CTL_PAD_GPIO_SD_B1_08>
#### sw_pad_ctl_pad_gpio_emc_02
<link=SW_PAD_CTL_PAD_GPIO_EMC_02>
#### SW_PAD_CTL_PAD_GPIO_EMC_09
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_09>
#### sw_pad_ctl_pad_gpio_emc_19
<link=SW_PAD_CTL_PAD_GPIO_EMC_19>
#### sw_pad_ctl_pad_gpio_emc_24
<link=SW_PAD_CTL_PAD_GPIO_EMC_24>
#### SW_PAD_CTL_PAD_GPIO_EMC_31
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_EMC_31>
#### SW_PAD_CTL_PAD_GPIO_AD_B0_03
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B0_03>
#### sw_pad_ctl_pad_gpio_ad_b0_08
<link=SW_PAD_CTL_PAD_GPIO_AD_B0_08>
#### sw_pad_ctl_pad_gpio_ad_b1_03
<link=SW_PAD_CTL_PAD_GPIO_AD_B1_03>
#### SW_PAD_CTL_PAD_GPIO_AD_B1_05
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_B1_05>
#### sw_pad_ctl_pad_gpio_ad_b1_14
<link=SW_PAD_CTL_PAD_GPIO_AD_B1_14>
#### sw_pad_ctl_pad_gpio_b0_08
<link=SW_PAD_CTL_PAD_GPIO_B0_08>
#### SW_PAD_CTL_PAD_GPIO_B0_09
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B0_09>
#### SW_PAD_CTL_PAD_GPIO_B0_13
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B0_13>
#### sw_pad_ctl_pad_gpio_b0_14
<link=SW_PAD_CTL_PAD_GPIO_B0_14>
#### sw_pad_ctl_pad_gpio_b1_00
<link=SW_PAD_CTL_PAD_GPIO_B1_00>
#### SW_PAD_CTL_PAD_GPIO_B1_15
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_B1_15>
#### SW_PAD_CTL_PAD_GPIO_SD_B1_00
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_B1_00>
#### sw_pad_ctl_pad_gpio_sd_b1_10
<link=SW_PAD_CTL_PAD_GPIO_SD_B1_10>
#### flexpwm1_pwmb1_select_input
<link=FLEXPWM1_PWMB1_SELECT_INPUT>
#### FLEXPWM1_PWMB2_SELECT_INPUT
<link=p.IOMUXC.FLEXPWM1_PWMB2_SELECT_INPUT>
#### flexpwm2_pwma3_select_input
<link=FLEXPWM2_PWMA3_SELECT_INPUT>
#### flexpwm2_pwmb3_select_input
<link=FLEXPWM2_PWMB3_SELECT_INPUT>
#### FLEXSPIA_DQS_SELECT_INPUT
<link=p.IOMUXC.FLEXSPIA_DQS_SELECT_INPUT>
#### flexspia_data2_select_input
<link=FLEXSPIA_DATA2_SELECT_INPUT>
#### lpi2c4_sda_select_input
<link=LPI2C4_SDA_SELECT_INPUT>
#### lpspi4_sdo_select_input
<link=LPSPI4_SDO_SELECT_INPUT>
#### LPUART3_CTS_B_SELECT_INPUT
<link=p.IOMUXC.LPUART3_CTS_B_SELECT_INPUT>
#### LPUART6_RX_SELECT_INPUT
<link=p.IOMUXC.LPUART6_RX_SELECT_INPUT>
#### qtimer2_timer2_select_input
<link=QTIMER2_TIMER2_SELECT_INPUT>
#### SAI2_RX_DATA0_SELECT_INPUT
<link=p.IOMUXC.SAI2_RX_DATA0_SELECT_INPUT>
#### sai2_tx_bclk_select_input
<link=SAI2_TX_BCLK_SELECT_INPUT>
#### usdhc2_data0_select_input
<link=USDHC2_DATA0_SELECT_INPUT>
#### usdhc2_data7_select_input
<link=USDHC2_DATA7_SELECT_INPUT>
#### xbar1_in03_select_input
<link=XBAR1_IN03_SELECT_INPUT>
#### XBAR1_IN04_SELECT_INPUT
<link=p.IOMUXC.XBAR1_IN04_SELECT_INPUT>
#### xbar1_in04_select_input
<link=XBAR1_IN04_SELECT_INPUT>
#### xbar1_in16_select_input
<link=XBAR1_IN16_SELECT_INPUT>
#### SW_MUX_CTL_PAD_GPIO_SPI_B0_04
<link=p.IOMUXC.SW_MUX_CTL_PAD_GPIO_SPI_B0_04>
#### sw_mux_ctl_pad_gpio_spi_b0_10
<link=SW_MUX_CTL_PAD_GPIO_SPI_B0_10>
#### sw_mux_ctl_pad_gpio_spi_b1_04
<link=SW_MUX_CTL_PAD_GPIO_SPI_B1_04>
#### SW_PAD_CTL_PAD_GPIO_SPI_B0_00
<link=p.IOMUXC.SW_PAD_CTL_PAD_GPIO_SPI_B0_00>
#### ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT
<link=p.IOMUXC.ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT>
#### enet2_ipp_ind_mac0_txclk_select_input
<link=ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT>
#### FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT
<link=p.IOMUXC.FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT>
#### SEMC_I_IPP_IND_DQS4_SELECT_INPUT
<link=p.IOMUXC.SEMC_I_IPP_IND_DQS4_SELECT_INPUT>
#### kpdr
<link=KPDR>
#### flshb1cr0
<link=FLSHB1CR0>
#### STS0
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.STS0
   p.FLEXSPI2.STS0
   p.SEMC.STS0
#### sts2
<link=STS2>
#### RFDR[1]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.RFDR[1]
   p.FLEXSPI2.RFDR[1]
#### RFDR[12]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.RFDR[12]
   p.FLEXSPI2.RFDR[12]
#### RFDR[18]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.RFDR[18]
   p.FLEXSPI2.RFDR[18]
#### RFDR[20]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.RFDR[20]
   p.FLEXSPI2.RFDR[20]
#### rfdr[23]
<link=RFDR[23]>
#### TFDR[8]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.TFDR[8]
   p.FLEXSPI2.TFDR[8]
#### tfdr[8]
<link=TFDR[8]>
#### lut[5]
<link=LUT[5]>
#### LUT[36]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.LUT[36]
   p.FLEXSPI2.LUT[36]
#### lut[36]
<link=LUT[36]>
#### lut[42]
<link=LUT[42]>
#### lut[48]
<link=LUT[48]>
#### LUT[61]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.FLEXSPI.LUT[61]
   p.FLEXSPI2.LUT[61]
#### STAT_TOG
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PXP.STAT_TOG
   p.DCP.STAT_TOG
#### out_ctrl
<link=OUT_CTRL>
#### ps_ubuf
<link=PS_UBUF>
#### ps_vbuf
<link=PS_VBUF>
#### PS_PITCH
<link=p.PXP.PS_PITCH>
#### VDCTRL1
<link=p.LCDIF.VDCTRL1>
#### vdctrl1
<link=VDCTRL1>
#### pigeonctrl2_tog
<link=PIGEONCTRL2_TOG>
#### PIGEON_2_1
<link=p.LCDIF.PIGEON_2_1>
#### PIGEON_7_1
<link=p.LCDIF.PIGEON_7_1>
#### pigeon_8_1
<link=PIGEON_8_1>
#### pigeon_11_2
<link=PIGEON_11_2>
#### LUT0_DATA
<link=p.LCDIF.LUT0_DATA>
#### cmd_xfr_typ
<link=CMD_XFR_TYP>
#### CMD_RSP2
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USDHC1.CMD_RSP2
   p.USDHC2.CMD_RSP2
#### int_status_en
<link=INT_STATUS_EN>
#### WTMK_LVL
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USDHC1.WTMK_LVL
   p.USDHC2.WTMK_LVL
#### force_event
<link=FORCE_EVENT>
#### adma_err_status
<link=ADMA_ERR_STATUS>
#### CLK_TUNE_CTRL_STATUS
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USDHC1.CLK_TUNE_CTRL_STATUS
   p.USDHC2.CLK_TUNE_CTRL_STATUS
#### palr
<link=PALR>
#### rdsr
<link=RDSR>
#### RSFL
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.RSFL
   p.ENET2.RSFL
#### TAFL
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.TAFL
   p.ENET2.TAFL
#### rmon_t_p64
<link=RMON_T_P64>
#### RMON_T_P1024TO2047
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.RMON_T_P1024TO2047
   p.ENET2.RMON_T_P1024TO2047
#### RMON_T_P_GTE2048
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.RMON_T_P_GTE2048
   p.ENET2.RMON_T_P_GTE2048
#### RMON_R_OVERSIZE
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.RMON_R_OVERSIZE
   p.ENET2.RMON_R_OVERSIZE
#### RMON_R_P512TO1023
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.RMON_R_P512TO1023
   p.ENET2.RMON_R_P512TO1023
#### rmon_r_p1024to2047
<link=RMON_R_P1024TO2047>
#### IEEE_R_DROP
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.IEEE_R_DROP
   p.ENET2.IEEE_R_DROP
#### TGSR
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENET.TGSR
   p.ENET2.TGSR
#### tgsr
<link=TGSR>
#### HWGENERAL
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USB1.HWGENERAL
   p.USB2.HWGENERAL
#### HWTXBUF
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USB1.HWTXBUF
   p.USB2.HWTXBUF
#### BURSTSIZE
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USB1.BURSTSIZE
   p.USB2.BURSTSIZE
#### ENDPTNAK
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USB1.ENDPTNAK
   p.USB2.ENDPTNAK
#### portsc1
<link=PORTSC1>
#### ENDPTCTRL6
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.USB1.ENDPTCTRL6
   p.USB2.ENDPTCTRL6
#### usb_otg1_ctrl
<link=USB_OTG1_CTRL>
#### br5
<link=BR5>
#### SRAMCR1
<link=p.SEMC.SRAMCR1>
#### STS13
<link=p.SEMC.STS13>
#### sts15
<link=STS15>
#### capability0
<link=CAPABILITY0>
#### packet2
<link=PACKET2>
#### PACKET5
<link=p.DCP.PACKET5>
#### ch0sema
<link=CH0SEMA>
#### CH1OPTS_TOG
<link=p.DCP.CH1OPTS_TOG>
#### PAGETABLE
<link=p.DCP.PAGETABLE>
#### STCSCL
<link=p.SPDIF.STCSCL>
#### tcr5
<link=TCR5>
#### tdr[1]
<link=TDR[1]>
#### TDR[2]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.SAI1.TDR[2]
   p.SAI2.TDR[2]
   p.SAI3.TDR[2]
#### TFR[1]
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.SAI1.TFR[1]
   p.SAI2.TFR[1]
   p.SAI3.TFR[1]
#### TRIG0_COUNTER
<link=p.ADC_ETC.TRIG0_COUNTER>
#### trig1_chain_5_4
<link=TRIG1_CHAIN_5_4>
#### trig1_chain_7_6
<link=TRIG1_CHAIN_7_6>
#### TRIG4_RESULT_3_2
<link=p.ADC_ETC.TRIG4_RESULT_3_2>
#### TRIG4_RESULT_5_4
<link=p.ADC_ETC.TRIG4_RESULT_5_4>
#### TRIG6_COUNTER
<link=p.ADC_ETC.TRIG6_COUNTER>
#### TRIG7_RESULT_5_4
<link=p.ADC_ETC.TRIG7_RESULT_5_4>
#### TRIG7_RESULT_7_6
<link=p.ADC_ETC.TRIG7_RESULT_7_6>
#### BFCRT010
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.AOI1.BFCRT010
   p.AOI2.BFCRT010
#### sel14
<link=SEL14>
#### sel21
<link=SEL21>
#### SEL23
<link=p.XBARA1.SEL23>
#### SEL41
<link=p.XBARA1.SEL41>
#### sel43
<link=SEL43>
#### SEL56
<link=p.XBARA1.SEL56>
#### sel58
<link=SEL58>
#### rev
<link=REV>
#### lpos
<link=LPOS>
#### UINIT
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.ENC1.UINIT
   p.ENC2.UINIT
   p.ENC3.UINIT
   p.ENC4.UINIT
#### sm0fracval3
<link=SM0FRACVAL3>
#### SM0FRACVAL4
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM0FRACVAL4
   p.PWM2.SM0FRACVAL4
   p.PWM3.SM0FRACVAL4
   p.PWM4.SM0FRACVAL4
#### SM0DISMAP1
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM0DISMAP1
   p.PWM2.SM0DISMAP1
   p.PWM3.SM0DISMAP1
   p.PWM4.SM0DISMAP1
#### SM0CAPTCTRLA
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM0CAPTCTRLA
   p.PWM2.SM0CAPTCTRLA
   p.PWM3.SM0CAPTCTRLA
   p.PWM4.SM0CAPTCTRLA
#### sm0captctrla
<link=SM0CAPTCTRLA>
#### SM0CAPTCOMPA
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM0CAPTCOMPA
   p.PWM2.SM0CAPTCOMPA
   p.PWM3.SM0CAPTCOMPA
   p.PWM4.SM0CAPTCOMPA
#### sm0cval0
<link=SM0CVAL0>
#### SM1FRACVAL1
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM1FRACVAL1
   p.PWM2.SM1FRACVAL1
   p.PWM3.SM1FRACVAL1
   p.PWM4.SM1FRACVAL1
#### SM1INTEN
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM1INTEN
   p.PWM2.SM1INTEN
   p.PWM3.SM1INTEN
   p.PWM4.SM1INTEN
#### SM1DTCNT1
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM1DTCNT1
   p.PWM2.SM1DTCNT1
   p.PWM3.SM1DTCNT1
   p.PWM4.SM1DTCNT1
#### SM1CVAL4
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM1CVAL4
   p.PWM2.SM1CVAL4
   p.PWM3.SM1CVAL4
   p.PWM4.SM1CVAL4
#### sm2ctrl
<link=SM2CTRL>
#### sm2val0
<link=SM2VAL0>
#### sm2fracval2
<link=SM2FRACVAL2>
#### SM2VAL2
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM2VAL2
   p.PWM2.SM2VAL2
   p.PWM3.SM2VAL2
   p.PWM4.SM2VAL2
#### SM2FRCTRL
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM2FRCTRL
   p.PWM2.SM2FRCTRL
   p.PWM3.SM2FRCTRL
   p.PWM4.SM2FRCTRL
#### sm2dtcnt0
<link=SM2DTCNT0>
#### sm2captctrla
<link=SM2CAPTCTRLA>
#### sm2cval2cyc
<link=SM2CVAL2CYC>
#### sm2cval3cyc
<link=SM2CVAL3CYC>
#### sm3val1
<link=SM3VAL1>
#### SM3FRACVAL2
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM3FRACVAL2
   p.PWM2.SM3FRACVAL2
   p.PWM3.SM3FRACVAL2
   p.PWM4.SM3FRACVAL2
#### SM3VAL3
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM3VAL3
   p.PWM2.SM3VAL3
   p.PWM3.SM3VAL3
   p.PWM4.SM3VAL3
#### sm3fracval5
<link=SM3FRACVAL5>
#### SM3DTCNT1
<lang=dft>
多个外设有这个寄存器/ multiple same names:
   p.PWM1.SM3DTCNT1
   p.PWM2.SM3DTCNT1
   p.PWM3.SM3DTCNT1
   p.PWM4.SM3DTCNT1
#### sm3captctrla
<link=SM3CAPTCTRLA>
#### sm3cval2
<link=SM3CVAL2>
#### fctrl20
<link=FCTRL20>
#### aes_key0_w2
<link=AES_KEY0_W2>
#### ICSR
<link=p.SystemControl.ICSR>
#### icsr
<link=ICSR>
#### ID_ISAR3
<link=p.SystemControl.ID_ISAR3>
#### CSSELR
<link=p.SystemControl.CSSELR>
#### iciallu
<link=ICIALLU>
#### ICIMVAU
<link=p.SystemControl.ICIMVAU>
#### DCISW
<link=p.SystemControl.DCISW>
#### cm7_dtcmcr
<link=CM7_DTCMCR>
#### NVICICER0
<link=p.NVIC.NVICICER0>
#### nvicicpr1
<link=NVICICPR1>
#### NVICICPR2
<link=p.NVIC.NVICICPR2>
#### nvicip3
<link=NVICIP3>
#### nvicip19
<link=NVICIP19>
#### nvicip21
<link=NVICIP21>
#### NVICIP31
<link=p.NVIC.NVICIP31>
#### nvicip43
<link=NVICIP43>
#### NVICIP48
<link=p.NVIC.NVICIP48>
#### NVICIP53
<link=p.NVIC.NVICIP53>
#### nvicip54
<link=NVICIP54>
#### NVICIP67
<link=p.NVIC.NVICIP67>
#### nvicip72
<link=NVICIP72>
#### nvicip87
<link=NVICIP87>
#### nvicip90
<link=NVICIP90>
#### NVICIP97
<link=p.NVIC.NVICIP97>
#### nvicip100
<link=NVICIP100>
#### nvicip117
<link=NVICIP117>
#### nvicip126
<link=NVICIP126>
#### NVICIP130
<link=p.NVIC.NVICIP130>
#### nvicip139
<link=NVICIP139>
#### NVICIP145
<link=p.NVIC.NVICIP145>
#### NVICIP152
<link=p.NVIC.NVICIP152>
